/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall adler32_implementation(__int64 a1, __int64 a2);
__int64 __fastcall adler32_final(__int64 a1, __int64 a2);
__int64 __fastcall adler32_oneshot(__int64 a1, __int64 a2);
__int64 adler32_setup();
__int64 __fastcall CCKeyDerivationHMac(int a1, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, char *a12, __int64 a13, __int64 a14, __int64 a15);
signed __int64 __fastcall gen_std_crc_table(__int64 a1);
// int __usercall dump_crc_table@<eax>(__int64 a1@<rax>, __int64 a2@<rdi>);
__int64 __fastcall crc_normal_init(__int64 a1);
signed __int64 __fastcall __crc_normal_init_block_invoke(__int64 a1);
unsigned __int64 __fastcall crc_normal_update(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall crc_normal_final(__int64 a1, __int64 a2);
unsigned __int64 __fastcall crc_normal_oneshot(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall __crc_normal_oneshot_block_invoke(__int64 a1);
__int64 __fastcall reflect_byte(__int64 a1);
__int64 __fastcall reflect(__int64 a1, unsigned __int64 a2);
__int64 __fastcall crc_reverse_init(__int64 a1);
signed __int64 __fastcall __crc_reverse_init_block_invoke(__int64 a1);
unsigned __int64 __fastcall crc_reverse_update(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall crc_reverse_final(__int64 a1, __int64 a2);
unsigned __int64 __fastcall crc_reverse_oneshot(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall __crc_reverse_oneshot_block_invoke(__int64 a1);
__int64 __fastcall reverse_poly(__int64 a1, unsigned __int64 a2);
// __int64 __usercall ccdebug_imp@<rax>(int level@<edi>, char a2@<al>, char *a3@<rdx>, __int64 a4@<rcx>, __int64 a5@<rsi>, __int64 a6@<r8>, __int64 a7@<r9>, __int128 a8@<xmm0>, __int128 a9@<xmm1>, __int128 a10@<xmm2>, __int128 a11@<xmm3>, __int128 a12@<xmm4>, __int128 a13@<xmm5>, __int128 a14@<xmm6>, __int128 a15@<xmm7>, char a16);
int __fastcall __ccdebug_init_block_invoke(__int64 a1);
void *__fastcall CCCreateBigNum(__int64 a1);
__int64 __fastcall CCBigNumClear(__int64 a1);
void __fastcall CCBigNumFree(void *a1);
void *__fastcall CCBigNumCopy(__int64 a1);
int __fastcall CCBigNumBitCount(__int64 a1);
int __fastcall CCBigNumZeroLSBCount(__int64 a1);
int __fastcall CCBigNumByteCount(__int64 a1);
void *__fastcall CCBigNumFromData(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall CCBigNumToData(__int64 a1, __int64 a2, __int64 a3);
void *__fastcall CCBigNumFromHexString(__int64 a1, const char *a2);
void *__fastcall CCBigNumToHexString(__int64 a1, __int64 a2);
void *__fastcall CCBigNumFromDecimalString(__int64 a1, const char *a2);
void *__fastcall CCBigNumToDecimalString(__int64 a1, __int64 a2);
int CCBigNumCompare();
int CCBigNumCompareI();
__int64 CCBigNumSetNegative();
__int64 __fastcall CCBigNumSetI(__int64 a1, __int64 a2);
// __int64 __usercall CCBigNumGetI@<rax>(__int64 a1@<rax>, __int64 a2@<rdi>, __int64 a3@<rsi>);
// void *__usercall CCBigNumCreateRandom@<rax>(int a1@<edx>, int a2@<ecx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5@<r9>, __int128 a6@<xmm0>, __int128 a7@<xmm1>, __int128 a8@<xmm2>, __int128 a9@<xmm3>, __int128 a10@<xmm4>, __int128 a11@<xmm5>, __int128 a12@<xmm6>, __int128 a13@<xmm7>);
__int64 CCBigNumAdd();
__int64 CCBigNumAddI();
__int64 CCBigNumSub();
__int64 CCBigNumSubI();
__int64 CCBigNumMul();
__int64 CCBigNumMulI();
__int64 CCBigNumDiv();
__int64 __fastcall CCBigNumDiv2(__int64 a1, __int64 a2);
__int64 __fastcall CCBigNumMod(__int64 a1, __int64 a2, __int64 a3);
// __int64 __usercall CCBigNumModI@<rax>(__int64 a1@<rax>, unsigned int a2@<edx>, __int64 a3@<rdi>, __int64 a4@<rsi>);
__int64 CCBigNumSquare();
__int64 CCBigNumGCD();
__int64 CCBigNumLCM();
__int64 CCBigNumMulMod();
__int64 CCBigNumSquareMod();
__int64 CCBigNumInverseMod();
__int64 CCBigNumModExp();
__int64 __fastcall CCBigNumLeftShift(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall CCBigNumRightShift(__int64 a1, __int64 a2, unsigned int a3);
signed __int64 CCBigNumMontgomerySetup();
signed __int64 CCBigNumMontgomeryNormalization();
signed __int64 CCBigNumMontgomeryReduce();
int __fastcall CCBigNumIsPrime(__int64 a1, __int64 a2);
int __fastcall CCBigNumIsOdd(__int64 a1, __int64 a2);
int __fastcall CCBigNumIsZero(__int64 a1, __int64 a2);
int __fastcall CCBigNumIsNegative(__int64 a1, __int64 a2);
void *__fastcall cc_alloc(__int64 a1, size_t a2);
void *__fastcall cc_realloc(__int64 a1, size_t a2, const void *a3, size_t a4);
void __fastcall cc_free(__int64 a1, __int64 a2, void *a3);
int __fastcall CCAESCmac(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void *__fastcall CCAESCmacCreate(__int64 a1);
void __fastcall CCAESCmacUpdate(__int64 a1, const void *a2, size_t a3);
int __fastcall CCAESCmacFinal(__int64 a1, __int64 a2);
void __fastcall CCAESCmacDestroy(__int64 a1);
__int64 __fastcall CCAESCmacOutputSizeFromContext(__int64 a1);
__int64 __fastcall getCipherMode(int a1, int a2, unsigned int a3);
int __fastcall __getCipherMode_block_invoke(__int64 a1);
__int64 __fastcall CCCryptorCreateFromData(unsigned int a1, int a2, unsigned int a3, __int64 a4, size_t a5, char *a6, __int64 a7, unsigned __int64 a8, __int64 a9, __int64 a10);
__int64 __fastcall CCCryptorCreate(unsigned int a1, int a2, unsigned int a3, __int64 a4, size_t a5, char *a6, __int64 a7);
__int64 __fastcall CCCryptorCreateWithMode(unsigned int a1, signed int a2, int a3, signed int a4, char *a5, __int64 a6, size_t a7, __int64 a8, __int64 a9, __int64 a10, int a11, __int64 a12);
__int64 __fastcall CCCryptorCreateFromDataWithMode(unsigned int a1, signed int a2, int a3, signed int a4, char *a5, __int64 a6, size_t a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, unsigned __int64 a13, __int64 a14, __int64 a15);
// __int64 __usercall ccInitCryptor@<rax>(__int64 a1@<rax>, __int64 a2@<rdx>, __int64 a3@<rcx>, __int64 a4@<rdi>, __int64 a5@<rsi>, char *a6@<r8>);
__int64 __fastcall CCCryptorRelease(void *); // idb
int __fastcall CCCryptorGetOutputLength(__int64 a1, __int64 a2, unsigned __int8 a3);
signed __int64 __fastcall CCCryptorUpdate(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall ccSimpleUpdate(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall CCCryptorFinal(__int64 a1, void *a2, size_t a3, __int64 a4);
signed __int64 __fastcall CCCryptorReset(__int64 a1, __int64 a2);
signed __int64 __fastcall CCCryptorGetIV(__int64 a1, __int64 a2);
__int64 __fastcall CCCrypt(unsigned int a1, int a2, unsigned int a3, __int64 a4, size_t a5, char *a6, __int64 a7, unsigned __int64 a8, __int64 a9, __int64 a10, __int64 a11);
__int64 __fastcall CCCryptorEncryptDataBlock(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall CCCryptorDecryptDataBlock(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall CCCryptorAddParameter(__int64 a1, int a2, const void *a3, size_t a4);
signed __int64 __fastcall CCCryptorGetParameter(__int64 a1, int a2, void *a3, __int64 a4);
void kCCDHRFC2409Group2_storage();
void kCCDHRFC3526Group5_storage();
void *__fastcall CCDHCreate(void (*a1)());
void __fastcall CCDHRelease(void *a1);
// signed __int64 __usercall CCDHGenerateKey@<rax>(__int64 a1@<rdx>, __int64 a2@<rdi>, __int64 a3@<rsi>, __int64 a4@<r8>, __int64 a5@<r9>, __int128 a6@<xmm0>, __int128 a7@<xmm1>, __int128 a8@<xmm2>, __int128 a9@<xmm3>, __int128 a10@<xmm4>, __int128 a11@<xmm5>, __int128 a12@<xmm6>, __int128 a13@<xmm7>);
signed __int64 __fastcall CCDHComputeKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void *__fastcall CCDHParametersCreateFromData(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall CCDHParametersRelease(void *a1);
__int64 CCDHParametersCreateFromPKCS3();
__int64 CCDHParametersPKCS3EncodeLength();
__int64 CCDHParametersPKCS3Encode();
__int64 __fastcall CCDigestGetDigestInfo(unsigned int a1);
__int64 __fastcall __CCDigestGetDigestInfo_block_invoke(__int64 a1);
signed __int64 __fastcall CCDigestInit(unsigned int a1, __int64 a2);
signed __int64 __fastcall CCDigestUpdate(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall CCDigestFinal(__int64 a1, __int64 a2);
__int64 __fastcall CCDigest(unsigned int a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall CCDigestGetBlockSize(unsigned int a1);
signed __int64 __fastcall CCDigestGetOutputSize(unsigned int a1);
signed __int64 __fastcall CCDigestGetBlockSizeFromRef(__int64 a1);
signed __int64 __fastcall CCDigestBlockSize(__int64 a1);
signed __int64 __fastcall CCDigestOutputSize(signed __int64 **a1);
signed __int64 __fastcall CCDigestGetOutputSizeFromRef(signed __int64 **a1);
void *__fastcall CCDigestCreate(unsigned int a1);
__int64 __fastcall CCDigestOID(__int64 a1);
__int64 __fastcall CCDigestOIDLen(__int64 a1);
void *__fastcall CCDigestCreateByOID(void *a1, size_t a2);
int __fastcall CCDigestReset(__int64 a1);
void __fastcall CCDigestDestroy(void *a1);
__int64 __fastcall CC_MD2(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall CC_MD4_Init(void *); // idb
__int64 __fastcall CC_MD4_Update(void *a1, __int64 a2, unsigned int a3);
signed __int64 __fastcall CC_MD4_Final(__int64 a1, __int64 a2);
__int64 __fastcall CC_MD4(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall CC_MD5_Init(void *); // idb
__int64 __fastcall CC_MD5_Update(void *a1, __int64 a2, unsigned int a3);
signed __int64 __fastcall CC_MD5_Final(__int64 a1, __int64 a2);
__int64 __fastcall CC_MD5(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall CC_SHA1_Init(void *); // idb
__int64 __fastcall CC_SHA1_Update(void *a1, __int64 a2, unsigned int a3);
signed __int64 __fastcall CC_SHA1_Final(__int64 a1, __int64 a2);
__int64 __fastcall CC_SHA1(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall CC_SHA224(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall CC_SHA256(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall CC_SHA384(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall CC_SHA512(__int64 a1, unsigned int a2, __int64 a3);
signed __int64 __fastcall MD5Final(__int64 a1, __int64 a2);
signed __int64 __fastcall CC_MD2_Init(__int64 a1);
// signed __int64 __usercall CC_MD2_Update@<rax>(__int64 a1@<rax>, unsigned int a2@<edx>, __int64 a3@<rdi>, __int64 a4@<rsi>);
// signed __int64 __usercall CC_MD2_Final@<rax>(__int64 a1@<rax>, __int64 a2@<rdi>, __int64 a3@<rsi>);
signed __int64 __fastcall CC_SHA256_Init(__int64 a1);
signed __int64 __fastcall CC_SHA256_Update(__int64 a1, const void *a2, unsigned int a3);
int __fastcall ccdigest_process(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5, const void *a6);
signed __int64 __fastcall CC_SHA256_Final(__int64 a1, unsigned __int64 *a2);
int __fastcall ccdigest_finalize(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5);
signed __int64 __fastcall CC_SHA512_Init(__int64 a1);
signed __int64 __fastcall CC_SHA512_Update(__int64 a1, const void *a2, unsigned int a3);
signed __int64 __fastcall CC_SHA512_Final(__int64 a1, unsigned __int64 *a2);
signed __int64 __fastcall CC_SHA224_Init(__int64 a1);
signed __int64 __fastcall CC_SHA224_Update(__int64 a1, const void *a2, unsigned int a3);
signed __int64 __fastcall CC_SHA224_Final(__int64 a1, unsigned __int64 *a2);
signed __int64 __fastcall CC_SHA384_Init(__int64 a1);
signed __int64 __fastcall CC_SHA384_Update(__int64 a1, const void *a2, unsigned int a3);
signed __int64 __fastcall CC_SHA384_Final(__int64 a1, unsigned __int64 *a2);
// signed __int64 __usercall CCECCryptorGeneratePair@<rax>(__int64 a1@<rdx>, __int64 a2@<rdi>, __int64 a3@<rsi>, __int64 a4@<r8>, __int64 a5@<r9>, __int128 a6@<xmm0>, __int128 a7@<xmm1>, __int128 a8@<xmm2>, __int128 a9@<xmm3>, __int128 a10@<xmm4>, __int128 a11@<xmm5>, __int128 a12@<xmm6>, __int128 a13@<xmm7>);
void *__fastcall ccMallocECCryptor(__int64 a1, int a2);
// __int64 __usercall CCECCryptorGetPublicKeyFromPrivateKey@<rax>(__int64 a1@<rdi>, __int128 a2@<xmm0>, __int128 a3@<xmm1>, __int128 a4@<xmm2>, __int128 a5@<xmm3>, __int128 a6@<xmm6>, __int128 a7@<xmm7>);
// bool __usercall ccECpairwiseConsistencyCheck@<al>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r9>, __int128 a4@<xmm0>, __int128 a5@<xmm1>, __int128 a6@<xmm2>, __int128 a7@<xmm3>, __int128 a8@<xmm4>, __int128 a9@<xmm5>, __int128 a10@<xmm6>, __int128 a11@<xmm7>);
void __fastcall ccECCryptorFree(void *a1);
signed __int64 __fastcall CCECCryptorGetKeyComponents(__int64 a1);
signed __int64 __fastcall CCECCryptorCreateFromData(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall CCECGetKeyType(__int64 a1);
signed __int64 __fastcall CCECGetKeySize(__int64 a1);
void __fastcall CCECCryptorRelease(void *a1);
signed __int64 __fastcall CCECCryptorImportPublicKey(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall CCECCryptorImportKey(int a1, __int64 a2, __int64 a3, int a4, __int64 a5);
signed __int64 __fastcall CCECCryptorExportPublicKey(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall CCECCryptorExportKey(int a1, __int64 a2, __int64 a3, int a4, __int64 a5);
// signed __int64 __usercall CCECCryptorSignHash@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5@<r8>, __int64 a6@<r9>, __int128 a7@<xmm0>, __int128 a8@<xmm1>, __int128 a9@<xmm2>, __int128 a10@<xmm3>, __int128 a11@<xmm4>, __int128 a12@<xmm5>, __int128 a13@<xmm6>, __int128 a14@<xmm7>);
signed __int64 __fastcall CCECCryptorVerifyHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 CCECCryptorWrapKey();
signed __int64 CCECCryptorUnwrapKey();
signed __int64 __fastcall CCECCryptorComputeSharedSecret(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall CCCryptorGCMAddIV(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall CCCryptorGCMAddAAD(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall CCCryptorGCMAddADD(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall CCCryptorGCMaddAAD(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall CCCryptorGCMEncrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall CCCryptorGCMDecrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall CCCryptorGCMFinal(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall CCCryptorGCMReset(__int64 a1);
__int64 __fastcall CCCryptorGCM(unsigned int a1, int a2, __int64 a3, size_t a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13);
void __fastcall CCHmacInit(__int64 a1, int a2, __int64 a3, __int64 a4);
__int64 __fastcall convertccHmacSelector(int a1);
int __fastcall CCHmacUpdate(__int64 a1, __int64 a2, __int64 a3);
int __fastcall CCHmacFinal(__int64 a1, __int64 a2);
void __fastcall CCHmacDestroy(void *a1);
__int64 __fastcall CCHmacOutputSizeFromRef(__int64 a1);
signed __int64 __fastcall CCHmacOutputSize(unsigned int a1);
int __fastcall CCHmac(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void *__fastcall CCHmacCreate(unsigned int a1, __int64 a2, __int64 a3);
int __fastcall CCHmacOneShot(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void *__fastcall CCHmacClone(void *a1);
__int64 __fastcall CCKeyDerivationPBKDF(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, unsigned int a7, __int64 a8, __int64 a9);
signed __int64 __fastcall CCCalibratePBKDF(int a1, unsigned __int64 a2, size_t a3, int a4, size_t a5, int a6);
uint64_t timer();
// __int64 __usercall ccDevRandomGetRngState@<rax>(__int64 a1@<r8>, __int64 a2@<r9>, __int128 a3@<xmm0>, __int128 a4@<xmm1>, __int128 a5@<xmm2>, __int128 a6@<xmm3>, __int128 a7@<xmm4>, __int128 a8@<xmm5>, __int128 a9@<xmm6>, __int128 a10@<xmm7>);
int __fastcall __ccDevRandomGetRngState_block_invoke(__int64 a1);
// __int64 __usercall ccDRBGGetRngState@<rax>(__int64 a1@<r8>, __int64 a2@<r9>, __int128 a3@<xmm0>, __int128 a4@<xmm1>, __int128 a5@<xmm2>, __int128 a6@<xmm3>, __int128 a7@<xmm4>, __int128 a8@<xmm5>, __int128 a9@<xmm6>, __int128 a10@<xmm7>);
int __fastcall __ccDRBGGetRngState_block_invoke(__int64 a1);
// __int64 __usercall CCRNGCreate@<rax>(unsigned int a1@<edi>, __int64 a2@<rsi>, __int128 a3@<xmm0>, __int128 a4@<xmm1>, __int128 a5@<xmm2>, __int128 a6@<xmm3>, __int128 a7@<xmm6>, __int128 a8@<xmm7>);
__int64 __fastcall CCRNGRelease(void *); // idb
// int __usercall CCRandomCopyBytes@<eax>(__int64 a1@<rdx>, __int64 a2@<rdi>, __int64 a3@<rsi>, __int64 a4@<r8>, __int64 a5@<r9>, __int128 a6@<xmm0>, __int128 a7@<xmm1>, __int128 a8@<xmm2>, __int128 a9@<xmm3>, __int128 a10@<xmm4>, __int128 a11@<xmm5>, __int128 a12@<xmm6>, __int128 a13@<xmm7>);
// __int64 __usercall CCRandomGenerateBytes@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r8>, __int64 a4@<r9>, __int128 a5@<xmm0>, __int128 a6@<xmm1>, __int128 a7@<xmm2>, __int128 a8@<xmm3>, __int128 a9@<xmm4>, __int128 a10@<xmm5>, __int128 a11@<xmm6>, __int128 a12@<xmm7>);
// __int64 __usercall CCRSACryptorGeneratePair@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, unsigned int a4@<esi>, __int64 a5@<r8>, __int64 a6@<r9>, __int128 a7@<xmm0>, __int128 a8@<xmm1>, __int128 a9@<xmm2>, __int128 a10@<xmm3>, __int128 a11@<xmm4>, __int128 a12@<xmm5>, __int128 a13@<xmm6>, __int128 a14@<xmm7>);
void *__fastcall CCRSACryptorGetPublicKeyFromPrivateKey(__int64 a1);
void __fastcall ccRSACryptorClear(void *a1);
signed __int64 __fastcall CCRSAGetKeyType(__int64 a1);
signed __int64 __fastcall CCRSAGetKeySize(__int64 a1);
void __fastcall CCRSACryptorRelease(void *a1);
signed __int64 __fastcall CCRSACryptorImport(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall CCRSACryptorExport(__int64 a1, __int64 a2, unsigned __int64 *a3);
// signed __int64 __usercall CCRSACryptorEncrypt@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, int a4@<esi>, __int64 a5@<r8>, __int64 a6@<r9>, __int128 a7@<xmm0>, __int128 a8@<xmm1>, __int128 a9@<xmm2>, __int128 a10@<xmm3>, __int128 a11@<xmm4>, __int128 a12@<xmm5>, __int128 a13@<xmm6>, __int128 a14@<xmm7>, __int64 a15, __int64 a16, unsigned int a17);
signed __int64 __fastcall CCRSACryptorDecrypt(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned int a9);
__int64 __fastcall CCRSACryptorCrypt(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall CCRSACryptorCreatePairFromData(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16, __int64 a17, __int64 a18, __int64 a19, __int64 a20, __int64 a21, __int64 a22, __int64 a23);
signed __int64 __fastcall CCRSACryptorCreateFromData(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
__int64 __fastcall CCRSAGetKeyComponents(__int64 a1, __int64 a2, __int64 a3);
// signed __int64 __usercall CCRSACryptorSign@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, int a4@<esi>, unsigned int a5@<r8d>, __int128 a6@<xmm0>, __int128 a7@<xmm1>, __int128 a8@<xmm2>, __int128 a9@<xmm3>, __int128 a10@<xmm6>, __int128 a11@<xmm7>, __int64 a12, __int64 a13);
// signed __int64 __usercall CCRSACryptorVerify@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, int a4@<esi>, unsigned int a5@<r8d>, __int64 a6, __int64 a7);
signed __int64 __fastcall CCSymmetricKeyWrap(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int64 a7, __int64 a8, __int64 a9);
signed __int64 __fastcall CCSymmetricKeyUnwrap(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5, __int64 a6, unsigned __int64 a7, __int64 a8);
signed __int64 __fastcall CCSymmetricWrappedSize(__int64 a1, __int64 a2);
signed __int64 __fastcall CCSymmetricUnwrappedSize(__int64 a1, __int64 a2);
__int64 noMode();
__int64 cc_rc4_crypt_mode();
__int64 __fastcall ccecb_mode_get_ctx_size(__int64 a1);
__int64 __fastcall ccecb_mode_get_block_size(__int64 a1);
// int __usercall ccecb_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4, __int64 a5);
int __fastcall ccecb_mode_crypt(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5);
signed __int64 __fastcall cccbc_mode_get_ctx_size(__int64 a1);
__int64 __fastcall cccbc_mode_get_block_size(__int64 a1);
// int __usercall cccbc_mode_setup@<eax>(void *a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, const void *a4@<rsi>, __int64 a5, void *a6);
int __fastcall cccbc_mode_crypt(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5);
signed __int64 __fastcall cccbc_setiv(__int64 a1, const void *a2, size_t a3, void *a4);
signed __int64 __fastcall cccbc_getiv(__int64 a1, void *a2, __int64 a3, const void *a4);
__int64 __fastcall cccfb_mode_get_ctx_size(__int64 a1);
__int64 __fastcall cccfb_mode_get_block_size(__int64 a1);
// int __usercall cccfb_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5, __int64 a6);
int __fastcall cccfb_mode_crypt(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5);
__int64 __fastcall cccfb8_mode_get_ctx_size(__int64 a1);
__int64 __fastcall cccfb8_mode_get_block_size(__int64 a1);
// int __usercall cccfb8_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5, __int64 a6);
int __fastcall cccfb8_mode_crypt(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5);
__int64 __fastcall ccctr_mode_get_ctx_size(__int64 a1);
__int64 __fastcall ccctr_mode_get_block_size(__int64 a1);
// int __usercall ccctr_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5, __int64 a6);
int __fastcall ccctr_mode_crypt(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5);
__int64 __fastcall ccofb_mode_get_ctx_size(__int64 a1);
__int64 __fastcall ccofb_mode_get_block_size(__int64 a1);
// int __usercall ccofb_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5, __int64 a6);
int __fastcall ccofb_mode_crypt(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5);
__int64 __fastcall ccxts_mode_get_ctx_size(__int64 a1);
__int64 __fastcall ccxts_mode_get_block_size(__int64 a1);
// int __usercall ccxts_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4, __int64 a5);
__int64 __fastcall ccxts_mode_encrypt_tweak(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ccxts_mode_decrypt_tweak(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ccgcm_mode_get_ctx_size(__int64 a1);
__int64 __fastcall ccgcm_mode_get_block_size(__int64 a1);
// int __usercall ccgcm_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4, __int64 a5);
int __fastcall ccgcm_mode_crypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall ccgcm_setiv(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
signed __int64 __fastcall ccccm_mode_get_ctx_size(__int64 a1);
__int64 __fastcall ccccm_mode_get_block_size(__int64 a1);
// int __usercall ccccm_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4, __int64 a5);
int __fastcall ccccm_mode_crypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall ccccm_mode_done(__int64 a1, __int64 a2);
// __int64 __usercall ccpkcs7_encrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5@<r8>, __int64 a6);
// __int64 __usercall ccpkcs7_decrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5);
unsigned __int64 __fastcall ccpkcs7_padlen(int a1, __int64 a2, __int64 a3, unsigned __int64 a4, char a5);
int __fastcall ccpkcs7_reserve(int a1, __int64 a2, __int64 a3);
__int64 __fastcall ccpkcs7_encrypt_ecb_pad(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
__int64 __fastcall ccpkcs7_decrypt_ecb_pad(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
// __int64 __usercall cccts1_encrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5);
// __int64 __usercall cccts1_decrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5);
unsigned __int64 __fastcall ccctsX_padlen(int a1, __int64 a2, __int64 a3, unsigned __int64 a4, char a5);
signed __int64 __fastcall ccctsX_reserve(__int64 a1, __int64 a2, __int64 a3);
// __int64 __usercall cccts2_encrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5);
// __int64 __usercall cccts2_decrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5);
// __int64 __usercall cccts3_encrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5);
// __int64 __usercall cccts3_decrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5);
// __int64 __usercall ccnopad_encrypt_pad@<rax>(__int64 a1@<r8>, __int64 a2);
// __int64 __usercall ccnopad_decrypt_pad@<rax>(__int64 a1@<r8>, __int64 a2);
unsigned __int64 __fastcall ccnopad_padlen(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 ccnopad_reserve();
int __fastcall rc4ModeInit(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
int rc4crypt();
int __fastcall CC_RC4_set_key(__int64 a1, int a2);
int CC_RC4();
int CCDesIsWeakKey();
int CCDesSetOddParity();
int CCDesCBCCksum();
signed __int64 __fastcall CNCRC(unsigned int a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall CNCRCInit(unsigned int a1, __int64 a2);
__int64 __fastcall CNCRCRelease(void *a1);
__int64 __fastcall CNCRCUpdate(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall CNCRCFinal(__int64 *a1, __int64 a2);
signed __int64 __fastcall CNCRCDumpTable(unsigned int a1);
__int64 __fastcall CNCRCWeakTest(unsigned int a1);
__int64 __fastcall __getDesc_block_invoke(__int64 a1);
__int64 __fastcall CNEncoderCreate(unsigned int a1, int a2, __int64 a3);
__int64 __fastcall CNEncoderCreateCustom(__int64 a1, unsigned __int8 a2, __int64 a3, char a4, int a5, __int64 a6);
__int64 __fastcall setReverseMap(__int64 a1);
__int64 __fastcall CNEncoderRelease(void **a1);
unsigned __int64 __fastcall CNEncoderGetOutputLength(__int64 a1, __int64 a2);
unsigned __int64 __fastcall encodeLen(__int64 a1, __int64 a2);
unsigned __int64 __fastcall decodeLen(__int64 a1, __int64 a2);
// unsigned __int64 __usercall CNEncoderGetOutputLengthFromEncoding@<rax>(__int64 a1@<rax>, __int64 a2@<rdx>, unsigned int a3@<edi>, int a4@<esi>);
__int64 __fastcall CNEncoderUpdate(__int64 a1, const void *a2, unsigned __int64 a3, __int64 a4, unsigned __int64 *a5);
signed __int64 __fastcall enCode(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall deCode(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall CNEncoderFinal(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall CNEncoderBlocksize(unsigned int a1, __int64 a2, __int64 a3);
signed __int64 __fastcall CNEncoderBlocksizeFromRef(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall CNEncode(unsigned int a1, int a2, const void *a3, unsigned __int64 a4, __int64 a5, __int64 *a6);
__int64 __fastcall __getCodeFrame_block_invoke(__int64 a1);
__int64 __fastcall __getCodeFrame_block_invoke_2(__int64 a1);
void *__fastcall CNBufferCreate(size_t a1);
__int64 __fastcall CNBufferRelease(void **a1);
__int64 __fastcall CNBufferProcessData(__int64 a1, __int64 a2, const void *a3, unsigned __int64 a4, __int64 a5, unsigned __int64 *a6, void (__fastcall *a7)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD), int (__fastcall *a8)(_QWORD, _QWORD));
signed __int64 __fastcall CNBufferFlushData(__int64 a1, __int64 a2, __int64 a3, __int64 a4, void (__fastcall *a5)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD), int (__fastcall *a6)(_QWORD));
bool __fastcall CNBufferEmpty(__int64 a1);
// uint64_t mach_absolute_time(void);
// kern_return_t __cdecl mach_timebase_info(mach_timebase_info_t info);
// int __fastcall __bzero(_QWORD); weak
// int __fastcall _os_alloc_once(_QWORD, _QWORD, _QWORD); weak
// void *__cdecl calloc(size_t, size_t);
// void __cdecl free(void *);
// void *__cdecl malloc(size_t);
// int __fastcall __memset_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __snprintf_chk(char *, size_t, int, size_t, const char *, ...);
// void abort(void);
// char *__cdecl getenv(const char *);
// int __cdecl memcmp(const void *, const void *, size_t);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memmove(void *, const void *, size_t);
// void *__cdecl memset(void *, int, size_t);
// int printf(const char *, ...);
// int __cdecl putchar(int);
// int __cdecl puts(const char *);
// size_t __cdecl strlen(const char *);
// int __cdecl strncmp(const char *, const char *, size_t);
// char *__cdecl strndup(const char *, size_t);
// int __fastcall dispatch_once(_QWORD, _QWORD); weak
// aslmsg __cdecl asl_new(uint32_t type);
// aslclient __cdecl asl_open(const char *ident, const char *facility, uint32_t opts);
// int __cdecl asl_set(aslmsg msg, const char *key, const char *value);
// int __cdecl asl_vlog(aslclient asl, aslmsg msg, int level, const char *format, va_list ap);
// int __fastcall ccaes_cbc_encrypt_mode(_QWORD); weak
// int __fastcall cccmac(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall cccmac_block_update(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall cccmac_final(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall cccmac_init(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccder_decode_rsa_priv(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccder_decode_rsa_priv_n(_QWORD, _QWORD); weak
// int __fastcall ccder_decode_rsa_pub_n(_QWORD, _QWORD); weak
// int __fastcall ccder_encode_rsa_priv(_QWORD, _QWORD, _QWORD); weak
// int __cdecl ccder_encode_rsa_priv_size(_QWORD); weak
// int __fastcall ccder_encode_rsa_pub_size(_QWORD, _QWORD, _QWORD); weak
// int ccdes_cbc_cksum(void); weak
// int ccdes_key_is_weak(void); weak
// int ccdes_key_set_odd_parity(void); weak
// int __fastcall ccdh_compute_key(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccdh_export_pub(_QWORD, _QWORD); weak
// int __fastcall ccdh_generate_key(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccdh_gp_rfc3526group05(_QWORD); weak
// int __fastcall ccdh_import_pub(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccdh_init_gp(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccdigest(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccdigest_init(_QWORD, _QWORD); weak
// int __fastcall ccdigest_update(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccdrbg_factory_nistctr(_QWORD, _QWORD); weak
// int __fastcall ccec_compute_key(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccec_generate_key(_QWORD, _QWORD, _QWORD); weak
// int __cdecl ccec_get_cp(_QWORD); weak
// int __fastcall ccec_get_fullkey_components(_QWORD); weak
// int __fastcall ccec_get_pubkey_components(_QWORD); weak
// int __cdecl ccec_keysize_is_supported(_QWORD); weak
// int __fastcall ccec_make_pub(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccec_sign(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccec_verify(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccec_x963_export(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccec_x963_import_priv(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccec_x963_import_priv_size(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccec_x963_import_pub(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccec_x963_import_pub_size(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall cchkdf(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall cchmac(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall cchmac_final(_QWORD, _QWORD, _QWORD); weak
// int __fastcall cchmac_init(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall cchmac_update(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccmd5_di(_QWORD, _QWORD); weak
// int __fastcall ccmode_gcm_decrypt(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccmode_gcm_encrypt(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccmode_gcm_finalize(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccmode_gcm_gmac(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccmode_gcm_reset(_QWORD); weak
// int __fastcall ccmode_gcm_set_iv(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccn_bitlen(_QWORD, _QWORD); weak
// int __fastcall ccn_read_uint(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccn_write_int(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccn_write_int_size(_QWORD, _QWORD); weak
// int __fastcall ccn_write_uint(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccn_write_uint_size(_QWORD, _QWORD); weak
// int __fastcall ccnistkdf_ctr_hmac(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccnistkdf_ctr_hmac_fixed(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpad_cts1_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpad_cts1_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpad_cts2_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpad_cts2_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpad_cts3_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpad_cts3_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpad_pkcs7_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpad_pkcs7_ecb_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpad_pkcs7_ecb_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpad_pkcs7_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpad_xts_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpad_xts_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccpbkdf2_hmac(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrng_CommonCrypto_done(_QWORD); weak
// int __fastcall ccrng_CommonCrypto_init(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrng_system_init(_QWORD); weak
// int __fastcall ccrsa_crt_makekey(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_decrypt_eme_pkcs1v15(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_decrypt_oaep(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_encrypt_eme_pkcs1v15(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_encrypt_oaep(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_export_pub(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_generate_931_key(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __cdecl ccrsa_get_fullkey_components(_QWORD, _QWORD, _QWORD); weak
// int ccrsa_get_pubkey_components(void); weak
// int __fastcall ccrsa_import_pub(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_init_pub(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_make_931_key(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_priv_crypt(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_pub_crypt(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_sign_oaep(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_sign_pkcs1v15(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_verify_oaep(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccrsa_verify_pkcs1v15(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __cdecl ccsha1_di(_QWORD); weak
// int __cdecl ccsha224_di(_QWORD); weak
// int __cdecl ccsha256_di(_QWORD); weak
// int __cdecl ccsha384_di(_QWORD); weak
// int __cdecl ccsha512_di(_QWORD); weak
// int ccz_add(void); weak
// int ccz_addi(void); weak
// int __fastcall ccz_bit(_QWORD, _QWORD); weak
// int __fastcall ccz_bitlen(_QWORD); weak
// int ccz_cmp(void); weak
// int ccz_cmpi(void); weak
// int ccz_divmod(void); weak
// int ccz_expmod(void); weak
// int __cdecl ccz_free(_QWORD); weak
// int ccz_gcd(void); weak
// int __fastcall ccz_init(_QWORD, _QWORD); weak
// int ccz_invmod(void); weak
// int __fastcall ccz_is_negative(_QWORD); weak
// int __fastcall ccz_is_prime(_QWORD, _QWORD); weak
// int __fastcall ccz_is_zero(_QWORD); weak
// int ccz_lcm(void); weak
// int __fastcall ccz_lsl(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccz_lsr(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccz_mod(_QWORD, _QWORD, _QWORD); weak
// int ccz_mul(void); weak
// int ccz_muli(void); weak
// int ccz_mulmod(void); weak
// int ccz_neg(void); weak
// int __fastcall ccz_random_bits(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccz_read_radix(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccz_read_uint(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccz_set(_QWORD); weak
// int __fastcall ccz_seti(_QWORD, _QWORD); weak
// int __fastcall ccz_size(_QWORD); weak
// int ccz_sqr(void); weak
// int ccz_sqrmod(void); weak
// int ccz_sub(void); weak
// int ccz_subi(void); weak
// int __fastcall ccz_trailing_zeros(_QWORD); weak
// int __fastcall ccz_write_int_size(_QWORD); weak
// int __fastcall ccz_write_radix(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall ccz_write_radix_size(_QWORD, _QWORD); weak
// int __fastcall ccz_write_uint(_QWORD, _QWORD, _QWORD); weak
// int __fastcall ccz_write_uint_size(_QWORD); weak
// int __fastcall ccz_zero(_QWORD); weak
// int __fastcall cczp_init(_QWORD); weak
uLong __cdecl adler32(uLong adler, const Bytef *buf, uInt len);
uLong __cdecl crc32(uLong crc, const Bytef *buf, uInt len);

//-------------------------------------------------------------------------
// Data declarations

char byte_B546 = '\0'; // weak
__int64 qword_B860[3] = { 255LL, 65535LL, 0LL }; // weak
__int64 qword_B8A0[3] = { 255LL, 65535LL, 0LL }; // weak
__int64 reflector[32] =
{
  -2278645348924620800LL,
  -1121202583515394032LL,
  -1699923966220007416LL,
  -542481200810780648LL,
  -1989284657572314108LL,
  -831841892163087340LL,
  -1410563274867700724LL,
  -253120509458473956LL,
  -2133965003248467454LL,
  -976522237839240686LL,
  -1555243620543854070LL,
  -397800855134627302LL,
  -1844604311896160762LL,
  -687161546486933994LL,
  -1265882929191547378LL,
  -108440163782320610LL,
  -2206305176086544127LL,
  -1048862410677317359LL,
  -1627583793381930743LL,
  -470141027972703975LL,
  -1916944484734237435LL,
  -759501719325010667LL,
  -1338223102029624051LL,
  -180780336620397283LL,
  -2061624830410390781LL,
  -904182065001164013LL,
  -1482903447705777397LL,
  -325460682296550629LL,
  -1772264139058084089LL,
  -614821373648857321LL,
  -1193542756353470705LL,
  -36099990944243937LL
}; // weak
__int64 qword_B9E0[4] = { 34359738384LL, 34359738376LL, 34359738369LL, 8LL }; // weak
__int64 ccRandomDefaultStruct[5] = { 1LL, 0LL, 0LL, 0LL, 0LL }; // weak
__int64 encoderValue[7] =
{
  17179869200LL,
  8589934593LL,
  137438953487LL,
  21474836485LL,
  133143986184LL,
  25769803840LL,
  17179869187LL
}; // weak
__int64 _NSConcreteStackBlock_ptr[176] =
{
  98104LL,
  98000LL,
  97912LL,
  98256LL,
  98944LL,
  98952LL,
  99264LL,
  99272LL,
  99280LL,
  99288LL,
  99296LL,
  97920LL,
  97928LL,
  97936LL,
  97944LL,
  97952LL,
  97960LL,
  97968LL,
  97976LL,
  97984LL,
  97992LL,
  98008LL,
  98016LL,
  98024LL,
  98032LL,
  98040LL,
  98048LL,
  98056LL,
  98064LL,
  98072LL,
  98080LL,
  98088LL,
  98096LL,
  98112LL,
  98120LL,
  98128LL,
  98136LL,
  98144LL,
  98160LL,
  98448LL,
  98456LL,
  98464LL,
  98472LL,
  98480LL,
  98488LL,
  98496LL,
  98504LL,
  98512LL,
  98520LL,
  98608LL,
  98688LL,
  98696LL,
  98712LL,
  98720LL,
  98728LL,
  98736LL,
  98744LL,
  98752LL,
  98760LL,
  98768LL,
  98776LL,
  98784LL,
  98792LL,
  98800LL,
  98808LL,
  98816LL,
  98824LL,
  98832LL,
  98840LL,
  98848LL,
  98856LL,
  98864LL,
  98872LL,
  98880LL,
  98888LL,
  98896LL,
  98904LL,
  98912LL,
  98920LL,
  98928LL,
  98936LL,
  98960LL,
  98968LL,
  98976LL,
  98984LL,
  98992LL,
  99000LL,
  99008LL,
  99016LL,
  99024LL,
  99032LL,
  99040LL,
  99048LL,
  99056LL,
  99064LL,
  99072LL,
  99080LL,
  99088LL,
  99096LL,
  99104LL,
  99112LL,
  99120LL,
  99128LL,
  99136LL,
  99144LL,
  99152LL,
  99160LL,
  99168LL,
  99176LL,
  99304LL,
  99312LL,
  99320LL,
  99328LL,
  99336LL,
  99344LL,
  99352LL,
  99360LL,
  99368LL,
  99376LL,
  99384LL,
  99392LL,
  99400LL,
  99408LL,
  99416LL,
  99424LL,
  99432LL,
  99440LL,
  99448LL,
  99456LL,
  99464LL,
  99472LL,
  99480LL,
  99488LL,
  99496LL,
  99504LL,
  99512LL,
  99520LL,
  99528LL,
  99536LL,
  99544LL,
  99552LL,
  99560LL,
  99568LL,
  99576LL,
  99584LL,
  99592LL,
  99600LL,
  99608LL,
  99616LL,
  99624LL,
  99632LL,
  99640LL,
  99648LL,
  99656LL,
  99664LL,
  99672LL,
  99680LL,
  99688LL,
  99696LL,
  99704LL,
  99712LL,
  99720LL,
  99728LL,
  99736LL,
  99744LL,
  99752LL,
  99760LL,
  99768LL,
  99776LL,
  99784LL,
  99792LL,
  99800LL,
  99808LL,
  99816LL,
  99824LL,
  99832LL
}; // weak
__int64 __stack_chk_guard_ptr[175] =
{
  98000LL,
  97912LL,
  98256LL,
  98944LL,
  98952LL,
  99264LL,
  99272LL,
  99280LL,
  99288LL,
  99296LL,
  97920LL,
  97928LL,
  97936LL,
  97944LL,
  97952LL,
  97960LL,
  97968LL,
  97976LL,
  97984LL,
  97992LL,
  98008LL,
  98016LL,
  98024LL,
  98032LL,
  98040LL,
  98048LL,
  98056LL,
  98064LL,
  98072LL,
  98080LL,
  98088LL,
  98096LL,
  98112LL,
  98120LL,
  98128LL,
  98136LL,
  98144LL,
  98160LL,
  98448LL,
  98456LL,
  98464LL,
  98472LL,
  98480LL,
  98488LL,
  98496LL,
  98504LL,
  98512LL,
  98520LL,
  98608LL,
  98688LL,
  98696LL,
  98712LL,
  98720LL,
  98728LL,
  98736LL,
  98744LL,
  98752LL,
  98760LL,
  98768LL,
  98776LL,
  98784LL,
  98792LL,
  98800LL,
  98808LL,
  98816LL,
  98824LL,
  98832LL,
  98840LL,
  98848LL,
  98856LL,
  98864LL,
  98872LL,
  98880LL,
  98888LL,
  98896LL,
  98904LL,
  98912LL,
  98920LL,
  98928LL,
  98936LL,
  98960LL,
  98968LL,
  98976LL,
  98984LL,
  98992LL,
  99000LL,
  99008LL,
  99016LL,
  99024LL,
  99032LL,
  99040LL,
  99048LL,
  99056LL,
  99064LL,
  99072LL,
  99080LL,
  99088LL,
  99096LL,
  99104LL,
  99112LL,
  99120LL,
  99128LL,
  99136LL,
  99144LL,
  99152LL,
  99160LL,
  99168LL,
  99176LL,
  99304LL,
  99312LL,
  99320LL,
  99328LL,
  99336LL,
  99344LL,
  99352LL,
  99360LL,
  99368LL,
  99376LL,
  99384LL,
  99392LL,
  99400LL,
  99408LL,
  99416LL,
  99424LL,
  99432LL,
  99440LL,
  99448LL,
  99456LL,
  99464LL,
  99472LL,
  99480LL,
  99488LL,
  99496LL,
  99504LL,
  99512LL,
  99520LL,
  99528LL,
  99536LL,
  99544LL,
  99552LL,
  99560LL,
  99568LL,
  99576LL,
  99584LL,
  99592LL,
  99600LL,
  99608LL,
  99616LL,
  99624LL,
  99632LL,
  99640LL,
  99648LL,
  99656LL,
  99664LL,
  99672LL,
  99680LL,
  99688LL,
  99696LL,
  99704LL,
  99712LL,
  99720LL,
  99728LL,
  99736LL,
  99744LL,
  99752LL,
  99760LL,
  99768LL,
  99776LL,
  99784LL,
  99792LL,
  99800LL,
  99808LL,
  99816LL,
  99824LL,
  99832LL
}; // weak
__int64 _os_alloc_once_table_ptr[174] =
{
  97912LL,
  98256LL,
  98944LL,
  98952LL,
  99264LL,
  99272LL,
  99280LL,
  99288LL,
  99296LL,
  97920LL,
  97928LL,
  97936LL,
  97944LL,
  97952LL,
  97960LL,
  97968LL,
  97976LL,
  97984LL,
  97992LL,
  98008LL,
  98016LL,
  98024LL,
  98032LL,
  98040LL,
  98048LL,
  98056LL,
  98064LL,
  98072LL,
  98080LL,
  98088LL,
  98096LL,
  98112LL,
  98120LL,
  98128LL,
  98136LL,
  98144LL,
  98160LL,
  98448LL,
  98456LL,
  98464LL,
  98472LL,
  98480LL,
  98488LL,
  98496LL,
  98504LL,
  98512LL,
  98520LL,
  98608LL,
  98688LL,
  98696LL,
  98712LL,
  98720LL,
  98728LL,
  98736LL,
  98744LL,
  98752LL,
  98760LL,
  98768LL,
  98776LL,
  98784LL,
  98792LL,
  98800LL,
  98808LL,
  98816LL,
  98824LL,
  98832LL,
  98840LL,
  98848LL,
  98856LL,
  98864LL,
  98872LL,
  98880LL,
  98888LL,
  98896LL,
  98904LL,
  98912LL,
  98920LL,
  98928LL,
  98936LL,
  98960LL,
  98968LL,
  98976LL,
  98984LL,
  98992LL,
  99000LL,
  99008LL,
  99016LL,
  99024LL,
  99032LL,
  99040LL,
  99048LL,
  99056LL,
  99064LL,
  99072LL,
  99080LL,
  99088LL,
  99096LL,
  99104LL,
  99112LL,
  99120LL,
  99128LL,
  99136LL,
  99144LL,
  99152LL,
  99160LL,
  99168LL,
  99176LL,
  99304LL,
  99312LL,
  99320LL,
  99328LL,
  99336LL,
  99344LL,
  99352LL,
  99360LL,
  99368LL,
  99376LL,
  99384LL,
  99392LL,
  99400LL,
  99408LL,
  99416LL,
  99424LL,
  99432LL,
  99440LL,
  99448LL,
  99456LL,
  99464LL,
  99472LL,
  99480LL,
  99488LL,
  99496LL,
  99504LL,
  99512LL,
  99520LL,
  99528LL,
  99536LL,
  99544LL,
  99552LL,
  99560LL,
  99568LL,
  99576LL,
  99584LL,
  99592LL,
  99600LL,
  99608LL,
  99616LL,
  99624LL,
  99632LL,
  99640LL,
  99648LL,
  99656LL,
  99664LL,
  99672LL,
  99680LL,
  99688LL,
  99696LL,
  99704LL,
  99712LL,
  99720LL,
  99728LL,
  99736LL,
  99744LL,
  99752LL,
  99760LL,
  99768LL,
  99776LL,
  99784LL,
  99792LL,
  99800LL,
  99808LL,
  99816LL,
  99824LL,
  99832LL
}; // weak
__int64 ccaes_ltc_ecb_encrypt_mode_ptr[173] =
{
  98256LL,
  98944LL,
  98952LL,
  99264LL,
  99272LL,
  99280LL,
  99288LL,
  99296LL,
  97920LL,
  97928LL,
  97936LL,
  97944LL,
  97952LL,
  97960LL,
  97968LL,
  97976LL,
  97984LL,
  97992LL,
  98008LL,
  98016LL,
  98024LL,
  98032LL,
  98040LL,
  98048LL,
  98056LL,
  98064LL,
  98072LL,
  98080LL,
  98088LL,
  98096LL,
  98112LL,
  98120LL,
  98128LL,
  98136LL,
  98144LL,
  98160LL,
  98448LL,
  98456LL,
  98464LL,
  98472LL,
  98480LL,
  98488LL,
  98496LL,
  98504LL,
  98512LL,
  98520LL,
  98608LL,
  98688LL,
  98696LL,
  98712LL,
  98720LL,
  98728LL,
  98736LL,
  98744LL,
  98752LL,
  98760LL,
  98768LL,
  98776LL,
  98784LL,
  98792LL,
  98800LL,
  98808LL,
  98816LL,
  98824LL,
  98832LL,
  98840LL,
  98848LL,
  98856LL,
  98864LL,
  98872LL,
  98880LL,
  98888LL,
  98896LL,
  98904LL,
  98912LL,
  98920LL,
  98928LL,
  98936LL,
  98960LL,
  98968LL,
  98976LL,
  98984LL,
  98992LL,
  99000LL,
  99008LL,
  99016LL,
  99024LL,
  99032LL,
  99040LL,
  99048LL,
  99056LL,
  99064LL,
  99072LL,
  99080LL,
  99088LL,
  99096LL,
  99104LL,
  99112LL,
  99120LL,
  99128LL,
  99136LL,
  99144LL,
  99152LL,
  99160LL,
  99168LL,
  99176LL,
  99304LL,
  99312LL,
  99320LL,
  99328LL,
  99336LL,
  99344LL,
  99352LL,
  99360LL,
  99368LL,
  99376LL,
  99384LL,
  99392LL,
  99400LL,
  99408LL,
  99416LL,
  99424LL,
  99432LL,
  99440LL,
  99448LL,
  99456LL,
  99464LL,
  99472LL,
  99480LL,
  99488LL,
  99496LL,
  99504LL,
  99512LL,
  99520LL,
  99528LL,
  99536LL,
  99544LL,
  99552LL,
  99560LL,
  99568LL,
  99576LL,
  99584LL,
  99592LL,
  99600LL,
  99608LL,
  99616LL,
  99624LL,
  99632LL,
  99640LL,
  99648LL,
  99656LL,
  99664LL,
  99672LL,
  99680LL,
  99688LL,
  99696LL,
  99704LL,
  99712LL,
  99720LL,
  99728LL,
  99736LL,
  99744LL,
  99752LL,
  99760LL,
  99768LL,
  99776LL,
  99784LL,
  99792LL,
  99800LL,
  99808LL,
  99816LL,
  99824LL,
  99832LL
}; // weak
__int64 ccmd2_ltc_di_ptr[172] =
{
  98944LL,
  98952LL,
  99264LL,
  99272LL,
  99280LL,
  99288LL,
  99296LL,
  97920LL,
  97928LL,
  97936LL,
  97944LL,
  97952LL,
  97960LL,
  97968LL,
  97976LL,
  97984LL,
  97992LL,
  98008LL,
  98016LL,
  98024LL,
  98032LL,
  98040LL,
  98048LL,
  98056LL,
  98064LL,
  98072LL,
  98080LL,
  98088LL,
  98096LL,
  98112LL,
  98120LL,
  98128LL,
  98136LL,
  98144LL,
  98160LL,
  98448LL,
  98456LL,
  98464LL,
  98472LL,
  98480LL,
  98488LL,
  98496LL,
  98504LL,
  98512LL,
  98520LL,
  98608LL,
  98688LL,
  98696LL,
  98712LL,
  98720LL,
  98728LL,
  98736LL,
  98744LL,
  98752LL,
  98760LL,
  98768LL,
  98776LL,
  98784LL,
  98792LL,
  98800LL,
  98808LL,
  98816LL,
  98824LL,
  98832LL,
  98840LL,
  98848LL,
  98856LL,
  98864LL,
  98872LL,
  98880LL,
  98888LL,
  98896LL,
  98904LL,
  98912LL,
  98920LL,
  98928LL,
  98936LL,
  98960LL,
  98968LL,
  98976LL,
  98984LL,
  98992LL,
  99000LL,
  99008LL,
  99016LL,
  99024LL,
  99032LL,
  99040LL,
  99048LL,
  99056LL,
  99064LL,
  99072LL,
  99080LL,
  99088LL,
  99096LL,
  99104LL,
  99112LL,
  99120LL,
  99128LL,
  99136LL,
  99144LL,
  99152LL,
  99160LL,
  99168LL,
  99176LL,
  99304LL,
  99312LL,
  99320LL,
  99328LL,
  99336LL,
  99344LL,
  99352LL,
  99360LL,
  99368LL,
  99376LL,
  99384LL,
  99392LL,
  99400LL,
  99408LL,
  99416LL,
  99424LL,
  99432LL,
  99440LL,
  99448LL,
  99456LL,
  99464LL,
  99472LL,
  99480LL,
  99488LL,
  99496LL,
  99504LL,
  99512LL,
  99520LL,
  99528LL,
  99536LL,
  99544LL,
  99552LL,
  99560LL,
  99568LL,
  99576LL,
  99584LL,
  99592LL,
  99600LL,
  99608LL,
  99616LL,
  99624LL,
  99632LL,
  99640LL,
  99648LL,
  99656LL,
  99664LL,
  99672LL,
  99680LL,
  99688LL,
  99696LL,
  99704LL,
  99712LL,
  99720LL,
  99728LL,
  99736LL,
  99744LL,
  99752LL,
  99760LL,
  99768LL,
  99776LL,
  99784LL,
  99792LL,
  99800LL,
  99808LL,
  99816LL,
  99824LL,
  99832LL
}; // weak
__int64 ccmd4_ltc_di_ptr[171] =
{
  98952LL,
  99264LL,
  99272LL,
  99280LL,
  99288LL,
  99296LL,
  97920LL,
  97928LL,
  97936LL,
  97944LL,
  97952LL,
  97960LL,
  97968LL,
  97976LL,
  97984LL,
  97992LL,
  98008LL,
  98016LL,
  98024LL,
  98032LL,
  98040LL,
  98048LL,
  98056LL,
  98064LL,
  98072LL,
  98080LL,
  98088LL,
  98096LL,
  98112LL,
  98120LL,
  98128LL,
  98136LL,
  98144LL,
  98160LL,
  98448LL,
  98456LL,
  98464LL,
  98472LL,
  98480LL,
  98488LL,
  98496LL,
  98504LL,
  98512LL,
  98520LL,
  98608LL,
  98688LL,
  98696LL,
  98712LL,
  98720LL,
  98728LL,
  98736LL,
  98744LL,
  98752LL,
  98760LL,
  98768LL,
  98776LL,
  98784LL,
  98792LL,
  98800LL,
  98808LL,
  98816LL,
  98824LL,
  98832LL,
  98840LL,
  98848LL,
  98856LL,
  98864LL,
  98872LL,
  98880LL,
  98888LL,
  98896LL,
  98904LL,
  98912LL,
  98920LL,
  98928LL,
  98936LL,
  98960LL,
  98968LL,
  98976LL,
  98984LL,
  98992LL,
  99000LL,
  99008LL,
  99016LL,
  99024LL,
  99032LL,
  99040LL,
  99048LL,
  99056LL,
  99064LL,
  99072LL,
  99080LL,
  99088LL,
  99096LL,
  99104LL,
  99112LL,
  99120LL,
  99128LL,
  99136LL,
  99144LL,
  99152LL,
  99160LL,
  99168LL,
  99176LL,
  99304LL,
  99312LL,
  99320LL,
  99328LL,
  99336LL,
  99344LL,
  99352LL,
  99360LL,
  99368LL,
  99376LL,
  99384LL,
  99392LL,
  99400LL,
  99408LL,
  99416LL,
  99424LL,
  99432LL,
  99440LL,
  99448LL,
  99456LL,
  99464LL,
  99472LL,
  99480LL,
  99488LL,
  99496LL,
  99504LL,
  99512LL,
  99520LL,
  99528LL,
  99536LL,
  99544LL,
  99552LL,
  99560LL,
  99568LL,
  99576LL,
  99584LL,
  99592LL,
  99600LL,
  99608LL,
  99616LL,
  99624LL,
  99632LL,
  99640LL,
  99648LL,
  99656LL,
  99664LL,
  99672LL,
  99680LL,
  99688LL,
  99696LL,
  99704LL,
  99712LL,
  99720LL,
  99728LL,
  99736LL,
  99744LL,
  99752LL,
  99760LL,
  99768LL,
  99776LL,
  99784LL,
  99792LL,
  99800LL,
  99808LL,
  99816LL,
  99824LL,
  99832LL
}; // weak
__int64 ccrc4_eay_ptr[170] =
{
  99264LL,
  99272LL,
  99280LL,
  99288LL,
  99296LL,
  97920LL,
  97928LL,
  97936LL,
  97944LL,
  97952LL,
  97960LL,
  97968LL,
  97976LL,
  97984LL,
  97992LL,
  98008LL,
  98016LL,
  98024LL,
  98032LL,
  98040LL,
  98048LL,
  98056LL,
  98064LL,
  98072LL,
  98080LL,
  98088LL,
  98096LL,
  98112LL,
  98120LL,
  98128LL,
  98136LL,
  98144LL,
  98160LL,
  98448LL,
  98456LL,
  98464LL,
  98472LL,
  98480LL,
  98488LL,
  98496LL,
  98504LL,
  98512LL,
  98520LL,
  98608LL,
  98688LL,
  98696LL,
  98712LL,
  98720LL,
  98728LL,
  98736LL,
  98744LL,
  98752LL,
  98760LL,
  98768LL,
  98776LL,
  98784LL,
  98792LL,
  98800LL,
  98808LL,
  98816LL,
  98824LL,
  98832LL,
  98840LL,
  98848LL,
  98856LL,
  98864LL,
  98872LL,
  98880LL,
  98888LL,
  98896LL,
  98904LL,
  98912LL,
  98920LL,
  98928LL,
  98936LL,
  98960LL,
  98968LL,
  98976LL,
  98984LL,
  98992LL,
  99000LL,
  99008LL,
  99016LL,
  99024LL,
  99032LL,
  99040LL,
  99048LL,
  99056LL,
  99064LL,
  99072LL,
  99080LL,
  99088LL,
  99096LL,
  99104LL,
  99112LL,
  99120LL,
  99128LL,
  99136LL,
  99144LL,
  99152LL,
  99160LL,
  99168LL,
  99176LL,
  99304LL,
  99312LL,
  99320LL,
  99328LL,
  99336LL,
  99344LL,
  99352LL,
  99360LL,
  99368LL,
  99376LL,
  99384LL,
  99392LL,
  99400LL,
  99408LL,
  99416LL,
  99424LL,
  99432LL,
  99440LL,
  99448LL,
  99456LL,
  99464LL,
  99472LL,
  99480LL,
  99488LL,
  99496LL,
  99504LL,
  99512LL,
  99520LL,
  99528LL,
  99536LL,
  99544LL,
  99552LL,
  99560LL,
  99568LL,
  99576LL,
  99584LL,
  99592LL,
  99600LL,
  99608LL,
  99616LL,
  99624LL,
  99632LL,
  99640LL,
  99648LL,
  99656LL,
  99664LL,
  99672LL,
  99680LL,
  99688LL,
  99696LL,
  99704LL,
  99712LL,
  99720LL,
  99728LL,
  99736LL,
  99744LL,
  99752LL,
  99760LL,
  99768LL,
  99776LL,
  99784LL,
  99792LL,
  99800LL,
  99808LL,
  99816LL,
  99824LL,
  99832LL
}; // weak
__int64 ccrmd128_ltc_di_ptr[169] =
{
  99272LL,
  99280LL,
  99288LL,
  99296LL,
  97920LL,
  97928LL,
  97936LL,
  97944LL,
  97952LL,
  97960LL,
  97968LL,
  97976LL,
  97984LL,
  97992LL,
  98008LL,
  98016LL,
  98024LL,
  98032LL,
  98040LL,
  98048LL,
  98056LL,
  98064LL,
  98072LL,
  98080LL,
  98088LL,
  98096LL,
  98112LL,
  98120LL,
  98128LL,
  98136LL,
  98144LL,
  98160LL,
  98448LL,
  98456LL,
  98464LL,
  98472LL,
  98480LL,
  98488LL,
  98496LL,
  98504LL,
  98512LL,
  98520LL,
  98608LL,
  98688LL,
  98696LL,
  98712LL,
  98720LL,
  98728LL,
  98736LL,
  98744LL,
  98752LL,
  98760LL,
  98768LL,
  98776LL,
  98784LL,
  98792LL,
  98800LL,
  98808LL,
  98816LL,
  98824LL,
  98832LL,
  98840LL,
  98848LL,
  98856LL,
  98864LL,
  98872LL,
  98880LL,
  98888LL,
  98896LL,
  98904LL,
  98912LL,
  98920LL,
  98928LL,
  98936LL,
  98960LL,
  98968LL,
  98976LL,
  98984LL,
  98992LL,
  99000LL,
  99008LL,
  99016LL,
  99024LL,
  99032LL,
  99040LL,
  99048LL,
  99056LL,
  99064LL,
  99072LL,
  99080LL,
  99088LL,
  99096LL,
  99104LL,
  99112LL,
  99120LL,
  99128LL,
  99136LL,
  99144LL,
  99152LL,
  99160LL,
  99168LL,
  99176LL,
  99304LL,
  99312LL,
  99320LL,
  99328LL,
  99336LL,
  99344LL,
  99352LL,
  99360LL,
  99368LL,
  99376LL,
  99384LL,
  99392LL,
  99400LL,
  99408LL,
  99416LL,
  99424LL,
  99432LL,
  99440LL,
  99448LL,
  99456LL,
  99464LL,
  99472LL,
  99480LL,
  99488LL,
  99496LL,
  99504LL,
  99512LL,
  99520LL,
  99528LL,
  99536LL,
  99544LL,
  99552LL,
  99560LL,
  99568LL,
  99576LL,
  99584LL,
  99592LL,
  99600LL,
  99608LL,
  99616LL,
  99624LL,
  99632LL,
  99640LL,
  99648LL,
  99656LL,
  99664LL,
  99672LL,
  99680LL,
  99688LL,
  99696LL,
  99704LL,
  99712LL,
  99720LL,
  99728LL,
  99736LL,
  99744LL,
  99752LL,
  99760LL,
  99768LL,
  99776LL,
  99784LL,
  99792LL,
  99800LL,
  99808LL,
  99816LL,
  99824LL,
  99832LL
}; // weak
__int64 ccrmd160_ltc_di_ptr[168] =
{
  99280LL,
  99288LL,
  99296LL,
  97920LL,
  97928LL,
  97936LL,
  97944LL,
  97952LL,
  97960LL,
  97968LL,
  97976LL,
  97984LL,
  97992LL,
  98008LL,
  98016LL,
  98024LL,
  98032LL,
  98040LL,
  98048LL,
  98056LL,
  98064LL,
  98072LL,
  98080LL,
  98088LL,
  98096LL,
  98112LL,
  98120LL,
  98128LL,
  98136LL,
  98144LL,
  98160LL,
  98448LL,
  98456LL,
  98464LL,
  98472LL,
  98480LL,
  98488LL,
  98496LL,
  98504LL,
  98512LL,
  98520LL,
  98608LL,
  98688LL,
  98696LL,
  98712LL,
  98720LL,
  98728LL,
  98736LL,
  98744LL,
  98752LL,
  98760LL,
  98768LL,
  98776LL,
  98784LL,
  98792LL,
  98800LL,
  98808LL,
  98816LL,
  98824LL,
  98832LL,
  98840LL,
  98848LL,
  98856LL,
  98864LL,
  98872LL,
  98880LL,
  98888LL,
  98896LL,
  98904LL,
  98912LL,
  98920LL,
  98928LL,
  98936LL,
  98960LL,
  98968LL,
  98976LL,
  98984LL,
  98992LL,
  99000LL,
  99008LL,
  99016LL,
  99024LL,
  99032LL,
  99040LL,
  99048LL,
  99056LL,
  99064LL,
  99072LL,
  99080LL,
  99088LL,
  99096LL,
  99104LL,
  99112LL,
  99120LL,
  99128LL,
  99136LL,
  99144LL,
  99152LL,
  99160LL,
  99168LL,
  99176LL,
  99304LL,
  99312LL,
  99320LL,
  99328LL,
  99336LL,
  99344LL,
  99352LL,
  99360LL,
  99368LL,
  99376LL,
  99384LL,
  99392LL,
  99400LL,
  99408LL,
  99416LL,
  99424LL,
  99432LL,
  99440LL,
  99448LL,
  99456LL,
  99464LL,
  99472LL,
  99480LL,
  99488LL,
  99496LL,
  99504LL,
  99512LL,
  99520LL,
  99528LL,
  99536LL,
  99544LL,
  99552LL,
  99560LL,
  99568LL,
  99576LL,
  99584LL,
  99592LL,
  99600LL,
  99608LL,
  99616LL,
  99624LL,
  99632LL,
  99640LL,
  99648LL,
  99656LL,
  99664LL,
  99672LL,
  99680LL,
  99688LL,
  99696LL,
  99704LL,
  99712LL,
  99720LL,
  99728LL,
  99736LL,
  99744LL,
  99752LL,
  99760LL,
  99768LL,
  99776LL,
  99784LL,
  99792LL,
  99800LL,
  99808LL,
  99816LL,
  99824LL,
  99832LL
}; // weak
__int64 ccrmd256_ltc_di_ptr[167] =
{
  99288LL,
  99296LL,
  97920LL,
  97928LL,
  97936LL,
  97944LL,
  97952LL,
  97960LL,
  97968LL,
  97976LL,
  97984LL,
  97992LL,
  98008LL,
  98016LL,
  98024LL,
  98032LL,
  98040LL,
  98048LL,
  98056LL,
  98064LL,
  98072LL,
  98080LL,
  98088LL,
  98096LL,
  98112LL,
  98120LL,
  98128LL,
  98136LL,
  98144LL,
  98160LL,
  98448LL,
  98456LL,
  98464LL,
  98472LL,
  98480LL,
  98488LL,
  98496LL,
  98504LL,
  98512LL,
  98520LL,
  98608LL,
  98688LL,
  98696LL,
  98712LL,
  98720LL,
  98728LL,
  98736LL,
  98744LL,
  98752LL,
  98760LL,
  98768LL,
  98776LL,
  98784LL,
  98792LL,
  98800LL,
  98808LL,
  98816LL,
  98824LL,
  98832LL,
  98840LL,
  98848LL,
  98856LL,
  98864LL,
  98872LL,
  98880LL,
  98888LL,
  98896LL,
  98904LL,
  98912LL,
  98920LL,
  98928LL,
  98936LL,
  98960LL,
  98968LL,
  98976LL,
  98984LL,
  98992LL,
  99000LL,
  99008LL,
  99016LL,
  99024LL,
  99032LL,
  99040LL,
  99048LL,
  99056LL,
  99064LL,
  99072LL,
  99080LL,
  99088LL,
  99096LL,
  99104LL,
  99112LL,
  99120LL,
  99128LL,
  99136LL,
  99144LL,
  99152LL,
  99160LL,
  99168LL,
  99176LL,
  99304LL,
  99312LL,
  99320LL,
  99328LL,
  99336LL,
  99344LL,
  99352LL,
  99360LL,
  99368LL,
  99376LL,
  99384LL,
  99392LL,
  99400LL,
  99408LL,
  99416LL,
  99424LL,
  99432LL,
  99440LL,
  99448LL,
  99456LL,
  99464LL,
  99472LL,
  99480LL,
  99488LL,
  99496LL,
  99504LL,
  99512LL,
  99520LL,
  99528LL,
  99536LL,
  99544LL,
  99552LL,
  99560LL,
  99568LL,
  99576LL,
  99584LL,
  99592LL,
  99600LL,
  99608LL,
  99616LL,
  99624LL,
  99632LL,
  99640LL,
  99648LL,
  99656LL,
  99664LL,
  99672LL,
  99680LL,
  99688LL,
  99696LL,
  99704LL,
  99712LL,
  99720LL,
  99728LL,
  99736LL,
  99744LL,
  99752LL,
  99760LL,
  99768LL,
  99776LL,
  99784LL,
  99792LL,
  99800LL,
  99808LL,
  99816LL,
  99824LL,
  99832LL
}; // weak
__int64 ccrmd320_ltc_di_ptr[166] =
{
  99296LL,
  97920LL,
  97928LL,
  97936LL,
  97944LL,
  97952LL,
  97960LL,
  97968LL,
  97976LL,
  97984LL,
  97992LL,
  98008LL,
  98016LL,
  98024LL,
  98032LL,
  98040LL,
  98048LL,
  98056LL,
  98064LL,
  98072LL,
  98080LL,
  98088LL,
  98096LL,
  98112LL,
  98120LL,
  98128LL,
  98136LL,
  98144LL,
  98160LL,
  98448LL,
  98456LL,
  98464LL,
  98472LL,
  98480LL,
  98488LL,
  98496LL,
  98504LL,
  98512LL,
  98520LL,
  98608LL,
  98688LL,
  98696LL,
  98712LL,
  98720LL,
  98728LL,
  98736LL,
  98744LL,
  98752LL,
  98760LL,
  98768LL,
  98776LL,
  98784LL,
  98792LL,
  98800LL,
  98808LL,
  98816LL,
  98824LL,
  98832LL,
  98840LL,
  98848LL,
  98856LL,
  98864LL,
  98872LL,
  98880LL,
  98888LL,
  98896LL,
  98904LL,
  98912LL,
  98920LL,
  98928LL,
  98936LL,
  98960LL,
  98968LL,
  98976LL,
  98984LL,
  98992LL,
  99000LL,
  99008LL,
  99016LL,
  99024LL,
  99032LL,
  99040LL,
  99048LL,
  99056LL,
  99064LL,
  99072LL,
  99080LL,
  99088LL,
  99096LL,
  99104LL,
  99112LL,
  99120LL,
  99128LL,
  99136LL,
  99144LL,
  99152LL,
  99160LL,
  99168LL,
  99176LL,
  99304LL,
  99312LL,
  99320LL,
  99328LL,
  99336LL,
  99344LL,
  99352LL,
  99360LL,
  99368LL,
  99376LL,
  99384LL,
  99392LL,
  99400LL,
  99408LL,
  99416LL,
  99424LL,
  99432LL,
  99440LL,
  99448LL,
  99456LL,
  99464LL,
  99472LL,
  99480LL,
  99488LL,
  99496LL,
  99504LL,
  99512LL,
  99520LL,
  99528LL,
  99536LL,
  99544LL,
  99552LL,
  99560LL,
  99568LL,
  99576LL,
  99584LL,
  99592LL,
  99600LL,
  99608LL,
  99616LL,
  99624LL,
  99632LL,
  99640LL,
  99648LL,
  99656LL,
  99664LL,
  99672LL,
  99680LL,
  99688LL,
  99696LL,
  99704LL,
  99712LL,
  99720LL,
  99728LL,
  99736LL,
  99744LL,
  99752LL,
  99760LL,
  99768LL,
  99776LL,
  99784LL,
  99792LL,
  99800LL,
  99808LL,
  99816LL,
  99824LL,
  99832LL
}; // weak
char *crc16_a = "crc16-a"; // weak
char *crc16_b = "crc16-b"; // weak
char *crc16_ccitt_false = "crc16-ccitt-false"; // weak
char *crc16_ccitt_true = "crc16-ccitt-true"; // weak
char *crc16_dect_r = "crc16-dect-r"; // weak
char *crc16_dect_x = "crc16-dect-x"; // weak
char *crc16_icode = "crc16-icode"; // weak
char *crc16_usb = "crc16-usb"; // weak
char *crc16_verifone = "crc16-verifone"; // weak
char *crc16_xmodem = "crc16-xmodem"; // weak
char *crc16 = "crc16"; // weak
char *crc32_bzip2 = "crc32-bzip2"; // weak
char *crc32_castagnoli = "crc32-castagnoli"; // weak
char *crc32_mpeg_2 = "crc32-mpeg-2"; // weak
char *crc32_posix = "crc32-posix"; // weak
char *crc32_xfer = "crc32-xfer"; // weak
char *crc64_ecma_182 = "crc64-ecma-182"; // weak
char *crc8_icode = "crc8-icode"; // weak
char *crc8_itu = "crc8-itu"; // weak
char *crc8_rohc = "crc8-rohc"; // weak
char *crc8_wcdma = "crc8-wcdma"; // weak
char *crc8 = "crc8"; // weak
__int64 __block_descriptor_tmp = 0LL; // weak
__int64 __block_descriptor_tmp1 = 0LL; // weak
__int64 __block_descriptor_tmp_0 = 0LL; // weak
__int64 __block_descriptor_tmp1_0 = 0LL; // weak
__int64 __block_descriptor_tmp_1 = 0LL; // weak
__int64 ccz_c = 0LL; // weak
__int64 __block_descriptor_tmp_2 = 0LL; // weak
__int64 __block_descriptor_tmp_3 = 0LL; // weak
int dword_CCA4 = 8; // weak
__int64 __block_descriptor_tmp_4 = 0LL; // weak
__int64 *DRBGcustom = &ccaes_ltc_ecb_encrypt_mode; // weak
__int64 __block_descriptor_tmp2 = 0LL; // weak
__int64 ccmodeList[24] =
{
  98232LL,
  98160LL,
  98208LL,
  98192LL,
  98216LL,
  98264LL,
  98280LL,
  98248LL,
  98176LL,
  98224LL,
  98152LL,
  98200LL,
  98184LL,
  98216LL,
  98264LL,
  98272LL,
  98240LL,
  98168LL,
  98680LL,
  98624LL,
  98656LL,
  98640LL,
  98664LL,
  98704LL
}; // weak
__int64 (__fastcall *ccecb_mode[2])() = { &ccecb_mode_get_ctx_size, &ccecb_mode_get_block_size }; // weak
__int64 (__fastcall *cccbc_mode[2])() = { &cccbc_mode_get_ctx_size, &cccbc_mode_get_block_size }; // weak
__int64 (__fastcall *cccfb_mode[2])() = { &cccfb_mode_get_ctx_size, &cccfb_mode_get_block_size }; // weak
__int64 (__fastcall *cccfb8_mode[2])() = { &cccfb8_mode_get_ctx_size, &cccfb8_mode_get_block_size }; // weak
__int64 (__fastcall *ccctr_mode[2])() = { &ccctr_mode_get_ctx_size, &ccctr_mode_get_block_size }; // weak
__int64 (__fastcall *ccofb_mode[2])() = { &ccofb_mode_get_ctx_size, &ccofb_mode_get_block_size }; // weak
__int64 (__fastcall *ccxts_mode[2])() = { &ccxts_mode_get_ctx_size, &ccxts_mode_get_block_size }; // weak
__int64 (__fastcall *ccgcm_mode[2])() = { &ccgcm_mode_get_ctx_size, &ccgcm_mode_get_block_size }; // weak
__int64 (__fastcall *ccccm_mode[2])() = { &ccccm_mode_get_ctx_size, &ccccm_mode_get_block_size }; // weak
__int64 (__fastcall *ccpkcs7_pad[2])(__int64) = { &ccpkcs7_encrypt_pad, &ccpkcs7_decrypt_pad }; // weak
__int64 (__fastcall *ccpkcs7_ecb_pad[2])(__int64) = { &ccpkcs7_encrypt_ecb_pad, &ccpkcs7_decrypt_ecb_pad }; // weak
__int64 (__fastcall *cccts1_pad[2])(__int64) = { &cccts1_encrypt_pad, &cccts1_decrypt_pad }; // weak
__int64 (__fastcall *cccts2_pad[2])(__int64) = { &cccts2_encrypt_pad, &cccts2_decrypt_pad }; // weak
__int64 (__fastcall *cccts3_pad[2])(__int64) = { &cccts3_encrypt_pad, &cccts3_decrypt_pad }; // weak
__int64 (__fastcall *ccnopad_pad[2])(__int64) = { &ccnopad_encrypt_pad, &ccnopad_decrypt_pad }; // weak
__int64 rc4mode[2] = { 1032LL, 1LL }; // weak
__int64 __block_descriptor_tmp_5 = 0LL; // weak
__int64 __block_descriptor_tmp_6 = 0LL; // weak
__int64 __block_descriptor_tmp1_1 = 0LL; // weak
char *defaultBase16 = "Base16"; // weak
char *hexBase32 = "Base32Hex"; // weak
char *recoveryBase32 = "RecoveryBase32"; // weak
char *defaultBase32 = "Base32"; // weak
char *defaultBase64 = "Base64"; // weak


//----- (0000000000000CE0) ----------------------------------------------------
__int64 __fastcall adler32_implementation(__int64 a1, __int64 a2)
{
  unsigned int v2; // ecx@1
  unsigned int v3; // eax@1

  v2 = 0;
  v3 = 1;
  if ( a1 )
  {
    do
    {
      v3 = (v3 + *(_BYTE *)a2) % 0xFFF1;
      v2 = (v3 + v2) % 0xFFF1;
      ++a2;
      --a1;
    }
    while ( a1 );
    v2 <<= 16;
  }
  return v2 | v3;
}

//----- (0000000000000D36) ----------------------------------------------------
__int64 __fastcall adler32_final(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (0000000000000D3F) ----------------------------------------------------
__int64 __fastcall adler32_oneshot(__int64 a1, __int64 a2)
{
  unsigned int v2; // ecx@1
  unsigned int v3; // eax@1

  v2 = 0;
  v3 = 1;
  if ( a1 )
  {
    do
    {
      v3 = (v3 + *(_BYTE *)a2) % 0xFFF1;
      v2 = (v3 + v2) % 0xFFF1;
      ++a2;
      --a1;
    }
    while ( a1 );
    v2 <<= 16;
  }
  return v2 | v3;
}

//----- (0000000000000D95) ----------------------------------------------------
__int64 adler32_setup()
{
  return 0LL;
}

//----- (0000000000000DA0) ----------------------------------------------------
__int64 __fastcall CCKeyDerivationHMac(int a1, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, char *a12, __int64 a13, __int64 a14, __int64 a15)
{
  __int64 v15; // r15@1
  __int64 v16; // r13@1
  __int64 v17; // r14@1
  unsigned int v18; // er12@1
  __int64 v19; // rax@1
  signed int v20; // edx@6
  char *v21; // r8@6
  int v23; // eax@11

  v15 = a6;
  v16 = a5;
  v17 = a4;
  v18 = a3;
  v19 = CCDigestGetDigestInfo(a2);
  if ( v19 && v16 && v17 && a15 && a14 )
  {
    v20 = -4305;
    v21 = a12;
    switch ( a1 )
    {
      case 0:
        if ( !a12 )
        {
          if ( a13 )
            goto LABEL_9;
          v21 = &byte_B546;
        }
        v23 = ccpbkdf2_hmac(v19, v16, v17, a13, v21, v18);
        break;
      default:
        return (unsigned int)v20;
      case 1:
        v23 = ccnistkdf_ctr_hmac(v19, v16, v17, a7, v15, a9);
        break;
      case 2:
        v23 = ccnistkdf_ctr_hmac_fixed(v19, v16, v17, a9, a8);
        break;
      case 6:
        v23 = cchkdf(v19, v16, v17, a13, a12, a9);
        break;
    }
    v20 = -4300;
    if ( !v23 )
      v20 = 0;
  }
  else
  {
LABEL_9:
    v20 = -4300;
  }
  return (unsigned int)v20;
}
// AB86: using guessed type int __fastcall cchkdf(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// ABF2: using guessed type int __fastcall ccnistkdf_ctr_hmac(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// ABF8: using guessed type int __fastcall ccnistkdf_ctr_hmac_fixed(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// AC46: using guessed type int __fastcall ccpbkdf2_hmac(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// B546: using guessed type char byte_B546;

//----- (0000000000000EF0) ----------------------------------------------------
signed __int64 __fastcall gen_std_crc_table(__int64 a1)
{
  __int64 v1; // rbx@1
  __int64 v2; // r15@1
  void *v3; // rax@1
  void *v4; // rcx@1
  signed __int64 result; // rax@1
  __int64 v6; // r14@2
  signed __int64 v7; // r15@2
  __int64 v8; // r12@4
  int v9; // edx@4
  signed __int64 v10; // rbx@4
  __int64 v11; // r13@4
  __int64 v12; // rax@7
  __int64 v13; // r12@8
  int v14; // edx@8
  signed __int64 v15; // rbx@8
  __int64 v16; // r13@8
  __int64 v17; // rax@11
  __int64 v18; // r12@12
  int v19; // edx@12
  signed __int64 v20; // rbx@12
  __int64 v21; // r13@12
  __int64 v22; // rax@15
  __int64 v23; // r12@16
  int v24; // edx@16
  signed __int64 v25; // rbx@16
  __int64 v26; // r13@16
  __int64 v27; // rax@19
  __int64 v28; // rax@21
  signed int v29; // ecx@21
  bool v30; // zf@22
  __int64 v31; // rax@29
  signed int v32; // ecx@29
  __int64 v33; // rax@37
  signed int v34; // ecx@37
  __int64 v35; // rax@45
  signed int v36; // ecx@45

  v1 = a1;
  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
  v3 = malloc(v2 << 8);
  v4 = v3;
  *(_QWORD *)(a1 + 24) = v3;
  result = 0xFFFFFFFFLL;
  if ( v4 )
  {
    v6 = 0LL;
    v7 = v2 - 1;
    do
    {
      switch ( v7 )
      {
        case 0LL:
          v8 = *(_QWORD *)(v1 + 8);
          v9 = *(_DWORD *)(v8 + 16);
          v10 = 1LL << (8 * (unsigned __int8)v9 - 1);
          LOBYTE(v11) = 0;
          if ( (unsigned int)(v9 - 1) <= 7 )
            v11 = qword_B860[v9 - 1];
          if ( *(_DWORD *)(v8 + 20) )
          {
            v12 = (unsigned __int8)reflect_byte((unsigned __int8)v6);
            v9 = *(_DWORD *)(v8 + 16);
          }
          else
          {
            v12 = (char)v6;
          }
          v28 = v12 << (8 * (unsigned __int8)v9 - 8);
          v29 = 8;
          do
          {
            v30 = (v28 & v10) == 0;
            v28 *= 2LL;
            if ( !v30 )
              v28 ^= *(_QWORD *)(v8 + 32);
            --v29;
          }
          while ( v29 );
          if ( *(_DWORD *)(v8 + 20) )
            LODWORD(v28) = reflect(v28, 8 * v9);
          v1 = a1;
          *(_BYTE *)(*(_QWORD *)(a1 + 24) + v6) = v11 & v28;
          break;
        case 1LL:
          v13 = *(_QWORD *)(v1 + 8);
          v14 = *(_DWORD *)(v13 + 16);
          v15 = 1LL << (8 * (unsigned __int8)v14 - 1);
          LOWORD(v16) = 0;
          if ( (unsigned int)(v14 - 1) <= 7 )
            v16 = qword_B860[v14 - 1];
          if ( *(_DWORD *)(v13 + 20) )
          {
            v17 = (unsigned __int8)reflect_byte((unsigned __int8)v6);
            v14 = *(_DWORD *)(v13 + 16);
          }
          else
          {
            v17 = (char)v6;
          }
          v31 = v17 << (8 * (unsigned __int8)v14 - 8);
          v32 = 8;
          do
          {
            v30 = (v31 & v15) == 0;
            v31 *= 2LL;
            if ( !v30 )
              v31 ^= *(_QWORD *)(v13 + 32);
            --v32;
          }
          while ( v32 );
          if ( *(_DWORD *)(v13 + 20) )
            LODWORD(v31) = reflect(v31, 8 * v14);
          v1 = a1;
          *(_WORD *)(*(_QWORD *)(a1 + 24) + 2 * v6) = v16 & v31;
          break;
        case 3LL:
          v18 = *(_QWORD *)(v1 + 8);
          v19 = *(_DWORD *)(v18 + 16);
          v20 = 1LL << (8 * (unsigned __int8)v19 - 1);
          LODWORD(v21) = 0;
          if ( (unsigned int)(v19 - 1) <= 7 )
            v21 = qword_B860[v19 - 1];
          if ( *(_DWORD *)(v18 + 20) )
          {
            v22 = (unsigned __int8)reflect_byte((unsigned __int8)v6);
            v19 = *(_DWORD *)(v18 + 16);
          }
          else
          {
            v22 = (char)v6;
          }
          v33 = v22 << (8 * (unsigned __int8)v19 - 8);
          v34 = 8;
          do
          {
            v30 = (v33 & v20) == 0;
            v33 *= 2LL;
            if ( !v30 )
              v33 ^= *(_QWORD *)(v18 + 32);
            --v34;
          }
          while ( v34 );
          if ( *(_DWORD *)(v18 + 20) )
            LODWORD(v33) = reflect(v33, 8 * v19);
          v1 = a1;
          *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * v6) = v21 & v33;
          break;
        case 7LL:
          v23 = *(_QWORD *)(v1 + 8);
          v24 = *(_DWORD *)(v23 + 16);
          v25 = 1LL << (8 * (unsigned __int8)v24 - 1);
          v26 = 0LL;
          if ( (unsigned int)(v24 - 1) <= 7 )
            v26 = qword_B860[v24 - 1];
          if ( *(_DWORD *)(v23 + 20) )
          {
            v27 = (unsigned __int8)reflect_byte((unsigned __int8)v6);
            v24 = *(_DWORD *)(v23 + 16);
          }
          else
          {
            v27 = (char)v6;
          }
          v35 = v27 << (8 * (unsigned __int8)v24 - 8);
          v36 = 8;
          do
          {
            v30 = (v35 & v25) == 0;
            v35 *= 2LL;
            if ( !v30 )
              v35 ^= *(_QWORD *)(v23 + 32);
            --v36;
          }
          while ( v36 );
          if ( *(_DWORD *)(v23 + 20) )
            v35 = reflect(v35, 8 * v24);
          v1 = a1;
          *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v6) = v26 & v35;
          break;
        default:
          break;
      }
      ++v6;
      result = 0LL;
    }
    while ( v6 != 256 );
  }
  return result;
}
// B860: using guessed type __int64 qword_B860[3];

//----- (0000000000001230) ----------------------------------------------------
int __usercall dump_crc_table@<eax>(__int64 a1@<rax>, __int64 a2@<rdi>)
{
  __int64 v2; // r15@1
  __int64 v3; // rax@1
  __int64 v4; // r12@1
  char *v5; // rax@1
  const char *v6; // r14@1
  char v7; // al@1
  size_t v8; // rbx@1
  signed int v9; // er13@7
  signed __int64 v10; // r12@7
  const char *v11; // rdi@9
  __int64 v12; // r14@13
  __int64 v14; // [sp-8h] [bp-30h]@1

  v14 = a1;
  v2 = a2;
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_DWORD *)(v3 + 16);
  v5 = strndup(*(const char **)v3, 0x40uLL);
  v6 = v5;
  v7 = *v5;
  v8 = 1LL;
  if ( v7 )
  {
    while ( 1 )
    {
      if ( v7 == 45 )
        v6[v8 - 1] = 95;
      if ( v8 >= strlen(v6) )
        break;
      v7 = v6[v8++];
    }
  }
  v9 = 8;
  v10 = v4 - 1;
  switch ( v10 )
  {
    case 0LL:
      printf("const uint8_t %s_crc_table[] = {\n", v6, v14);
      v9 = 16;
      break;
    case 1LL:
      v11 = "const uint16_t %s_crc_table[] = {\n";
      goto LABEL_11;
    case 3LL:
      v11 = "const uint32_t %s_crc_table[] = {\n";
LABEL_11:
      printf(v11, v6, v14);
      break;
    case 7LL:
      printf("const uint64_t %s_crc_table[] = {\n", v6, v14);
      v9 = 4;
      break;
    default:
      break;
  }
  v12 = 0LL;
  do
  {
    switch ( v10 )
    {
      case 0LL:
        printf(" 0x%02x,", *(_BYTE *)(*(_QWORD *)(v2 + 24) + v12), v14);
        break;
      case 1LL:
        printf(" 0x%04x,", *(_WORD *)(*(_QWORD *)(v2 + 24) + 2 * v12), v14);
        break;
      case 3LL:
        printf(" 0x%08x,", *(_DWORD *)(*(_QWORD *)(v2 + 24) + 4 * v12), v14);
        break;
      case 7LL:
        printf(" 0x%016llx,", *(_QWORD *)(*(_QWORD *)(v2 + 24) + 8 * v12), v14);
        break;
      default:
        break;
    }
    ++v12;
    if ( !((signed int)v12 % v9) )
      putchar(10);
  }
  while ( v12 != 256 );
  return puts("};\n");
}

//----- (00000000000013EC) ----------------------------------------------------
__int64 __fastcall crc_normal_init(__int64 a1)
{
  __int64 v2; // [sp+0h] [bp-30h]@1
  int v3; // [sp+8h] [bp-28h]@1
  int v4; // [sp+Ch] [bp-24h]@1
  signed __int64 (__fastcall *v5)(__int64); // [sp+10h] [bp-20h]@1
  __int64 *v6; // [sp+18h] [bp-18h]@1
  __int64 v7; // [sp+20h] [bp-10h]@1

  v2 = _NSConcreteStackBlock_ptr[0];
  v3 = 0x40000000;
  v4 = 0;
  v5 = __crc_normal_init_block_invoke;
  v6 = &__block_descriptor_tmp;
  v7 = a1;
  if ( *(_QWORD *)a1 != -1LL )
    dispatch_once(a1, &v2);
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL);
}
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// CB90: using guessed type __int64 __block_descriptor_tmp;

//----- (000000000000144E) ----------------------------------------------------
signed __int64 __fastcall __crc_normal_init_block_invoke(__int64 a1)
{
  return gen_std_crc_table(*(_QWORD *)(a1 + 32));
}

//----- (000000000000145C) ----------------------------------------------------
unsigned __int64 __fastcall crc_normal_update(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  int i; // er8@1
  int v5; // er8@8
  __int64 v6; // rax@8

  for ( i = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 16LL); a3; ++a2 )
  {
    switch ( i )
    {
      case 1:
        a4 = *(_BYTE *)(*(_QWORD *)(a1 + 24) + (unsigned __int8)(*(_BYTE *)a2 ^ a4));
        break;
      case 2:
        a4 = (unsigned __int16)(*(_WORD *)(*(_QWORD *)(a1 + 24) + 2 * (BYTE1(a4) ^ (unsigned __int64)*(_BYTE *)a2)) ^ ((_WORD)a4 << 8));
        break;
      case 4:
        a4 = (unsigned int)(*(_DWORD *)(*(_QWORD *)(a1 + 24)
                                      + 4 * (*(_BYTE *)a2 ^ (unsigned __int64)(unsigned __int8)(a4 >> 24))) ^ ((_DWORD)a4 << 8));
        break;
      case 8:
        a4 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * ((a4 >> 56) ^ *(_BYTE *)a2)) ^ (a4 << 8);
        break;
      default:
        break;
    }
    --a3;
  }
  v5 = i - 1;
  v6 = 0LL;
  if ( (unsigned int)v5 <= 7 )
    v6 = qword_B8A0[v5];
  return a4 & v6;
}
// B8A0: using guessed type __int64 qword_B8A0[3];

//----- (0000000000001538) ----------------------------------------------------
__int64 __fastcall crc_normal_final(__int64 a1, __int64 a2)
{
  __int64 v2; // rax@1
  __int64 v3; // rcx@1
  int v4; // edx@1
  __int64 v5; // rax@1

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(v2 + 48);
  v4 = *(_DWORD *)(v2 + 16) - 1;
  v5 = 0LL;
  if ( (unsigned int)v4 <= 7 )
    v5 = qword_B8A0[v4];
  return a2 ^ v3 & v5;
}
// B8A0: using guessed type __int64 qword_B8A0[3];

//----- (0000000000001566) ----------------------------------------------------
unsigned __int64 __fastcall crc_normal_oneshot(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx@1
  __int64 v4; // r14@1
  __int64 v5; // r8@2
  unsigned __int64 i; // rax@2
  __int64 v8; // [sp+0h] [bp-40h]@1
  int v9; // [sp+8h] [bp-38h]@1
  int v10; // [sp+Ch] [bp-34h]@1
  signed __int64 (__fastcall *v11)(__int64); // [sp+10h] [bp-30h]@1
  __int64 *v12; // [sp+18h] [bp-28h]@1
  __int64 v13; // [sp+20h] [bp-20h]@1

  v3 = a3;
  v4 = a2;
  v8 = _NSConcreteStackBlock_ptr[0];
  v9 = 0x40000000;
  v10 = 0;
  v11 = __crc_normal_oneshot_block_invoke;
  v12 = &__block_descriptor_tmp1;
  v13 = a1;
  if ( *(_QWORD *)a1 != -1LL )
    dispatch_once(a1, &v8);
  v5 = *(_QWORD *)(a1 + 8);
  for ( i = *(_QWORD *)(v5 + 40); v3; ++v4 )
  {
    switch ( *(_DWORD *)(v5 + 16) )
    {
      case 1:
        i = *(_BYTE *)(*(_QWORD *)(a1 + 24) + (unsigned __int8)(*(_BYTE *)v4 ^ i));
        break;
      case 2:
        i = (unsigned __int16)(*(_WORD *)(*(_QWORD *)(a1 + 24) + 2 * (BYTE1(i) ^ (unsigned __int64)*(_BYTE *)v4)) ^ ((_WORD)i << 8));
        break;
      case 4:
        i = (unsigned int)(*(_DWORD *)(*(_QWORD *)(a1 + 24)
                                     + 4 * (*(_BYTE *)v4 ^ (unsigned __int64)(unsigned __int8)(i >> 24))) ^ ((_DWORD)i << 8));
        break;
      case 8:
        i = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * ((i >> 56) ^ *(_BYTE *)v4)) ^ (i << 8);
        break;
      default:
        break;
    }
    --v3;
  }
  return *(_QWORD *)(v5 + 48) ^ i;
}
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// CBB0: using guessed type __int64 __block_descriptor_tmp1;

//----- (0000000000001694) ----------------------------------------------------
signed __int64 __fastcall __crc_normal_oneshot_block_invoke(__int64 a1)
{
  return gen_std_crc_table(*(_QWORD *)(a1 + 32));
}

//----- (00000000000016A2) ----------------------------------------------------
__int64 __fastcall reflect_byte(__int64 a1)
{
  return *((_BYTE *)reflector + a1);
}
// B8E0: using guessed type __int64 reflector[32];

//----- (00000000000016B3) ----------------------------------------------------
__int64 __fastcall reflect(__int64 a1, unsigned __int64 a2)
{
  __int64 result; // rax@1
  unsigned __int64 v3; // rsi@1
  char *v4; // rax@2
  signed __int64 i; // rcx@2
  __int64 v6; // [sp+0h] [bp-10h]@1
  __int64 v7; // [sp+8h] [bp-8h]@1

  v7 = a1;
  v6 = 0LL;
  result = 0LL;
  v3 = a2 >> 3;
  if ( v3 )
  {
    v4 = (char *)&v6 + v3 - 1;
    for ( i = 1LL; ; ++i )
    {
      *v4 = *((_BYTE *)reflector + (unsigned __int8)a1);
      if ( v3 <= i )
        break;
      LOBYTE(a1) = *((_BYTE *)&v7 + i);
      --v4;
    }
    result = v6;
  }
  return result;
}
// B8E0: using guessed type __int64 reflector[32];

//----- (0000000000001704) ----------------------------------------------------
__int64 __fastcall crc_reverse_init(__int64 a1)
{
  __int64 v2; // [sp+0h] [bp-30h]@1
  int v3; // [sp+8h] [bp-28h]@1
  int v4; // [sp+Ch] [bp-24h]@1
  signed __int64 (__fastcall *v5)(__int64); // [sp+10h] [bp-20h]@1
  __int64 *v6; // [sp+18h] [bp-18h]@1
  __int64 v7; // [sp+20h] [bp-10h]@1

  v2 = _NSConcreteStackBlock_ptr[0];
  v3 = 0x40000000;
  v4 = 0;
  v5 = __crc_reverse_init_block_invoke;
  v6 = &__block_descriptor_tmp_0;
  v7 = a1;
  if ( *(_QWORD *)a1 != -1LL )
    dispatch_once(a1, &v2);
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL);
}
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// CBD0: using guessed type __int64 __block_descriptor_tmp_0;

//----- (0000000000001766) ----------------------------------------------------
signed __int64 __fastcall __crc_reverse_init_block_invoke(__int64 a1)
{
  return gen_std_crc_table(*(_QWORD *)(a1 + 32));
}

//----- (0000000000001774) ----------------------------------------------------
unsigned __int64 __fastcall crc_reverse_update(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // rdx@3

  while ( 1 )
  {
    v4 = -a3;
    while ( 2 )
    {
      ++v4;
      if ( v4 == 1 )
        return a4;
      switch ( *(_DWORD *)(*(_QWORD *)(a1 + 8) + 16LL) )
      {
        default:
          continue;
        case 1:
          a4 = *(_BYTE *)(*(_QWORD *)(a1 + 24) + (unsigned __int8)(*(_BYTE *)a2 ^ a4));
          goto LABEL_2;
        case 2:
          a4 = (unsigned __int16)(*(_WORD *)(*(_QWORD *)(a1 + 24)
                                           + 2 * (*(_BYTE *)a2 ^ (unsigned __int64)(unsigned __int8)a4)) ^ BYTE1(a4));
          break;
        case 4:
          a4 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * (*(_BYTE *)a2 ^ (unsigned __int64)(unsigned __int8)a4)) ^ ((unsigned int)a4 >> 8);
          break;
        case 8:
          a4 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * (*(_BYTE *)a2 ^ (unsigned __int64)(unsigned __int8)a4)) ^ (a4 >> 8);
          break;
      }
      break;
    }
LABEL_2:
    a3 = -v4;
  }
}

//----- (0000000000001828) ----------------------------------------------------
__int64 __fastcall crc_reverse_final(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48LL) ^ a2;
}

//----- (0000000000001839) ----------------------------------------------------
unsigned __int64 __fastcall crc_reverse_oneshot(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx@1
  __int64 v4; // r14@1
  __int64 v5; // r8@2
  unsigned __int64 i; // rax@2
  __int64 v8; // [sp+0h] [bp-40h]@1
  int v9; // [sp+8h] [bp-38h]@1
  int v10; // [sp+Ch] [bp-34h]@1
  signed __int64 (__fastcall *v11)(__int64); // [sp+10h] [bp-30h]@1
  __int64 *v12; // [sp+18h] [bp-28h]@1
  __int64 v13; // [sp+20h] [bp-20h]@1

  v3 = a3;
  v4 = a2;
  v8 = _NSConcreteStackBlock_ptr[0];
  v9 = 0x40000000;
  v10 = 0;
  v11 = __crc_reverse_oneshot_block_invoke;
  v12 = &__block_descriptor_tmp1_0;
  v13 = a1;
  if ( *(_QWORD *)a1 != -1LL )
    dispatch_once(a1, &v8);
  v5 = *(_QWORD *)(a1 + 8);
  for ( i = *(_QWORD *)(v5 + 40); v3; ++v4 )
  {
    switch ( *(_DWORD *)(v5 + 16) )
    {
      case 1:
        i = *(_BYTE *)(*(_QWORD *)(a1 + 24) + (unsigned __int8)(*(_BYTE *)v4 ^ i));
        break;
      case 2:
        i = (unsigned __int16)(*(_WORD *)(*(_QWORD *)(a1 + 24)
                                        + 2 * (*(_BYTE *)v4 ^ (unsigned __int64)(unsigned __int8)i)) ^ BYTE1(i));
        break;
      case 4:
        i = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * (*(_BYTE *)v4 ^ (unsigned __int64)(unsigned __int8)i)) ^ ((unsigned int)i >> 8);
        break;
      case 8:
        i = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * (*(_BYTE *)v4 ^ (unsigned __int64)(unsigned __int8)i)) ^ (i >> 8);
        break;
      default:
        break;
    }
    --v3;
  }
  return *(_QWORD *)(v5 + 48) ^ i;
}
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// CBF0: using guessed type __int64 __block_descriptor_tmp1_0;

//----- (0000000000001958) ----------------------------------------------------
signed __int64 __fastcall __crc_reverse_oneshot_block_invoke(__int64 a1)
{
  return gen_std_crc_table(*(_QWORD *)(a1 + 32));
}

//----- (0000000000001966) ----------------------------------------------------
__int64 __fastcall reverse_poly(__int64 a1, unsigned __int64 a2)
{
  return 2 * reflect(a1, a2) + 1;
}

//----- (0000000000001976) ----------------------------------------------------
__int64 __usercall ccdebug_imp@<rax>(int level@<edi>, char a2@<al>, char *a3@<rdx>, __int64 a4@<rcx>, __int64 a5@<rsi>, __int64 a6@<r8>, __int64 a7@<r9>, __int128 a8@<xmm0>, __int128 a9@<xmm1>, __int128 a10@<xmm2>, __int128 a11@<xmm3>, __int128 a12@<xmm4>, __int128 a13@<xmm5>, __int128 a14@<xmm6>, __int128 a15@<xmm7>, char a16)
{
  char *v16; // r15@1
  int v17; // er14@1
  __int64 v18; // r13@3
  struct __aslclient *v19; // rdi@3
  __int64 i; // rbx@4
  char *v21; // ST00_8@6
  __int64 result; // rax@6
  __int64 v23; // rax@7
  char v24; // [sp+10h] [bp-230h]@6
  __int64 v25; // [sp+28h] [bp-218h]@3
  __int64 v26; // [sp+30h] [bp-210h]@3
  __int64 v27; // [sp+38h] [bp-208h]@3
  __int128 v28; // [sp+40h] [bp-200h]@2
  __int128 v29; // [sp+50h] [bp-1F0h]@2
  __int128 v30; // [sp+60h] [bp-1E0h]@2
  __int128 v31; // [sp+70h] [bp-1D0h]@2
  __int128 v32; // [sp+80h] [bp-1C0h]@2
  __int128 v33; // [sp+90h] [bp-1B0h]@2
  __int128 v34; // [sp+A0h] [bp-1A0h]@2
  __int128 v35; // [sp+B0h] [bp-190h]@2
  __int64 v36; // [sp+C8h] [bp-178h]@5
  int v37; // [sp+D0h] [bp-170h]@5
  int v38; // [sp+D4h] [bp-16Ch]@5
  int (__fastcall *v39)(__int64); // [sp+D8h] [bp-168h]@5
  __int64 *v40; // [sp+E0h] [bp-160h]@5
  __int64 v41; // [sp+E8h] [bp-158h]@5
  char format; // [sp+F0h] [bp-150h]@6
  void *ap; // [sp+1F0h] [bp-50h]@6
  char *v44; // [sp+1F8h] [bp-48h]@6
  char *v45; // [sp+200h] [bp-40h]@6
  __int64 v46; // [sp+210h] [bp-30h]@3

  v16 = a3;
  v17 = level;
  if ( a2 )
  {
    v28 = a8;
    v29 = a9;
    v30 = a10;
    v31 = a11;
    v32 = a12;
    v33 = a13;
    v34 = a14;
    v35 = a15;
  }
  v27 = a7;
  v26 = a6;
  v25 = a4;
  v18 = __stack_chk_guard_ptr[0];
  v46 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v19 = (struct __aslclient *)_os_alloc_once_table_ptr[0];
  if ( *(_QWORD *)(_os_alloc_once_table_ptr[0] + 96) != -1LL )
    goto LABEL_7;
  for ( i = *(_QWORD *)(_os_alloc_once_table_ptr[0] + 104); ; i = v23 )
  {
    v36 = _NSConcreteStackBlock_ptr[0];
    v37 = 0x40000000;
    v38 = 0;
    v39 = __ccdebug_init_block_invoke;
    v40 = &__block_descriptor_tmp_1;
    v41 = i;
    if ( *(_QWORD *)(i + 2232) != -1LL )
      dispatch_once(i + 2232, &v36);
    v45 = &v24;
    v44 = &a16;
    ap = (void *)24;
    v21 = v16;
    v16 = &format;
    __snprintf_chk(&format, 0x100uLL, 0, 0x100uLL, "###CommonCrypto : %s - %s", a5, v21);
    v19 = *(struct __aslclient **)(i + 2240);
    asl_vlog(
      v19,
      *(aslmsg *)(i + 2248),
      v17,
      &format,
      (struct __va_list_tag *__attribute__((__org_typedef(va_list))) )&ap);
    result = *(_QWORD *)v18;
    if ( *(_QWORD *)v18 == v46 )
      break;
LABEL_7:
    LODWORD(v23) = _os_alloc_once((char *)v19 + 96, 3376LL, 0LL);
  }
  return result;
}
// AA12: using guessed type int __fastcall _os_alloc_once(_QWORD, _QWORD, _QWORD);
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];
// C020: using guessed type __int64 _os_alloc_once_table_ptr[174];
// CC10: using guessed type __int64 __block_descriptor_tmp_1;

//----- (0000000000001B19) ----------------------------------------------------
int __fastcall __ccdebug_init_block_invoke(__int64 a1)
{
  char *v1; // rax@1
  uint32_t v2; // edx@1

  v1 = getenv("CC_STDERR");
  v2 = 0;
  if ( v1 )
    v2 = strncmp(v1, "yes", 3uLL) == 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 2240LL) = asl_open("CommonCrypto", "CipherSuite", v2);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 2248LL) = asl_new(0);
  return asl_set(*(aslmsg *)(*(_QWORD *)(a1 + 32) + 2248LL), "Facility", "com.apple.platformsec");
}

//----- (0000000000001BA5) ----------------------------------------------------
void *__fastcall CCCreateBigNum(__int64 a1)
{
  size_t v1; // rax@1
  void *v2; // rbx@1
  signed int v3; // ecx@2

  LODWORD(v1) = ccz_size(&ccz_c);
  v2 = malloc(v1);
  if ( a1 )
  {
    v3 = -4302;
    if ( v2 )
      v3 = 0;
    *(_DWORD *)a1 = v3;
  }
  if ( v2 )
    ccz_init(&ccz_c, v2);
  return v2;
}
// AD24: using guessed type int __fastcall ccz_init(_QWORD, _QWORD);
// AD90: using guessed type int __fastcall ccz_size(_QWORD);
// CC30: using guessed type __int64 ccz_c;

//----- (0000000000001BF7) ----------------------------------------------------
__int64 __fastcall CCBigNumClear(__int64 a1)
{
  ccz_zero(a1);
  return 0LL;
}
// ADD2: using guessed type int __fastcall ccz_zero(_QWORD);

//----- (0000000000001C04) ----------------------------------------------------
void __fastcall CCBigNumFree(void *a1)
{
  ccz_free(a1);
  free(a1);
}
// AD18: using guessed type int __cdecl ccz_free(_QWORD);

//----- (0000000000001C20) ----------------------------------------------------
void *__fastcall CCBigNumCopy(__int64 a1)
{
  void *v1; // rax@1
  void *v2; // rbx@1

  v1 = CCCreateBigNum(a1);
  v2 = v1;
  if ( v1 )
    ccz_set(v1);
  return v2;
}
// AD84: using guessed type int __fastcall ccz_set(_QWORD);

//----- (0000000000001C4A) ----------------------------------------------------
int __fastcall CCBigNumBitCount(__int64 a1)
{
  return ccz_bitlen(a1);
}
// ACFA: using guessed type int __fastcall ccz_bitlen(_QWORD);

//----- (0000000000001C54) ----------------------------------------------------
int __fastcall CCBigNumZeroLSBCount(__int64 a1)
{
  return ccz_trailing_zeros(a1);
}
// ADAE: using guessed type int __fastcall ccz_trailing_zeros(_QWORD);

//----- (0000000000001C5E) ----------------------------------------------------
int __fastcall CCBigNumByteCount(__int64 a1)
{
  return ccz_write_uint_size(a1);
}
// ADCC: using guessed type int __fastcall ccz_write_uint_size(_QWORD);

//----- (0000000000001C68) ----------------------------------------------------
void *__fastcall CCBigNumFromData(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14@1
  void *v4; // rax@1
  void *v5; // rbx@1

  v3 = a3;
  v4 = CCCreateBigNum(a1);
  v5 = v4;
  if ( v4 )
    ccz_read_uint(v4, v3, a2);
  return v5;
}
// AD7E: using guessed type int __fastcall ccz_read_uint(_QWORD, _QWORD, _QWORD);

//----- (0000000000001CA1) ----------------------------------------------------
__int64 __fastcall CCBigNumToData(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14@1
  __int64 v4; // rax@1
  __int64 v5; // r15@1

  v3 = a3;
  LODWORD(v4) = ccz_write_uint_size(a2);
  v5 = v4;
  ccz_write_uint(a2, v4, v3);
  return v5;
}
// ADC6: using guessed type int __fastcall ccz_write_uint(_QWORD, _QWORD, _QWORD);
// ADCC: using guessed type int __fastcall ccz_write_uint_size(_QWORD);

//----- (0000000000001CD8) ----------------------------------------------------
void *__fastcall CCBigNumFromHexString(__int64 a1, const char *a2)
{
  void *v2; // rbx@1
  void *result; // rax@1
  size_t v4; // rax@2

  v2 = CCCreateBigNum(a1);
  result = 0LL;
  if ( v2 )
  {
    v4 = strlen(a2);
    if ( ccz_read_radix(v2, v4, a2, 16LL) )
    {
      ccz_zero(v2);
      result = 0LL;
      if ( a1 )
      {
        *(_DWORD *)a1 = -4304;
        result = 0LL;
      }
    }
    else
    {
      result = v2;
    }
  }
  return result;
}
// AD78: using guessed type int __fastcall ccz_read_radix(_QWORD, _QWORD, _QWORD, _QWORD);
// ADD2: using guessed type int __fastcall ccz_zero(_QWORD);

//----- (0000000000001D3E) ----------------------------------------------------
void *__fastcall CCBigNumToHexString(__int64 a1, __int64 a2)
{
  __int64 v2; // rax@1
  __int64 v3; // r15@1
  void *v4; // rbx@1

  LODWORD(v2) = ccz_write_radix_size(a2, 16LL);
  v3 = v2;
  v4 = malloc(v2 + 1);
  ccz_write_radix(a2, v3, v4, 16LL);
  *((_BYTE *)v4 + v3) = 0;
  return v4;
}
// ADBA: using guessed type int __fastcall ccz_write_radix(_QWORD, _QWORD, _QWORD, _QWORD);
// ADC0: using guessed type int __fastcall ccz_write_radix_size(_QWORD, _QWORD);

//----- (0000000000001D8D) ----------------------------------------------------
void *__fastcall CCBigNumFromDecimalString(__int64 a1, const char *a2)
{
  void *v2; // rbx@1
  void *result; // rax@1
  size_t v4; // rax@2

  v2 = CCCreateBigNum(a1);
  result = 0LL;
  if ( v2 )
  {
    v4 = strlen(a2);
    if ( ccz_read_radix(v2, v4, a2, 10LL) )
    {
      ccz_zero(v2);
      result = 0LL;
      if ( a1 )
      {
        *(_DWORD *)a1 = -4304;
        result = 0LL;
      }
    }
    else
    {
      result = v2;
    }
  }
  return result;
}
// AD78: using guessed type int __fastcall ccz_read_radix(_QWORD, _QWORD, _QWORD, _QWORD);
// ADD2: using guessed type int __fastcall ccz_zero(_QWORD);

//----- (0000000000001DF3) ----------------------------------------------------
void *__fastcall CCBigNumToDecimalString(__int64 a1, __int64 a2)
{
  __int64 v2; // rax@1
  __int64 v3; // r15@1
  void *v4; // rbx@1

  LODWORD(v2) = ccz_write_radix_size(a2, 10LL);
  v3 = v2;
  v4 = malloc(v2 + 1);
  ccz_write_radix(a2, v3, v4, 10LL);
  *((_BYTE *)v4 + v3) = 0;
  return v4;
}
// ADBA: using guessed type int __fastcall ccz_write_radix(_QWORD, _QWORD, _QWORD, _QWORD);
// ADC0: using guessed type int __fastcall ccz_write_radix_size(_QWORD, _QWORD);

//----- (0000000000001E42) ----------------------------------------------------
int CCBigNumCompare()
{
  return ccz_cmp();
}
// AD00: using guessed type int ccz_cmp(void);

//----- (0000000000001E4C) ----------------------------------------------------
int CCBigNumCompareI()
{
  return ccz_cmpi();
}
// AD06: using guessed type int ccz_cmpi(void);

//----- (0000000000001E56) ----------------------------------------------------
__int64 CCBigNumSetNegative()
{
  ccz_neg();
  return 0LL;
}
// AD6C: using guessed type int ccz_neg(void);

//----- (0000000000001E63) ----------------------------------------------------
__int64 __fastcall CCBigNumSetI(__int64 a1, __int64 a2)
{
  ccz_seti(a1, a2);
  return 0LL;
}
// AD8A: using guessed type int __fastcall ccz_seti(_QWORD, _QWORD);

//----- (0000000000001E70) ----------------------------------------------------
__int64 __usercall CCBigNumGetI@<rax>(__int64 a1@<rax>, __int64 a2@<rdi>, __int64 a3@<rsi>)
{
  unsigned __int64 v3; // rax@1
  __int64 result; // rax@2
  __int64 v5; // [sp-4h] [bp-20h]@1

  v5 = a1;
  LODWORD(v3) = ccz_write_int_size(a3);
  if ( v3 < 5 )
  {
    ccz_write_uint(a3, 4LL, (char *)&v5 + 4);
    result = _byteswap_ulong(HIDWORD(v5));
    if ( a2 )
      *(_DWORD *)a2 = 0;
  }
  else
  {
    *(_DWORD *)a2 = -4306;
    result = 0LL;
  }
  return result;
}
// ADB4: using guessed type int __fastcall ccz_write_int_size(_QWORD);
// ADC6: using guessed type int __fastcall ccz_write_uint(_QWORD, _QWORD, _QWORD);

//----- (0000000000001EC9) ----------------------------------------------------
void *__usercall CCBigNumCreateRandom@<rax>(int a1@<edx>, int a2@<ecx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5@<r9>, __int128 a6@<xmm0>, __int128 a7@<xmm1>, __int128 a8@<xmm2>, __int128 a9@<xmm3>, __int128 a10@<xmm4>, __int128 a11@<xmm5>, __int128 a12@<xmm6>, __int128 a13@<xmm7>)
{
  unsigned __int64 v13; // r12@1
  __int64 v14; // r15@1
  __int64 v15; // r14@1
  void *v16; // r13@1
  __int64 v17; // rax@4
  __int64 v18; // rbx@4
  __int64 v19; // rax@4

  LODWORD(v13) = a2;
  LODWORD(v14) = a1;
  v15 = ccDRBGGetRngState(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
  v16 = CCCreateBigNum(a3);
  if ( v16 && (signed int)v14 > 0 )
  {
    v14 = (signed int)v14;
    v13 = (signed int)v13;
    do
    {
      ccz_random_bits(v16, v14, v15);
      LODWORD(v17) = ccz_bitlen(v16);
      v18 = v17;
      LODWORD(v19) = ccz_trailing_zeros(v16);
    }
    while ( v18 - v19 < v13 );
  }
  return v16;
}
// ACFA: using guessed type int __fastcall ccz_bitlen(_QWORD);
// AD72: using guessed type int __fastcall ccz_random_bits(_QWORD, _QWORD, _QWORD);
// ADAE: using guessed type int __fastcall ccz_trailing_zeros(_QWORD);

//----- (0000000000001F3E) ----------------------------------------------------
__int64 CCBigNumAdd()
{
  ccz_add();
  return 0LL;
}
// ACE8: using guessed type int ccz_add(void);

//----- (0000000000001F4B) ----------------------------------------------------
__int64 CCBigNumAddI()
{
  ccz_addi();
  return 0LL;
}
// ACEE: using guessed type int ccz_addi(void);

//----- (0000000000001F58) ----------------------------------------------------
__int64 CCBigNumSub()
{
  ccz_sub();
  return 0LL;
}
// ADA2: using guessed type int ccz_sub(void);

//----- (0000000000001F65) ----------------------------------------------------
__int64 CCBigNumSubI()
{
  ccz_subi();
  return 0LL;
}
// ADA8: using guessed type int ccz_subi(void);

//----- (0000000000001F72) ----------------------------------------------------
__int64 CCBigNumMul()
{
  ccz_mul();
  return 0LL;
}
// AD5A: using guessed type int ccz_mul(void);

//----- (0000000000001F7F) ----------------------------------------------------
__int64 CCBigNumMulI()
{
  ccz_muli();
  return 0LL;
}
// AD60: using guessed type int ccz_muli(void);

//----- (0000000000001F8C) ----------------------------------------------------
__int64 CCBigNumDiv()
{
  ccz_divmod();
  return 0LL;
}
// AD0C: using guessed type int ccz_divmod(void);

//----- (0000000000001F99) ----------------------------------------------------
__int64 __fastcall CCBigNumDiv2(__int64 a1, __int64 a2)
{
  ccz_lsr(a1, a2, 1LL);
  return 0LL;
}
// AD4E: using guessed type int __fastcall ccz_lsr(_QWORD, _QWORD, _QWORD);

//----- (0000000000001FAB) ----------------------------------------------------
__int64 __fastcall CCBigNumMod(__int64 a1, __int64 a2, __int64 a3)
{
  ccz_mod(a1, a2, a3);
  return 0LL;
}
// AD54: using guessed type int __fastcall ccz_mod(_QWORD, _QWORD, _QWORD);

//----- (0000000000001FB8) ----------------------------------------------------
__int64 __usercall CCBigNumModI@<rax>(__int64 a1@<rax>, unsigned int a2@<edx>, __int64 a3@<rdi>, __int64 a4@<rsi>)
{
  unsigned int v4; // er12@1
  void *v5; // rbx@1
  void *v6; // rax@2
  void *v7; // r13@2
  __int64 v8; // rax@3
  __int64 v10; // [sp-4h] [bp-30h]@1

  v10 = a1;
  v4 = a2;
  HIDWORD(v10) = 0;
  v5 = CCCreateBigNum((__int64)((char *)&v10 + 4));
  if ( v5 )
  {
    v6 = CCCreateBigNum((__int64)((char *)&v10 + 4));
    v7 = v6;
    if ( v6 )
    {
      ccz_seti(v6, v4);
      HIDWORD(v10) = 0;
      LODWORD(v8) = ccz_mod(v5, a4, v7);
      *(_DWORD *)a3 = CCBigNumGetI(v8, (__int64)((char *)&v10 + 4), (__int64)v5);
    }
    ccz_free(v5);
    free(v5);
  }
  return HIDWORD(v10);
}
// AD18: using guessed type int __cdecl ccz_free(_QWORD);
// AD54: using guessed type int __fastcall ccz_mod(_QWORD, _QWORD, _QWORD);
// AD8A: using guessed type int __fastcall ccz_seti(_QWORD, _QWORD);

//----- (0000000000002049) ----------------------------------------------------
__int64 CCBigNumSquare()
{
  ccz_sqr();
  return 0LL;
}
// AD96: using guessed type int ccz_sqr(void);

//----- (0000000000002056) ----------------------------------------------------
__int64 CCBigNumGCD()
{
  ccz_gcd();
  return 0LL;
}
// AD1E: using guessed type int ccz_gcd(void);

//----- (0000000000002063) ----------------------------------------------------
__int64 CCBigNumLCM()
{
  ccz_lcm();
  return 0LL;
}
// AD42: using guessed type int ccz_lcm(void);

//----- (0000000000002070) ----------------------------------------------------
__int64 CCBigNumMulMod()
{
  ccz_mulmod();
  return 0LL;
}
// AD66: using guessed type int ccz_mulmod(void);

//----- (000000000000207D) ----------------------------------------------------
__int64 CCBigNumSquareMod()
{
  ccz_sqrmod();
  return 0LL;
}
// AD9C: using guessed type int ccz_sqrmod(void);

//----- (000000000000208A) ----------------------------------------------------
__int64 CCBigNumInverseMod()
{
  ccz_invmod();
  return 0LL;
}
// AD2A: using guessed type int ccz_invmod(void);

//----- (0000000000002097) ----------------------------------------------------
__int64 CCBigNumModExp()
{
  ccz_expmod();
  return 0LL;
}
// AD12: using guessed type int ccz_expmod(void);

//----- (00000000000020A4) ----------------------------------------------------
__int64 __fastcall CCBigNumLeftShift(__int64 a1, __int64 a2, unsigned int a3)
{
  ccz_lsl(a1, a2, a3);
  return 0LL;
}
// AD48: using guessed type int __fastcall ccz_lsl(_QWORD, _QWORD, _QWORD);

//----- (00000000000020B3) ----------------------------------------------------
__int64 __fastcall CCBigNumRightShift(__int64 a1, __int64 a2, unsigned int a3)
{
  ccz_lsr(a1, a2, a3);
  return 0LL;
}
// AD4E: using guessed type int __fastcall ccz_lsr(_QWORD, _QWORD, _QWORD);

//----- (00000000000020C2) ----------------------------------------------------
signed __int64 CCBigNumMontgomerySetup()
{
  return 4294962991LL;
}

//----- (00000000000020CD) ----------------------------------------------------
signed __int64 CCBigNumMontgomeryNormalization()
{
  return 4294962991LL;
}

//----- (00000000000020D8) ----------------------------------------------------
signed __int64 CCBigNumMontgomeryReduce()
{
  return 4294962991LL;
}

//----- (00000000000020E3) ----------------------------------------------------
int __fastcall CCBigNumIsPrime(__int64 a1, __int64 a2)
{
  if ( a1 )
    *(_DWORD *)a1 = 0;
  return ccz_is_prime(a2, 16LL);
}
// AD36: using guessed type int __fastcall ccz_is_prime(_QWORD, _QWORD);

//----- (0000000000002103) ----------------------------------------------------
int __fastcall CCBigNumIsOdd(__int64 a1, __int64 a2)
{
  if ( a1 )
    *(_DWORD *)a1 = 0;
  return ccz_bit(a2, 0LL);
}
// ACF4: using guessed type int __fastcall ccz_bit(_QWORD, _QWORD);

//----- (0000000000002120) ----------------------------------------------------
int __fastcall CCBigNumIsZero(__int64 a1, __int64 a2)
{
  if ( a1 )
    *(_DWORD *)a1 = 0;
  return ccz_is_zero(a2);
}
// AD3C: using guessed type int __fastcall ccz_is_zero(_QWORD);

//----- (0000000000002138) ----------------------------------------------------
int __fastcall CCBigNumIsNegative(__int64 a1, __int64 a2)
{
  if ( a1 )
    *(_DWORD *)a1 = 0;
  return ccz_is_negative(a2);
}
// AD30: using guessed type int __fastcall ccz_is_negative(_QWORD);

//----- (0000000000002150) ----------------------------------------------------
void *__fastcall cc_alloc(__int64 a1, size_t a2)
{
  return malloc(a2);
}

//----- (000000000000215D) ----------------------------------------------------
void *__fastcall cc_realloc(__int64 a1, size_t a2, const void *a3, size_t a4)
{
  const void *v4; // r15@1
  void *v5; // rbx@1

  v4 = a3;
  v5 = malloc(a4);
  memcpy(v5, v4, a2);
  free((void *)v4);
  return v5;
}

//----- (000000000000219C) ----------------------------------------------------
void __fastcall cc_free(__int64 a1, __int64 a2, void *a3)
{
  free(a3);
}

//----- (00000000000021A9) ----------------------------------------------------
int __fastcall CCAESCmac(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r14@1
  __int64 v5; // r12@1
  __int64 v6; // rax@1

  v4 = a4;
  v5 = a3;
  LODWORD(v6) = ccaes_cbc_encrypt_mode(a1);
  return cccmac(v6, a1, v5, a2, v4);
}
// AAA2: using guessed type int __fastcall ccaes_cbc_encrypt_mode(_QWORD);
// AAA8: using guessed type int __fastcall cccmac(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000021E1) ----------------------------------------------------
void *__fastcall CCAESCmacCreate(__int64 a1)
{
  void *v1; // rbx@1
  void *result; // rax@1
  __int64 v3; // rax@2
  __int64 v4; // r15@2
  void *v5; // rax@2

  v1 = malloc(0x28uLL);
  result = 0LL;
  if ( v1 )
  {
    LODWORD(v3) = ccaes_cbc_encrypt_mode(40LL);
    v4 = v3;
    *(_QWORD *)v1 = v3;
    v5 = malloc(*(_QWORD *)(v3 + 8) + *(_QWORD *)v3 + 40LL);
    *((_QWORD *)v1 + 1) = v5;
    *((_QWORD *)v1 + 2) = 0LL;
    if ( v5 )
    {
      cccmac_init(v4, v5, a1);
      result = v1;
    }
    else
    {
      free(v1);
      result = 0LL;
    }
  }
  return result;
}
// AAA2: using guessed type int __fastcall ccaes_cbc_encrypt_mode(_QWORD);
// AABA: using guessed type int __fastcall cccmac_init(_QWORD, _QWORD, _QWORD);

//----- (0000000000002257) ----------------------------------------------------
void __fastcall CCAESCmacUpdate(__int64 a1, const void *a2, size_t a3)
{
  unsigned __int64 v3; // r14@2
  __int64 i; // rax@3
  size_t v5; // rbx@5
  bool v6; // zf@12
  signed __int64 v7; // [sp+8h] [bp-38h]@2
  size_t v8; // [sp+10h] [bp-30h]@1

  v8 = a3;
  if ( a3 )
  {
    v3 = *(_QWORD *)(*(_QWORD *)a1 + 8LL);
    v7 = v3 - 1;
    do
    {
      for ( i = *(_QWORD *)(a1 + 16); ; i = 0LL )
      {
        v5 = v3 - i;
        if ( v3 != i )
          break;
        cccmac_block_update(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), 1LL, a1 + 24);
        *(_QWORD *)(a1 + 16) = 0LL;
      }
      if ( i || v8 <= v3 )
      {
        if ( v8 < v5 )
          v5 = v8;
        memcpy((void *)(a1 + i + 24), a2, v5);
        *(_QWORD *)(a1 + 16) += v5;
      }
      else
      {
        cccmac_block_update(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), (v7 + v8) / v3 - 1, a2);
        v5 = v3 * ((v7 + v8) / v3 - 1);
      }
      v6 = v8 == v5;
      v8 -= v5;
      a2 = (char *)a2 + v5;
    }
    while ( !v6 );
  }
}
// AAAE: using guessed type int __fastcall cccmac_block_update(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000002330) ----------------------------------------------------
int __fastcall CCAESCmacFinal(__int64 a1, __int64 a2)
{
  return cccmac_final(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), a1 + 24, a2);
}
// AAB4: using guessed type int __fastcall cccmac_final(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000234F) ----------------------------------------------------
void __fastcall CCAESCmacDestroy(__int64 a1)
{
  if ( a1 )
  {
    *(_QWORD *)(a1 + 32) = 0LL;
    *(_QWORD *)(a1 + 24) = 0LL;
    free((void *)a1);
  }
}

//----- (0000000000002370) ----------------------------------------------------
__int64 __fastcall CCAESCmacOutputSizeFromContext(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 8LL);
}

//----- (0000000000002380) ----------------------------------------------------
__int64 __fastcall getCipherMode(int a1, int a2, unsigned int a3)
{
  __int64 v3; // rsi@2
  signed __int64 v4; // rax@3
  signed __int64 v5; // rbx@3
  __int64 v6; // r14@3
  __int64 v7; // rax@3
  __int64 result; // rax@7
  __int64 v9; // rax@9
  signed __int64 v10; // [sp+8h] [bp-78h]@3
  unsigned int v11; // [sp+14h] [bp-6Ch]@2
  int v12; // [sp+18h] [bp-68h]@2
  __int64 v13; // [sp+20h] [bp-60h]@3
  __int64 v14; // [sp+28h] [bp-58h]@4
  int v15; // [sp+30h] [bp-50h]@5
  int v16; // [sp+34h] [bp-4Ch]@5
  int (__fastcall *v17)(__int64); // [sp+38h] [bp-48h]@5
  __int64 *v18; // [sp+40h] [bp-40h]@5
  __int64 v19; // [sp+48h] [bp-38h]@5
  int v20; // [sp+50h] [bp-30h]@5
  int v21; // [sp+54h] [bp-2Ch]@5

  if ( *(_QWORD *)(_os_alloc_once_table_ptr[0] + 96) == -1LL )
  {
    v12 = a2;
    v11 = a3;
    v3 = *(_QWORD *)(_os_alloc_once_table_ptr[0] + 104);
  }
  else
  {
    v12 = a2;
    v11 = a3;
    LODWORD(v9) = _os_alloc_once(_os_alloc_once_table_ptr[0] + 96, 3376LL, 0LL);
    v3 = v9;
  }
  v13 = v3;
  v4 = 160LL * (unsigned int)a1;
  v10 = v4;
  v5 = v4 + v3 + 2256;
  v6 = 0LL;
  v7 = _NSConcreteStackBlock_ptr[0];
  do
  {
    v14 = v7;
    v15 = 0x40000000;
    v16 = 0;
    v17 = __getCipherMode_block_invoke;
    v18 = &__block_descriptor_tmp_2;
    v19 = v3;
    v20 = a1;
    v21 = v6;
    if ( *(_QWORD *)v5 != -1LL )
    {
      dispatch_once(v5, &v14);
      v7 = _NSConcreteStackBlock_ptr[0];
      v3 = v13;
    }
    ++v6;
    v5 += 80LL;
  }
  while ( v6 != 2 );
  result = 0LL;
  switch ( v12 )
  {
    case 1:
      result = *(_QWORD *)(80LL * v11 + v10 + v3 + 2264);
      break;
    case 2:
      result = *(_QWORD *)(80LL * v11 + v10 + v3 + 2272);
      break;
    case 3:
      result = *(_QWORD *)(80LL * v11 + v10 + v3 + 2280);
      break;
    case 4:
      result = *(_QWORD *)(80LL * v11 + v10 + v3 + 2296);
      break;
    case 7:
      result = *(_QWORD *)(80LL * v11 + v10 + v3 + 2304);
      break;
    case 8:
      result = *(_QWORD *)(80LL * v11 + v10 + v3 + 2312);
      break;
    case 10:
      result = *(_QWORD *)(80LL * v11 + v10 + v3 + 2288);
      break;
    case 11:
      result = *(_QWORD *)(80LL * v11 + v10 + v3 + 2320);
      break;
    case 12:
      result = *(_QWORD *)(80LL * v11 + v10 + v3 + 2328);
      break;
    default:
      return result;
  }
  return result;
}
// AA12: using guessed type int __fastcall _os_alloc_once(_QWORD, _QWORD, _QWORD);
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// C020: using guessed type __int64 _os_alloc_once_table_ptr[174];
// CC50: using guessed type __int64 __block_descriptor_tmp_2;

//----- (00000000000025A0) ----------------------------------------------------
int __fastcall __getCipherMode_block_invoke(__int64 a1)
{
  __int64 v1; // rax@1
  __int64 v2; // rcx@1
  __int64 v3; // rdx@1
  __int64 v4; // rax@1
  __int64 v5; // rcx@1
  __int64 v6; // rdx@1
  __int64 v7; // rax@1
  __int64 v8; // rcx@1
  __int64 v9; // rdx@1
  __int64 v10; // rax@1
  __int64 v11; // rcx@1
  __int64 v12; // rdx@1
  __int64 v13; // rax@1
  __int64 v14; // rcx@1
  __int64 v15; // rdx@1
  __int64 v16; // rax@1
  __int64 v17; // rcx@1
  __int64 v18; // rdx@1
  __int64 v19; // rax@1
  __int64 v20; // rcx@1
  __int64 v21; // rdx@1
  __int64 v22; // rax@1
  __int64 v23; // rcx@1
  __int64 v24; // rdx@1
  __int64 v25; // rax@1

  LODWORD(v1) = ((int (*)(void))*(&ccmodeList[18 * (unsigned __int64)*(_DWORD *)(a1 + 40)] + 9 * *(_DWORD *)(a1 + 44)))();
  v2 = *(_DWORD *)(a1 + 44);
  v3 = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(80 * v2 + *(_QWORD *)(a1 + 32) + 160 * v3 + 2264) = v1;
  LODWORD(v4) = ((int (*)(void))*(&ccmodeList[18 * v3 + 1] + 9 * v2))();
  v5 = *(_DWORD *)(a1 + 44);
  v6 = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(80 * v5 + *(_QWORD *)(a1 + 32) + 160 * v6 + 2272) = v4;
  LODWORD(v7) = ((int (*)(void))*(&ccmodeList[18 * v6 + 2] + 9 * v5))();
  v8 = *(_DWORD *)(a1 + 44);
  v9 = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(80 * v8 + *(_QWORD *)(a1 + 32) + 160 * v9 + 2280) = v7;
  LODWORD(v10) = ((int (*)(void))*(&ccmodeList[18 * v9 + 3] + 9 * v8))();
  v11 = *(_DWORD *)(a1 + 44);
  v12 = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(80 * v11 + *(_QWORD *)(a1 + 32) + 160 * v12 + 2288) = v10;
  LODWORD(v13) = ((int (*)(void))*(&ccmodeList[18 * v12 + 4] + 9 * v11))();
  v14 = *(_DWORD *)(a1 + 44);
  v15 = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(80 * v14 + *(_QWORD *)(a1 + 32) + 160 * v15 + 2296) = v13;
  LODWORD(v16) = ((int (*)(void))*(&ccmodeList[18 * v15 + 5] + 9 * v14))();
  v17 = *(_DWORD *)(a1 + 44);
  v18 = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(80 * v17 + *(_QWORD *)(a1 + 32) + 160 * v18 + 2304) = v16;
  LODWORD(v19) = ((int (*)(void))*(&ccmodeList[18 * v18 + 6] + 9 * v17))();
  v20 = *(_DWORD *)(a1 + 44);
  v21 = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(80 * v20 + *(_QWORD *)(a1 + 32) + 160 * v21 + 2312) = v19;
  LODWORD(v22) = ((int (*)(void))*(&ccmodeList[18 * v21 + 7] + 9 * v20))();
  v23 = *(_DWORD *)(a1 + 44);
  v24 = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(80 * v23 + *(_QWORD *)(a1 + 32) + 160 * v24 + 2320) = v22;
  LODWORD(v25) = ((int (*)(void))*(&ccmodeList[18 * v24 + 8] + 9 * v23))();
  *(_QWORD *)(80LL * *(_DWORD *)(a1 + 44) + *(_QWORD *)(a1 + 32) + 160LL * *(_DWORD *)(a1 + 40) + 2328) = v25;
  return v25;
}
// CD80: using guessed type __int64 ccmodeList[24];

//----- (00000000000027A2) ----------------------------------------------------
__int64 __fastcall CCCryptorCreateFromData(unsigned int a1, int a2, unsigned int a3, __int64 a4, size_t a5, char *a6, __int64 a7, unsigned __int64 a8, __int64 a9, __int64 a10)
{
  __int64 v10; // r14@1
  signed __int64 v11; // rbx@3
  __int64 result; // rax@5

  v10 = a7;
  if ( a7 & 7 )
    v10 = (a7 + 8) & 0xFFFFFFFFFFFFFFF8LL;
  v11 = v10 - a7 + 16;
  if ( a10 )
    *(_QWORD *)a10 = v11;
  result = 4294962995LL;
  if ( v11 <= a8 && v10 )
  {
    result = CCCryptorCreate(a1, a2, a3, a4, a5, a6, v10);
    if ( !(_DWORD)result )
    {
      *(_QWORD *)a9 = v10;
      result = 0LL;
    }
  }
  return result;
}

//----- (0000000000002808) ----------------------------------------------------
__int64 __fastcall CCCryptorCreate(unsigned int a1, int a2, unsigned int a3, __int64 a4, size_t a5, char *a6, __int64 a7)
{
  unsigned int v7; // eax@1
  int v8; // edx@1
  signed int v9; // esi@1
  __int64 v11; // [sp+10h] [bp-20h]@0
  __int64 v12; // [sp+18h] [bp-18h]@0

  v7 = a3;
  v8 = a2;
  v9 = 9;
  if ( v8 != 4 )
    v9 = 2 - ((v7 >> 1) & 1);
  return CCCryptorCreateWithMode(a1, v9, v8, v7 & 1, a6, a4, a5, 0LL, v11, v12, 0, a7);
}

//----- (0000000000002863) ----------------------------------------------------
__int64 __fastcall CCCryptorCreateWithMode(unsigned int a1, signed int a2, int a3, signed int a4, char *a5, __int64 a6, size_t a7, __int64 a8, __int64 a9, __int64 a10, int a11, __int64 a12)
{
  char *v12; // rbx@1
  int v13; // er14@1
  signed int v14; // er13@4
  const void *v15; // r13@8
  int v16; // ST20_4@8
  signed int v17; // er14@8
  void *v18; // rax@8
  signed int v19; // edi@8
  signed int v20; // edx@8
  const void *v21; // rsi@8
  unsigned int v22; // er15@9
  void *v23; // rbx@9
  __int64 v24; // r12@9
  void *v25; // rax@11
  __int64 v26; // rdi@11
  signed int v27; // ecx@14
  signed __int64 v28; // rsi@18
  __int64 v29; // rax@18
  __int64 v30; // rcx@19
  signed __int64 v31; // rsi@27
  __int64 v32; // rax@27
  __int64 v33; // rcx@28
  size_t v34; // rax@34
  void *v35; // rax@34
  signed __int64 v37; // rsi@42
  __int64 v38; // rax@42
  __int64 v39; // rcx@43
  size_t v40; // rax@60
  void *v41; // rax@60
  __int64 v42; // rax@62
  __int64 v43; // rax@64
  __int64 v44; // rax@66
  __int64 v45; // rax@68
  __int64 v46; // rax@70
  __int64 v47; // rax@72
  size_t v48; // rax@74
  void *v49; // rax@74
  __int64 v50; // rsi@76
  __int64 v51; // rax@77
  unsigned int v52; // edx@79
  __int64 v53; // rax@80
  __int64 v54; // rax@91
  char *v55; // [sp+10h] [bp-50h]@9
  signed int v56; // [sp+1Ch] [bp-44h]@9
  signed int v57; // [sp+28h] [bp-38h]@9
  signed int v58; // [sp+28h] [bp-38h]@18
  unsigned int v59; // [sp+34h] [bp-2Ch]@8

  v12 = a5;
  v13 = 0;
  if ( (a3 & 0xFFFFFFFE) != 20 )
    v13 = a3;
  if ( a2 != 4 || (v14 = -4305, a11 == 2) )
  {
    v14 = -4300;
    if ( a12 )
    {
      if ( a6 )
      {
        if ( a6 & 3 )
        {
          v59 = a1;
          v15 = (const void *)a6;
          v16 = v13;
          v17 = a4;
          v18 = malloc(a7);
          v19 = a2;
          v20 = v17;
          v13 = v16;
          v21 = v15;
          v14 = -4302;
          if ( !v18 )
            return (unsigned int)v14;
          v57 = v19;
          v56 = v20;
          v22 = v59;
          v55 = v12;
          v23 = v18;
          memcpy(v18, v21, a7);
          v24 = (__int64)v23;
        }
        else
        {
          v57 = a2;
          v56 = a4;
          v22 = a1;
          v24 = a6;
          v55 = a5;
          v23 = 0LL;
        }
        v25 = malloc(0x1000uLL);
        v26 = (__int64)v25;
        if ( !v25 )
        {
          *(_QWORD *)a12 = 0LL;
          v14 = -4302;
          goto LABEL_38;
        }
        *(_QWORD *)v25 = 0LL;
        if ( (unsigned int)v13 > 6 || v22 > 3 )
          goto LABEL_36;
        v27 = v57;
        if ( v13 == 4 )
          v27 = 7;
        *((_DWORD *)v25 + 17) = v27;
        if ( v27 == 1 )
        {
          v58 = 1;
          v28 = 1LL;
          v29 = getCipherMode(v13, 1, 0);
          *(_QWORD *)(v26 + 80) = v29;
          v14 = -4305;
          if ( !v29 )
            goto LABEL_37;
          v30 = (__int64)ccecb_mode;
          goto LABEL_34;
        }
        if ( v27 == 2 )
        {
          v58 = 2;
          v28 = 2LL;
          v29 = getCipherMode(v13, 2, 0);
          *(_QWORD *)(v26 + 80) = v29;
          v14 = -4305;
          if ( !v29 )
            goto LABEL_37;
          v30 = (__int64)cccbc_mode;
LABEL_34:
          *(_QWORD *)(v26 + 96) = v30;
          LODWORD(v34) = (*(int (__fastcall **)(__int64, signed __int64))v30)(v29, v28);
          v35 = malloc(v34);
          *(_QWORD *)(v26 + 104) = v35;
          v14 = -4302;
          if ( v35 )
          {
            if ( (unsigned int)(v58 - 1) <= 0xB )
            {
              v14 = -4300;
              switch ( v58 )
              {
                case 5:
                case 6:
                case 9:
                  goto LABEL_37;
                case 1:
                  v37 = 1LL;
                  v38 = getCipherMode(v13, 1, 1u);
                  *(_QWORD *)(v26 + 88) = v38;
                  v14 = -4305;
                  if ( !v38 )
                    goto LABEL_37;
                  v39 = (__int64)ccecb_mode;
                  goto LABEL_60;
                case 2:
                  v37 = 2LL;
                  v38 = getCipherMode(v13, 2, 1u);
                  *(_QWORD *)(v26 + 88) = v38;
                  v14 = -4305;
                  if ( !v38 )
                    goto LABEL_37;
                  v39 = (__int64)cccbc_mode;
                  goto LABEL_60;
                case 3:
                  v37 = 3LL;
                  v38 = getCipherMode(v13, 3, 1u);
                  *(_QWORD *)(v26 + 88) = v38;
                  v14 = -4305;
                  if ( !v38 )
                    goto LABEL_37;
                  v39 = (__int64)cccfb_mode;
                  goto LABEL_60;
                case 4:
                  v37 = 4LL;
                  v38 = getCipherMode(v13, 4, 1u);
                  *(_QWORD *)(v26 + 88) = v38;
                  v14 = -4305;
                  if ( !v38 )
                    goto LABEL_37;
                  v39 = (__int64)ccctr_mode;
                  goto LABEL_60;
                case 7:
                  v37 = 7LL;
                  v38 = getCipherMode(v13, 7, 1u);
                  *(_QWORD *)(v26 + 88) = v38;
                  v14 = -4305;
                  if ( !v38 )
                    goto LABEL_37;
                  v39 = (__int64)ccofb_mode;
                  goto LABEL_60;
                case 8:
                  v37 = 8LL;
                  v38 = getCipherMode(v13, 8, 1u);
                  *(_QWORD *)(v26 + 88) = v38;
                  v14 = -4305;
                  if ( !v38 )
                    goto LABEL_37;
                  v39 = (__int64)ccxts_mode;
                  goto LABEL_60;
                case 10:
                  v37 = 10LL;
                  v38 = getCipherMode(v13, 10, 1u);
                  *(_QWORD *)(v26 + 88) = v38;
                  v14 = -4305;
                  if ( !v38 )
                    goto LABEL_37;
                  v39 = (__int64)cccfb8_mode;
                  goto LABEL_60;
                case 11:
                  v37 = 11LL;
                  v38 = getCipherMode(v13, 11, 1u);
                  *(_QWORD *)(v26 + 88) = v38;
                  v14 = -4305;
                  if ( !v38 )
                    goto LABEL_37;
                  v39 = (__int64)ccgcm_mode;
                  goto LABEL_60;
                case 12:
                  v37 = 12LL;
                  v38 = getCipherMode(v13, 12, 1u);
                  *(_QWORD *)(v26 + 88) = v38;
                  v14 = -4305;
                  if ( !v38 )
                    goto LABEL_37;
                  v39 = (__int64)ccccm_mode;
LABEL_60:
                  *(_QWORD *)(v26 + 96) = v39;
                  LODWORD(v40) = (*(int (__fastcall **)(__int64, signed __int64))v39)(v38, v37);
                  v41 = malloc(v40);
                  *(_QWORD *)(v26 + 112) = v41;
                  v14 = -4302;
                  if ( !v41 )
                    goto LABEL_37;
                  goto LABEL_75;
                default:
                  break;
              }
            }
LABEL_36:
            v14 = -4300;
          }
LABEL_37:
          *(_QWORD *)a12 = 0LL;
          free((void *)v26);
LABEL_38:
          if ( v23 )
          {
            __bzero(v23);
            free(v23);
          }
          return (unsigned int)v14;
        }
        v58 = v27;
        if ( v27 == 8 )
        {
LABEL_32:
          v28 = 8LL;
          v29 = getCipherMode(v13, 8, 0);
          *(_QWORD *)(v26 + 80) = v29;
          v14 = -4305;
          if ( !v29 )
            goto LABEL_37;
          v30 = (__int64)ccxts_mode;
          goto LABEL_34;
        }
        if ( v22 == 3 )
        {
          v14 = -4300;
          switch ( v27 )
          {
            case 3:
              v28 = 3LL;
              v29 = getCipherMode(v13, 3, 0);
              *(_QWORD *)(v26 + 80) = v29;
              v14 = -4305;
              if ( !v29 )
                goto LABEL_37;
              v30 = (__int64)cccfb_mode;
              goto LABEL_34;
            case 8:
              goto LABEL_32;
            case 5:
            case 6:
            case 9:
              goto LABEL_37;
            case 4:
              v28 = 4LL;
              v29 = getCipherMode(v13, 4, 0);
              *(_QWORD *)(v26 + 80) = v29;
              v14 = -4305;
              if ( !v29 )
                goto LABEL_37;
              v30 = (__int64)ccctr_mode;
              goto LABEL_34;
            case 7:
              v28 = 7LL;
              v29 = getCipherMode(v13, 7, 0);
              *(_QWORD *)(v26 + 80) = v29;
              v14 = -4305;
              if ( !v29 )
                goto LABEL_37;
              v30 = (__int64)ccofb_mode;
              goto LABEL_34;
            case 10:
              v28 = 10LL;
              v29 = getCipherMode(v13, 10, 0);
              *(_QWORD *)(v26 + 80) = v29;
              v14 = -4305;
              if ( !v29 )
                goto LABEL_37;
              v30 = (__int64)cccfb8_mode;
              goto LABEL_34;
            case 11:
              v28 = 11LL;
              v29 = getCipherMode(v13, 11, 0);
              *(_QWORD *)(v26 + 80) = v29;
              v14 = -4305;
              if ( !v29 )
                goto LABEL_37;
              v30 = (__int64)ccgcm_mode;
              goto LABEL_34;
            case 12:
              v28 = 12LL;
              v29 = getCipherMode(v13, 12, 0);
              *(_QWORD *)(v26 + 80) = v29;
              v14 = -4305;
              if ( !v29 )
                goto LABEL_37;
              v30 = (__int64)ccccm_mode;
              goto LABEL_34;
            default:
              goto LABEL_36;
          }
          goto LABEL_36;
        }
        if ( v22 <= 1 )
        {
          v14 = -4300;
          switch ( v27 )
          {
            case 3:
              v31 = 3LL;
              v32 = getCipherMode(v13, 3, v22);
              *(_QWORD *)(v26 + 8LL * v22 + 80) = v32;
              v14 = -4305;
              if ( !v32 )
                goto LABEL_37;
              v33 = (__int64)cccfb_mode;
              goto LABEL_74;
            default:
              goto LABEL_37;
            case 4:
              v31 = 4LL;
              v42 = getCipherMode(v13, 4, v22);
              *(_QWORD *)(v26 + 8LL * v22 + 80) = v42;
              v14 = -4305;
              if ( !v42 )
                goto LABEL_37;
              v33 = (__int64)ccctr_mode;
              goto LABEL_74;
            case 7:
              v31 = 7LL;
              v43 = getCipherMode(v13, 7, v22);
              *(_QWORD *)(v26 + 8LL * v22 + 80) = v43;
              v14 = -4305;
              if ( !v43 )
                goto LABEL_37;
              v33 = (__int64)ccofb_mode;
              goto LABEL_74;
            case 8:
              v31 = 8LL;
              v44 = getCipherMode(v13, 8, v22);
              *(_QWORD *)(v26 + 8LL * v22 + 80) = v44;
              v14 = -4305;
              if ( !v44 )
                goto LABEL_37;
              v33 = (__int64)ccxts_mode;
              goto LABEL_74;
            case 10:
              v31 = 10LL;
              v45 = getCipherMode(v13, 10, v22);
              *(_QWORD *)(v26 + 8LL * v22 + 80) = v45;
              v14 = -4305;
              if ( !v45 )
                goto LABEL_37;
              v33 = (__int64)cccfb8_mode;
              goto LABEL_74;
            case 11:
              v31 = 11LL;
              v46 = getCipherMode(v13, 11, v22);
              *(_QWORD *)(v26 + 8LL * v22 + 80) = v46;
              v14 = -4305;
              if ( !v46 )
                goto LABEL_37;
              v33 = (__int64)ccgcm_mode;
              goto LABEL_74;
            case 12:
              v31 = 12LL;
              v47 = getCipherMode(v13, 12, v22);
              *(_QWORD *)(v26 + 8LL * v22 + 80) = v47;
              v14 = -4305;
              if ( v47 )
              {
                v33 = (__int64)ccccm_mode;
LABEL_74:
                *(_QWORD *)(v26 + 96) = v33;
                LODWORD(v48) = (*(int (__fastcall **)(_QWORD, signed __int64))v33)(
                                 *(_QWORD *)(v26 + 8LL * v22 + 80),
                                 v31);
                v49 = malloc(v48);
                *(_QWORD *)(v26 + 8LL * v22 + 104) = v49;
                v14 = -4302;
                if ( v49 )
                  goto LABEL_75;
              }
              break;
          }
          goto LABEL_37;
        }
LABEL_75:
        if ( v56 <= 9 )
        {
          v50 = v24;
          if ( !v56 )
          {
            v51 = (__int64)ccnopad_pad;
LABEL_85:
            *(_QWORD *)(v26 + 120) = v51;
            v52 = v22;
LABEL_91:
            *(_DWORD *)(v26 + 64) = v13;
            v54 = 16LL;
            if ( (unsigned int)v13 <= 6 )
              v54 = *((_DWORD *)qword_B9E0 + v13);
            *(_QWORD *)(v26 + 56) = v54;
            *(_DWORD *)(v26 + 72) = v52;
            *(_QWORD *)(v26 + 48) = 0LL;
            *(_QWORD *)(v26 + 40) = 0LL;
            ccInitCryptor(v54, a7, a8, v26, v50, v55);
            *(_QWORD *)a12 = v26;
            v14 = 0;
            goto LABEL_38;
          }
          v52 = v22;
          if ( v56 == 1 )
          {
            if ( v58 == 2 )
              v53 = (__int64)ccpkcs7_pad;
            else
              v53 = (__int64)ccpkcs7_ecb_pad;
            goto LABEL_90;
          }
          goto LABEL_88;
        }
        v50 = v24;
        if ( v56 == 10 )
        {
          v51 = (__int64)cccts1_pad;
          goto LABEL_85;
        }
        v52 = v22;
        if ( v56 == 11 )
        {
          v53 = (__int64)cccts2_pad;
        }
        else
        {
          if ( v56 != 12 )
          {
LABEL_88:
            v53 = (__int64)ccnopad_pad;
            goto LABEL_90;
          }
          v53 = (__int64)cccts3_pad;
        }
LABEL_90:
        *(_QWORD *)(v26 + 120) = v53;
        goto LABEL_91;
      }
    }
  }
  return (unsigned int)v14;
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);
// B9E0: using guessed type __int64 qword_B9E0[4];
// D170: using guessed type __int64 (__fastcall *ccecb_mode[2])();
// D1C0: using guessed type __int64 (__fastcall *cccbc_mode[2])();
// D210: using guessed type __int64 (__fastcall *cccfb_mode[2])();
// D260: using guessed type __int64 (__fastcall *cccfb8_mode[2])();
// D2B0: using guessed type __int64 (__fastcall *ccctr_mode[2])();
// D300: using guessed type __int64 (__fastcall *ccofb_mode[2])();
// D350: using guessed type __int64 (__fastcall *ccxts_mode[2])();
// D3A0: using guessed type __int64 (__fastcall *ccgcm_mode[2])();
// D3F0: using guessed type __int64 (__fastcall *ccccm_mode[2])();
// D440: using guessed type __int64 (__fastcall *ccpkcs7_pad[2])(__int64);
// D460: using guessed type __int64 (__fastcall *ccpkcs7_ecb_pad[2])(__int64);
// D480: using guessed type __int64 (__fastcall *cccts1_pad[2])(__int64);
// D4A0: using guessed type __int64 (__fastcall *cccts2_pad[2])(__int64);
// D4C0: using guessed type __int64 (__fastcall *cccts3_pad[2])(__int64);
// D4E0: using guessed type __int64 (__fastcall *ccnopad_pad[2])(__int64);

//----- (000000000000318C) ----------------------------------------------------
__int64 __fastcall CCCryptorCreateFromDataWithMode(unsigned int a1, signed int a2, int a3, signed int a4, char *a5, __int64 a6, size_t a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, unsigned __int64 a13, __int64 a14, __int64 a15)
{
  __int64 v15; // r14@1
  __int64 v16; // rbx@3
  __int64 result; // rax@5
  __int64 v18; // [sp+10h] [bp-30h]@0
  __int64 v19; // [sp+18h] [bp-28h]@0

  v15 = a12;
  if ( a12 & 7 )
    v15 = (a12 + 8) & 0xFFFFFFFFFFFFFFF8LL;
  v16 = v15 - a12 + 16;
  if ( a15 )
    *(_QWORD *)a15 = v16;
  result = 4294962995LL;
  if ( v16 <= a13 && v15 )
  {
    result = CCCryptorCreateWithMode(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, a11, v15);
    if ( !(_DWORD)result )
    {
      *(_QWORD *)a14 = v15;
      result = 0LL;
    }
  }
  return result;
}

//----- (000000000000320B) ----------------------------------------------------
__int64 __usercall ccInitCryptor@<rax>(__int64 a1@<rax>, __int64 a2@<rdx>, __int64 a3@<rcx>, __int64 a4@<rdi>, __int64 a5@<rsi>, char *a6@<r8>)
{
  char *v6; // r13@1
  __int64 v7; // r8@1
  __int64 v8; // r15@1
  __int64 v9; // r12@1
  __int64 v10; // rbx@1
  unsigned __int64 v11; // rax@1
  signed __int64 v12; // rsi@1
  unsigned __int64 v13; // rax@3
  char *v14; // r14@3
  __int64 v15; // r13@4
  unsigned int v16; // eax@5
  signed int v17; // ecx@6
  __int64 v18; // rax@7
  __int64 v19; // r10@9
  __int64 v20; // rdi@9
  __int64 v21; // rdi@10
  __int64 v22; // rax@10
  __int64 v23; // r14@10
  __int64 v24; // rdi@10
  __int64 v25; // rax@10
  __int64 v27; // [sp+10h] [bp-30h]@1

  v27 = a1;
  v6 = a6;
  v7 = a3;
  v8 = a2;
  v9 = a5;
  v10 = a4;
  v27 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v11 = *(_DWORD *)(a4 + 64);
  v12 = 16LL;
  if ( v11 <= 6 )
    v12 = *((_DWORD *)qword_B9E0 + v11);
  v13 = (v12 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  v14 = (char *)&v27 - v13;
  if ( !v6 )
  {
    v15 = a3;
    __bzero((char *)&v27 - v13);
    v7 = v15;
    v6 = v14;
  }
  v16 = *(_DWORD *)(a4 + 68);
  if ( v16 <= 8 && (v17 = 262, _bittest((const unsigned int *)&v17, v16)) || (v18 = *(_DWORD *)(a4 + 72), v18 == 3) )
  {
    v21 = *(_QWORD *)(a4 + 80);
    v22 = *(_QWORD *)(v10 + 96);
    v27 = *(_QWORD *)(v10 + 104);
    v23 = v7;
    (*(void (__fastcall **)(__int64, char *, __int64, __int64, __int64, _QWORD))(v22 + 16))(v21, v6, v9, v8, v7, 0LL);
    v24 = *(_QWORD *)(v10 + 88);
    v25 = *(_QWORD *)(v10 + 96);
    v27 = *(_QWORD *)(v10 + 112);
    (*(void (__fastcall **)(__int64, char *, __int64, __int64, __int64, _QWORD))(v25 + 16))(v24, v6, v9, v8, v23, 0LL);
  }
  else if ( (unsigned int)v18 <= 1 )
  {
    v19 = *(_QWORD *)(a4 + 96);
    v20 = *(_QWORD *)(a4 + 8 * v18 + 80);
    v27 = *(_QWORD *)(v10 + 8 * v18 + 104);
    (*(void (__fastcall **)(__int64, char *, __int64, __int64, __int64, _QWORD))(v19 + 16))(v20, v6, v9, v8, v7, 0LL);
  }
  return *(_QWORD *)__stack_chk_guard_ptr[0];
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);
// B9E0: using guessed type __int64 qword_B9E0[4];
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000003352) ----------------------------------------------------
__int64 __fastcall CCCryptorRelease(void *a1)
{
  void *v1; // r15@2
  unsigned int v2; // eax@4
  signed int v3; // ecx@5
  __int64 v4; // rax@6
  __int64 v5; // r14@8
  __int64 v6; // rbx@9
  __int64 v7; // r14@10

  if ( a1 )
  {
    v1 = *(void **)a1;
    if ( !*(_QWORD *)a1 )
      v1 = a1;
    *((_QWORD *)v1 + 4) = 0LL;
    *((_QWORD *)v1 + 3) = 0LL;
    *((_QWORD *)v1 + 2) = 0LL;
    *((_QWORD *)v1 + 1) = 0LL;
    v2 = *((_DWORD *)v1 + 17);
    if ( v2 <= 8 && (v3 = 262, _bittest((const unsigned int *)&v3, v2)) || (v4 = *((_DWORD *)v1 + 18), v4 == 3) )
    {
      v6 = 0LL;
      do
      {
        v7 = *((_QWORD *)v1 + v6 + 13);
        (**((void (__fastcall ***)(_QWORD))v1 + 12))(*((_QWORD *)v1 + v6 + 10));
        __bzero(v7);
        free(*((void **)v1 + v6++ + 13));
      }
      while ( v6 != 2 );
    }
    else if ( (unsigned int)v4 <= 1 )
    {
      v5 = *((_QWORD *)v1 + v4 + 13);
      (**((void (__fastcall ***)(_QWORD))v1 + 12))(*((_QWORD *)v1 + v4 + 10));
      __bzero(v5);
      free(*((void **)v1 + *((_DWORD *)v1 + 18) + 13));
    }
    *((_QWORD *)v1 + 8) = 0LL;
    *((_DWORD *)v1 + 18) = 0;
    *((_QWORD *)v1 + 6) = 0LL;
    *((_QWORD *)v1 + 5) = 0LL;
    *((_QWORD *)v1 + 15) = 0LL;
    *((_QWORD *)v1 + 14) = 0LL;
    *((_QWORD *)v1 + 13) = 0LL;
    *((_QWORD *)v1 + 12) = 0LL;
    *((_QWORD *)v1 + 11) = 0LL;
    *((_QWORD *)v1 + 10) = 0LL;
    *((_QWORD *)v1 + 9) = 0LL;
    *((_QWORD *)v1 + 8) = 0LL;
    *((_QWORD *)v1 + 7) = 0LL;
    *((_QWORD *)v1 + 6) = 0LL;
    *((_QWORD *)v1 + 5) = 0LL;
    *((_QWORD *)v1 + 4) = 0LL;
    *((_QWORD *)v1 + 3) = 0LL;
    *((_QWORD *)v1 + 2) = 0LL;
    *((_QWORD *)v1 + 1) = 0LL;
    *(_QWORD *)v1 = 0LL;
    free(v1);
  }
  return 0LL;
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);

//----- (00000000000034C0) ----------------------------------------------------
int __fastcall CCCryptorGetOutputLength(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  unsigned __int8 v3; // r14@1
  int result; // eax@1
  __int64 v5; // rbx@2
  __int64 v6; // rax@4

  v3 = a3;
  result = -4300;
  if ( a1 )
  {
    v5 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v5 = a1;
    LODWORD(v6) = (*(int (__fastcall **)(_QWORD))(*(_QWORD *)(v5 + 96) + 8LL))(*(_QWORD *)(v5
                                                                                         + 8LL * *(_DWORD *)(v5 + 72)
                                                                                         + 80));
    if ( v6 == 1 )
      result = a2;
    else
      result = (*(int (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64, _QWORD))(*(_QWORD *)(v5 + 120) + 16LL))(
                 *(_DWORD *)(v5 + 72) == 0LL,
                 *(_QWORD *)(v5 + 96),
                 *(_QWORD *)(v5 + 8LL * *(_DWORD *)(v5 + 72) + 80),
                 *(_QWORD *)(v5 + 40) + a2,
                 v3);
  }
  return result;
}

//----- (000000000000353D) ----------------------------------------------------
signed __int64 __fastcall CCCryptorUpdate(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r12@1
  __int64 v7; // rbx@1
  __int64 v8; // r13@1
  unsigned __int64 v9; // r14@1
  signed __int64 result; // rax@1
  __int64 v11; // r15@2
  __int64 v12; // rax@7
  unsigned __int64 v13; // rcx@7
  unsigned __int64 v14; // rax@8
  __int64 v15; // rax@12
  __int64 *v16; // rcx@13
  __int64 v17; // r8@13
  __int64 v18; // rdi@13
  unsigned __int64 v19; // rbx@15
  unsigned __int64 v20; // rax@15
  unsigned __int64 v21; // r13@15
  unsigned __int64 v22; // rax@15
  unsigned __int64 v23; // rdi@15
  unsigned __int64 v24; // rcx@17
  unsigned __int64 v25; // rdx@22
  unsigned __int64 v26; // rcx@23
  unsigned __int64 v27; // rbx@26
  unsigned __int64 v28; // rcx@27
  size_t v29; // r13@29
  unsigned __int64 v30; // rdx@29
  unsigned __int64 v31; // r13@32
  __int64 v32; // rcx@40
  unsigned __int64 v33; // rdx@40
  unsigned int v34; // er13@48
  unsigned __int64 v35; // [sp+8h] [bp-58h]@29
  unsigned __int64 v36; // [sp+10h] [bp-50h]@29
  unsigned __int64 v37; // [sp+10h] [bp-50h]@36
  __int64 v38; // [sp+20h] [bp-40h]@1
  __int64 v39; // [sp+28h] [bp-38h]@1
  __int64 v40; // [sp+30h] [bp-30h]@15

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v39 = a4;
  v38 = a5;
  result = 4294962996LL;
  if ( a1 )
  {
    v11 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v11 = a1;
    if ( a6 )
      *(_QWORD *)a6 = 0LL;
    result = 0LL;
    if ( a3 )
    {
      LODWORD(v12) = (*(int (__fastcall **)(_QWORD))(*(_QWORD *)(v11 + 96) + 8LL))(*(_QWORD *)(v11
                                                                                             + 8LL
                                                                                             * *(_DWORD *)(v11 + 72)
                                                                                             + 80));
      v13 = v9;
      if ( v12 != 1 )
      {
        LODWORD(v14) = (*(int (__fastcall **)(_QWORD, _QWORD, _QWORD, unsigned __int64, _QWORD))(*(_QWORD *)(v11 + 120)
                                                                                               + 16LL))(
                         *(_DWORD *)(v11 + 72) == 0LL,
                         *(_QWORD *)(v11 + 96),
                         *(_QWORD *)(v11 + 8LL * *(_DWORD *)(v11 + 72) + 80),
                         v9 + *(_QWORD *)(v11 + 40),
                         0LL);
        v13 = v14;
      }
      if ( v13 > v7 )
      {
        result = 4294962995LL;
        if ( v6 )
          *(_QWORD *)v6 = v13;
        return result;
      }
      LODWORD(v15) = (*(int (__fastcall **)(_QWORD))(*(_QWORD *)(v11 + 96) + 8LL))(*(_QWORD *)(v11
                                                                                             + 8LL
                                                                                             * *(_DWORD *)(v11 + 72)
                                                                                             + 80));
      if ( v15 == 1 )
      {
        v16 = &v39;
        v17 = (__int64)&v38;
        v18 = v11;
        return ccSimpleUpdate(v18, a2, v9, (__int64)v16, v17, v6);
      }
      v40 = v8;
      v19 = v9 + *(_QWORD *)(v11 + 40);
      LODWORD(v20) = (*(int (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(v11 + 120) + 24LL))(
                       *(_DWORD *)(v11 + 72) == 0LL,
                       *(_QWORD *)(v11 + 96),
                       *(_QWORD *)(v11 + 8LL * *(_DWORD *)(v11 + 72) + 80));
      v21 = v20;
      v22 = *(_DWORD *)(v11 + 64);
      v23 = 16LL;
      if ( v22 <= 6 )
        v23 = *((_DWORD *)qword_B9E0 + v22);
      v24 = v23;
      if ( v21 )
        v24 = v21;
      if ( !v21 && !*(_QWORD *)(v11 + 40) && !(v9 % v23) )
      {
        v16 = &v40;
        v17 = (__int64)&v38;
        v18 = v11;
        return ccSimpleUpdate(v18, a2, v9, (__int64)v16, v17, v6);
      }
      v25 = v19;
      if ( v19 > v21 )
      {
        v26 = v19 % v23 + v24 - v23;
        if ( !(v19 % v23) )
          v26 = v21;
        v25 = v26;
      }
      v27 = v19 - v25;
      if ( v27 )
      {
        v28 = *(_QWORD *)(v11 + 40);
        if ( v28 )
        {
          if ( v28 >= v27 )
          {
            if ( v28 != v27 )
            {
              result = 4294962992LL;
              if ( !v25 )
              {
                result = ccSimpleUpdate(v11, v11 + 8, v27, (__int64)&v40, (__int64)&v38, v6);
                if ( !(_DWORD)result )
                {
                  v34 = v21 - v27;
                  *(_QWORD *)(v11 + 40) = v34;
                  memmove((void *)(v11 + 8), (const void *)(v11 + v27 + 8), v34);
                  result = 0LL;
                }
              }
              return result;
            }
            v35 = v23;
            v31 = v25;
            result = ccSimpleUpdate(v11, v11 + 8, v27, (__int64)&v40, (__int64)&v38, v6);
            if ( (_DWORD)result )
              return result;
            v27 -= *(_QWORD *)(v11 + 40);
            *(_QWORD *)(v11 + 40) = 0LL;
            v25 = v31;
          }
          else
          {
            v36 = v25;
            v35 = v23;
            v29 = v23 - v28 % v23;
            memcpy((void *)(v11 + v28 + 8), (const void *)a2, v29);
            v30 = v29 + *(_QWORD *)(v11 + 40);
            *(_QWORD *)(v11 + 40) = v30;
            result = ccSimpleUpdate(v11, v11 + 8, v30, (__int64)&v40, (__int64)&v38, v6);
            if ( (_DWORD)result )
              return result;
            v9 -= v29;
            a2 += v29;
            v27 -= *(_QWORD *)(v11 + 40);
            *(_QWORD *)(v11 + 40) = 0LL;
            v25 = v36;
          }
          v23 = v35;
        }
        if ( v27 )
        {
          v37 = v25;
          result = 4294962992LL;
          if ( v27 % v23 )
            return result;
          result = ccSimpleUpdate(v11, a2, v27, (__int64)&v40, (__int64)&v38, v6);
          if ( (_DWORD)result )
            return result;
          a2 += v27;
          v9 -= v27;
          v25 = v37;
        }
      }
      if ( v25 )
      {
        v32 = *(_QWORD *)(v11 + 40);
        v33 = v25 - v32;
        if ( v33 )
        {
          result = 4294962992LL;
          if ( v9 != v33 )
            return result;
          memcpy((void *)(v11 + v32 + 8), (const void *)a2, v9);
          *(_QWORD *)(v11 + 40) += v9;
          v9 = 0LL;
        }
      }
      result = 4294962992LL;
      if ( !v9 )
        result = 0LL;
    }
  }
  return result;
}
// B9E0: using guessed type __int64 qword_B9E0[4];

//----- (0000000000003876) ----------------------------------------------------
signed __int64 __fastcall ccSimpleUpdate(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r13@1
  __int64 v7; // r14@1
  __int64 v8; // r15@1
  unsigned __int64 v9; // r12@1
  __int64 v10; // rbx@1
  __int64 v11; // rax@1
  void (__fastcall *v12)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // r9@2
  signed __int64 result; // rax@2
  __int64 v14; // rdi@3
  __int64 v15; // r8@3

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = a1;
  v11 = *(_QWORD *)(a1 + 96);
  if ( *(_DWORD *)(a1 + 72) )
  {
    v12 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v11 + 32);
    result = 4294962996LL;
    if ( !v12 )
      return result;
    v14 = *(_QWORD *)(a1 + 88);
    v15 = *(_QWORD *)(v10 + 112);
  }
  else
  {
    v12 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v11 + 24);
    result = 4294962996LL;
    if ( !v12 )
      return result;
    v14 = *(_QWORD *)(a1 + 80);
    v15 = *(_QWORD *)(v10 + 104);
  }
  v12(v14, a2, *(_QWORD *)a4, a3, v15);
  if ( v6 )
    *(_QWORD *)v6 += v9;
  result = 4294962995LL;
  if ( *(_QWORD *)v7 >= v9 )
  {
    *(_QWORD *)(v10 + 48) += v9;
    *(_QWORD *)v8 += v9;
    *(_QWORD *)v7 -= v9;
    result = 0LL;
  }
  return result;
}

//----- (0000000000003902) ----------------------------------------------------
__int64 __fastcall CCCryptorFinal(__int64 a1, void *a2, size_t a3, __int64 a4)
{
  __int64 v4; // r12@1
  size_t v5; // r15@1
  __int64 v6; // rcx@1
  signed int v7; // ebx@1
  __int64 v8; // r14@2
  int v9; // ebx@4
  unsigned __int64 v10; // rcx@4
  signed __int64 v11; // rax@4
  char *v12; // r13@6
  __int64 v13; // rax@8
  void (__fastcall *v14)(_QWORD, _QWORD); // rcx@9
  __int64 v15; // rax@11
  int v16; // eax@12
  size_t v17; // rdx@15
  int v18; // eax@20
  __int64 result; // rax@29
  __int64 v20; // [sp+10h] [bp-50h]@6
  void *v21; // [sp+18h] [bp-48h]@6
  __int64 *v22; // [sp+20h] [bp-40h]@6
  size_t v23; // [sp+28h] [bp-38h]@15
  __int64 v24; // [sp+30h] [bp-30h]@1

  v4 = a4;
  v5 = a3;
  v6 = __stack_chk_guard_ptr[0];
  v24 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v7 = 0;
  if ( !a1 )
    goto LABEL_29;
  v8 = *(_QWORD *)a1;
  if ( !*(_QWORD *)a1 )
    v8 = a1;
  v9 = *(_DWORD *)(v8 + 72);
  v10 = *(_DWORD *)(v8 + 64);
  v11 = 32LL;
  if ( v10 <= 6 )
    v11 = (unsigned int)(2 * *((_DWORD *)qword_B9E0 + v10));
  v21 = a2;
  v22 = &v20;
  v12 = (char *)&v20 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ( v4 )
    *(_QWORD *)v4 = 0LL;
  LODWORD(v13) = (*(int (__fastcall **)(_QWORD))(*(_QWORD *)(v8 + 96) + 8LL))(*(_QWORD *)(v8
                                                                                        + 8LL * *(_DWORD *)(v8 + 72)
                                                                                        + 80));
  if ( v13 == 1 )
  {
    v14 = *(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(v8 + 96) + 56LL);
    v7 = 0;
    if ( v14 )
      v14(*(_QWORD *)(v8 + 8LL * *(_DWORD *)(v8 + 72) + 80), *(_QWORD *)(v8 + 8LL * *(_DWORD *)(v8 + 72) + 104));
  }
  else
  {
    v15 = *(_QWORD *)(v8 + 120);
    if ( v9 )
    {
      v16 = (*(int (__fastcall **)(_QWORD, _QWORD, _QWORD, signed __int64, _QWORD, char *))(v15 + 8))(
              *(_QWORD *)(v8 + 8LL * *(_DWORD *)(v8 + 72) + 104),
              *(_QWORD *)(v8 + 96),
              *(_QWORD *)(v8 + 8LL * *(_DWORD *)(v8 + 72) + 80),
              v8 + 8,
              *(_QWORD *)(v8 + 40),
              v12);
      v7 = -4303;
      if ( !v16 )
        v7 = 0;
      if ( v16 )
        goto LABEL_28;
      v17 = v23;
      v7 = -4301;
      if ( v23 > v5 )
        goto LABEL_28;
      if ( v21 )
      {
        memcpy(v21, v12, v23);
        v17 = v23;
        if ( v4 )
          *(_QWORD *)v4 = v23;
      }
      *(_QWORD *)(v8 + 48) += v17;
    }
    else
    {
      v18 = (*(int (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64, _QWORD, char *))v15)(
              *(_QWORD *)(v8 + 8LL * *(_DWORD *)(v8 + 72) + 104),
              *(_QWORD *)(v8 + 96),
              *(_QWORD *)(v8 + 8LL * *(_DWORD *)(v8 + 72) + 80),
              v8 + 8,
              *(_QWORD *)(v8 + 40),
              v12);
      v7 = -4303;
      if ( !v18 )
        v7 = 0;
      if ( v18 )
        goto LABEL_28;
      v7 = -4301;
      if ( v23 > v5 )
        goto LABEL_28;
      if ( v21 )
      {
        memcpy(v21, v12, v23);
        if ( v4 )
          *(_QWORD *)v4 = v23;
      }
    }
    *(_QWORD *)(v8 + 40) = 0LL;
    *(_QWORD *)(v8 + 40) = 0LL;
    v7 = 0;
  }
LABEL_28:
  v6 = __stack_chk_guard_ptr[0];
LABEL_29:
  result = *(_QWORD *)v6;
  if ( *(_QWORD *)v6 == v24 )
    result = (unsigned int)v7;
  return result;
}
// B9E0: using guessed type __int64 qword_B9E0[4];
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000003AE0) ----------------------------------------------------
signed __int64 __fastcall CCCryptorReset(__int64 a1, __int64 a2)
{
  __int64 v2; // r14@1
  signed __int64 result; // rax@1
  __int64 v4; // rbx@2
  unsigned __int64 v5; // rax@4
  signed __int64 v6; // rdx@4
  int (__fastcall *v7)(_QWORD, _QWORD, _QWORD, _QWORD); // r8@7
  signed int v8; // ecx@7
  __int64 v9; // rax@8
  int v10; // eax@10
  unsigned __int64 v11; // rdx@13
  char *v12; // r15@13
  unsigned __int64 v13; // rax@13
  __int64 v14; // rsi@14
  unsigned __int64 v15; // rax@15
  signed __int64 v16; // rdx@15
  int (__fastcall *v17)(_QWORD, _QWORD, _QWORD, _QWORD); // rax@17
  __int64 v18; // rsi@18
  int v19; // eax@20
  __int64 v20; // rcx@24
  __int64 v21; // [sp+0h] [bp-30h]@13
  __int64 v22; // [sp+8h] [bp-28h]@1

  v2 = __stack_chk_guard_ptr[0];
  v22 = *(_QWORD *)__stack_chk_guard_ptr[0];
  result = 4294962996LL;
  if ( a1 )
  {
    v4 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v4 = a1;
    *(_QWORD *)(v4 + 48) = 0LL;
    *(_QWORD *)(v4 + 40) = 0LL;
    v5 = *(_DWORD *)(v4 + 64);
    v6 = 16LL;
    if ( v5 <= 6 )
      v6 = *((_DWORD *)qword_B9E0 + v5);
    if ( a2 )
    {
      v7 = *(int (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(v4 + 96) + 64LL);
      v8 = -4300;
      if ( v7 )
      {
        v9 = 0LL;
        if ( *(_DWORD *)(v4 + 72) != 3LL )
          v9 = *(_DWORD *)(v4 + 72);
        v10 = v7(*(_QWORD *)(v4 + 8 * v9 + 80), a2, v6, *(_QWORD *)(v4 + 8 * v9 + 104));
        v8 = -4302;
        if ( !v10 )
          v8 = 0;
      }
    }
    else
    {
      v11 = (v6 + 15) & 0xFFFFFFFFFFFFFFF0LL;
      v12 = (char *)&v21 - v11;
      v13 = *(_DWORD *)(v4 + 64);
      if ( v13 <= 6 )
        v14 = *((_DWORD *)qword_B9E0 + v13);
      __bzero((char *)&v21 - v11);
      v15 = *(_DWORD *)(v4 + 64);
      v16 = 16LL;
      if ( v15 <= 6 )
        v16 = *((_DWORD *)qword_B9E0 + v15);
      v17 = *(int (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(v4 + 96) + 64LL);
      v8 = -4300;
      if ( v17 )
      {
        v18 = 0LL;
        if ( *(_DWORD *)(v4 + 72) != 3LL )
          v18 = *(_DWORD *)(v4 + 72);
        v19 = v17(*(_QWORD *)(v4 + 8 * v18 + 80), v12, v16, *(_QWORD *)(v4 + 8 * v18 + 104));
        v8 = -4302;
        if ( !v19 )
          v8 = 0;
      }
    }
    result = 0LL;
    if ( v8 != -4300 )
      result = (unsigned int)v8;
  }
  v20 = *(_QWORD *)v2;
  return result;
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);
// B9E0: using guessed type __int64 qword_B9E0[4];
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000003C31) ----------------------------------------------------
signed __int64 __fastcall CCCryptorGetIV(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx@2
  __int64 v3; // rax@4
  unsigned __int64 v4; // rax@5
  signed int v5; // ecx@5
  int (__fastcall *v6)(_QWORD, _QWORD, _QWORD, _QWORD); // rax@7
  __int64 v7; // rdx@8
  int v8; // eax@10
  signed int v9; // ecx@10
  signed __int64 result; // rax@12
  int v11; // [sp+Ch] [bp-14h]@8

  if ( !a1 )
    goto LABEL_16;
  v2 = *(_QWORD *)a1;
  if ( !*(_QWORD *)a1 )
    v2 = a1;
  LODWORD(v3) = (*(int (__fastcall **)(_QWORD))(*(_QWORD *)(v2 + 96) + 8LL))(*(_QWORD *)(v2
                                                                                       + 8LL * *(_DWORD *)(v2 + 72)
                                                                                       + 80));
  if ( v3 == 1 )
    goto LABEL_16;
  v4 = *(_DWORD *)(v2 + 64);
  v5 = 16;
  if ( v4 <= 6 )
    v5 = *((_DWORD *)qword_B9E0 + v4);
  v6 = *(int (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(v2 + 96) + 72LL);
  if ( v6 )
  {
    v11 = v5;
    v7 = 0LL;
    if ( *(_DWORD *)(v2 + 72) != 3LL )
      v7 = *(_DWORD *)(v2 + 72);
    v8 = v6(*(_QWORD *)(v2 + 8 * v7 + 80), a2, &v11, *(_QWORD *)(v2 + 8 * v7 + 104));
    v9 = -4302;
    if ( !v8 )
      v9 = 0;
    result = (unsigned int)v9;
  }
  else
  {
LABEL_16:
    result = 4294962996LL;
  }
  return result;
}
// B9E0: using guessed type __int64 qword_B9E0[4];

//----- (0000000000003CC8) ----------------------------------------------------
__int64 __fastcall CCCrypt(unsigned int a1, int a2, unsigned int a3, __int64 a4, size_t a5, char *a6, __int64 a7, unsigned __int64 a8, __int64 a9, __int64 a10, __int64 a11)
{
  signed int v11; // ebx@1
  unsigned __int64 v12; // rax@2
  __int64 v14; // [sp+10h] [bp-40h]@6
  __int64 v15; // [sp+18h] [bp-38h]@5
  void *v16; // [sp+20h] [bp-30h]@1

  v16 = 0LL;
  v11 = CCCryptorCreate(a1, a2, a3, a4, a5, a6, (__int64)&v16);
  if ( !v11 )
  {
    LODWORD(v12) = CCCryptorGetOutputLength((__int64)v16, a8, 1u);
    if ( a11 )
      *(_QWORD *)a11 = v12;
    v11 = -4301;
    if ( v12 <= a10 )
    {
      v11 = CCCryptorUpdate((__int64)v16, a7, a8, a9, a10, (__int64)&v15);
      if ( !v11 )
      {
        v11 = CCCryptorFinal((__int64)v16, (void *)(v15 + a9), a10 - v15, (__int64)&v14);
        if ( a11 )
          *(_QWORD *)a11 = v15 + v14;
      }
    }
    CCCryptorRelease(v16);
  }
  return (unsigned int)v11;
}

//----- (0000000000003D96) ----------------------------------------------------
__int64 __fastcall CCCryptorEncryptDataBlock(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r15@1
  __int64 v6; // r12@1
  signed int v7; // ebx@1
  __int64 v8; // r14@2
  __int64 v9; // rax@4
  __int64 v10; // rax@5
  void (__fastcall *v11)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // rax@6
  void (__fastcall *v12)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // rax@8
  __int64 v14; // [sp+0h] [bp-30h]@2

  v5 = a4;
  v6 = a3;
  v7 = -4300;
  if ( a1 )
  {
    v14 = a5;
    v8 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v8 = a1;
    LODWORD(v9) = (*(int (__fastcall **)(_QWORD))(*(_QWORD *)(v8 + 96) + 8LL))(*(_QWORD *)(v8
                                                                                         + 8LL * *(_DWORD *)(v8 + 72)
                                                                                         + 80));
    if ( v9 != 1 )
    {
      v10 = *(_QWORD *)(v8 + 96);
      if ( a2 )
      {
        v11 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v10 + 40);
        if ( v11 )
        {
          v11(*(_QWORD *)(v8 + 80), v6, v5, v14, a2, *(_QWORD *)(v8 + 104));
LABEL_10:
          v7 = 0;
          return (unsigned int)v7;
        }
      }
      else
      {
        v12 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v10 + 24);
        if ( v12 )
        {
          v12(*(_QWORD *)(v8 + 80), v6, v14, v5, *(_QWORD *)(v8 + 104));
          goto LABEL_10;
        }
      }
    }
  }
  return (unsigned int)v7;
}

//----- (0000000000003E36) ----------------------------------------------------
__int64 __fastcall CCCryptorDecryptDataBlock(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r15@1
  __int64 v6; // r12@1
  signed int v7; // ebx@1
  __int64 v8; // r14@2
  __int64 v9; // rax@4
  __int64 v10; // rax@5
  void (__fastcall *v11)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // rax@6
  void (__fastcall *v12)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // rax@8
  __int64 v14; // [sp+0h] [bp-30h]@2

  v5 = a4;
  v6 = a3;
  v7 = -4300;
  if ( a1 )
  {
    v14 = a5;
    v8 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v8 = a1;
    LODWORD(v9) = (*(int (__fastcall **)(_QWORD))(*(_QWORD *)(v8 + 96) + 8LL))(*(_QWORD *)(v8
                                                                                         + 8LL * *(_DWORD *)(v8 + 72)
                                                                                         + 80));
    if ( v9 != 1 )
    {
      v10 = *(_QWORD *)(v8 + 96);
      if ( a2 )
      {
        v11 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v10 + 48);
        if ( v11 )
        {
          v11(*(_QWORD *)(v8 + 88), v6, v5, v14, a2, *(_QWORD *)(v8 + 112));
LABEL_10:
          v7 = 0;
          return (unsigned int)v7;
        }
      }
      else
      {
        v12 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v10 + 32);
        if ( v12 )
        {
          v12(*(_QWORD *)(v8 + 88), v6, v14, v5, *(_QWORD *)(v8 + 112));
          goto LABEL_10;
        }
      }
    }
  }
  return (unsigned int)v7;
}

//----- (0000000000003ED6) ----------------------------------------------------
signed __int64 __fastcall CCCryptorAddParameter(__int64 a1, int a2, const void *a3, size_t a4)
{
  size_t v4; // rbx@1
  const void *v5; // r14@1
  signed __int64 result; // rax@1
  __int64 v7; // rcx@2
  int v8; // edx@5
  __int64 v9; // rdi@6
  int v10; // edx@7
  __int64 v11; // rdx@8
  __int64 v12; // r13@8
  __int64 v13; // r10@11
  __int64 v14; // ST00_8@11
  size_t v15; // r9@11
  __int64 v16; // rbx@11

  v4 = a4;
  v5 = a3;
  result = 4294962996LL;
  if ( a1 )
  {
    v7 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v7 = a1;
    switch ( a2 )
    {
      case 0:
        v8 = *(_DWORD *)(v7 + 68);
        if ( v8 == 12 )
        {
          v9 = *(_QWORD *)(v7 + 8LL * *(_DWORD *)(v7 + 72) + 104);
          *(_QWORD *)(v9 + 16) = v4;
          memcpy((void *)(v9 + 32), v5, v4);
          goto LABEL_20;
        }
        result = 4294962991LL;
        if ( v8 == 11 )
        {
          ccmode_gcm_set_iv(*(_QWORD *)(v7 + 8LL * *(_DWORD *)(v7 + 72) + 104), v4, v5);
          goto LABEL_20;
        }
        break;
      case 1:
        v10 = *(_DWORD *)(v7 + 68);
        if ( v10 == 12 )
        {
          v11 = *(_DWORD *)(v7 + 72);
          v12 = *(_QWORD *)(v7 + 8 * v11 + 104);
          if ( *(_QWORD *)(v12 + 8) != -1LL && *(_QWORD *)(v12 + 16) != -1LL && *(_QWORD *)v12 != -1LL )
          {
            v13 = *(_QWORD *)(v7 + 8 * v11 + 80);
            *(_QWORD *)(v12 + 24) = v4;
            v14 = *(_QWORD *)v12;
            v15 = v4;
            v16 = v13;
            (*(void (__fastcall **)(signed __int64, signed __int64, _QWORD, signed __int64, _QWORD, size_t))(v13 + 32))(
              v12 + 160,
              v12 + 64,
              *(_QWORD *)(v12 + 16),
              v12 + 32,
              *(_QWORD *)(v12 + 8),
              v15);
            (*(void (__fastcall **)(signed __int64, signed __int64, _QWORD, const void *))(v16 + 40))(
              v12 + 160,
              v12 + 64,
              *(_QWORD *)(v12 + 24),
              v5);
            goto LABEL_20;
          }
        }
        else
        {
          result = 4294962991LL;
          if ( v10 == 11 )
          {
            ccmode_gcm_gmac(*(_QWORD *)(v7 + 8LL * *(_DWORD *)(v7 + 72) + 104), v4, v5);
            goto LABEL_20;
          }
        }
        break;
      case 2:
        result = 4294962991LL;
        if ( *(_DWORD *)(v7 + 68) == 12 )
        {
          *(_QWORD *)(*(_QWORD *)(v7 + 8LL * *(_DWORD *)(v7 + 72) + 104) + 8LL) = v4;
          goto LABEL_20;
        }
        break;
      case 3:
        result = 4294962991LL;
        if ( *(_DWORD *)(v7 + 68) == 12 )
        {
          **(_QWORD **)(v7 + 8LL * *(_DWORD *)(v7 + 72) + 104) = v4;
LABEL_20:
          result = 0LL;
        }
        break;
      default:
        return result;
    }
  }
  return result;
}
// ABBC: using guessed type int __fastcall ccmode_gcm_gmac(_QWORD, _QWORD, _QWORD);
// ABC8: using guessed type int __fastcall ccmode_gcm_set_iv(_QWORD, _QWORD, _QWORD);

//----- (0000000000004058) ----------------------------------------------------
signed __int64 __fastcall CCCryptorGetParameter(__int64 a1, int a2, void *a3, __int64 a4)
{
  __int64 v4; // rbx@1
  signed __int64 result; // rax@1
  __int64 v6; // rcx@2
  __int64 v7; // r14@7

  v4 = a4;
  result = 4294962996LL;
  if ( a1 )
  {
    v6 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v6 = a1;
    if ( v6 && a2 == 4 )
    {
      result = 4294962991LL;
      if ( *(_DWORD *)(v6 + 68) == 12 )
      {
        v7 = *(_QWORD *)(v6 + 8LL * *(_DWORD *)(v6 + 72) + 104);
        memcpy(a3, (const void *)(v7 + 48), *(_QWORD *)(v7 + 8));
        *(_QWORD *)v4 = *(_QWORD *)(v7 + 8);
        result = 0LL;
      }
    }
  }
  return result;
}

//----- (00000000000040B4) ----------------------------------------------------
void kCCDHRFC2409Group2_storage()
{
  ;
}

//----- (00000000000040BA) ----------------------------------------------------
void kCCDHRFC3526Group5_storage()
{
  ;
}

//----- (00000000000040C0) ----------------------------------------------------
void *__fastcall CCDHCreate(void (*a1)())
{
  void *v1; // rbx@1
  void *result; // rax@1
  void *v3; // r14@3
  __int64 v4; // rax@4
  void *v5; // r15@5
  _QWORD *v6; // r12@6
  void *v7; // rax@6

  v1 = a1;
  result = 0LL;
  if ( a1 && a1 != kCCDHRFC2409Group2_storage )
  {
    v3 = 0LL;
    if ( a1 == kCCDHRFC3526Group5_storage )
    {
      v3 = malloc(0x10uLL);
      LODWORD(v4) = ccdh_gp_rfc3526group05(16LL);
      *(_QWORD *)v3 = v4;
      *((_QWORD *)v3 + 1) = 1LL;
      v1 = v3;
    }
    v5 = malloc(0x10uLL);
    if ( v5 && (v6 = *(_QWORD **)v1, v7 = malloc(32LL * **(_QWORD **)v1 | 0x10), (*((_QWORD *)v5 + 1) = v7) != 0LL) )
    {
      *(_QWORD *)v7 = v6;
      *(_QWORD *)v5 = v1;
      result = v5;
    }
    else
    {
      if ( v3 )
        free(v3);
      result = 0LL;
      if ( v5 )
      {
        free(v5);
        result = 0LL;
      }
    }
  }
  return result;
}
// AB08: using guessed type int __fastcall ccdh_gp_rfc3526group05(_QWORD);

//----- (0000000000004179) ----------------------------------------------------
void __fastcall CCDHRelease(void *a1)
{
  void *v1; // rbx@1
  void *v2; // rdi@2

  v1 = a1;
  if ( a1 )
  {
    v2 = (void *)*((_QWORD *)a1 + 1);
    if ( v2 )
      free(v2);
    free(v1);
  }
}

//----- (00000000000041AA) ----------------------------------------------------
signed __int64 __usercall CCDHGenerateKey@<rax>(__int64 a1@<rdx>, __int64 a2@<rdi>, __int64 a3@<rsi>, __int64 a4@<r8>, __int64 a5@<r9>, __int128 a6@<xmm0>, __int128 a7@<xmm1>, __int128 a8@<xmm2>, __int128 a9@<xmm3>, __int128 a10@<xmm4>, __int128 a11@<xmm5>, __int128 a12@<xmm6>, __int128 a13@<xmm7>)
{
  __int64 v13; // r15@1
  signed __int64 result; // rax@1
  __int64 v15; // r12@4
  __int64 v16; // rax@4
  int v17; // ecx@4
  signed __int64 v18; // rcx@5
  bool v19; // cf@5
  bool v20; // zf@5

  v13 = a1;
  result = 4294962996LL;
  if ( a2 )
  {
    if ( a3 )
    {
      if ( a1 )
      {
        v15 = *(_QWORD *)a2;
        v16 = ccDRBGGetRngState(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
        v17 = ccdh_generate_key(*(_QWORD *)v15, v16, *(_QWORD *)(a2 + 8));
        result = 0xFFFFFFFFLL;
        if ( !v17 )
        {
          v18 = 8LL * ***(_QWORD ***)(a2 + 8);
          v19 = (unsigned __int64)v18 < *(_QWORD *)v13;
          v20 = v18 == *(_QWORD *)v13;
          *(_QWORD *)v13 = v18;
          if ( v19 || v20 )
          {
            ccdh_export_pub(*(_QWORD *)(a2 + 8), a3);
            result = 0LL;
          }
        }
      }
    }
  }
  return result;
}
// AAFC: using guessed type int __fastcall ccdh_export_pub(_QWORD, _QWORD);
// AB02: using guessed type int __fastcall ccdh_generate_key(_QWORD, _QWORD, _QWORD);

//----- (0000000000004222) ----------------------------------------------------
signed __int64 __fastcall CCDHComputeKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r12@1
  __int64 v6; // r13@1
  __int64 v7; // rsi@1
  signed __int64 result; // rax@1
  char *v9; // r14@5
  __int64 v10; // r15@5
  char *v11; // rbx@5
  int v12; // eax@5
  unsigned __int64 v13; // rax@7
  unsigned __int64 v14; // r14@7
  bool v15; // cf@7
  bool v16; // zf@7
  unsigned __int64 v17; // rax@8
  unsigned __int64 v18; // r12@8
  __int64 v19; // r13@10
  __int64 v20; // rcx@12
  __int64 v21; // [sp+0h] [bp-50h]@5
  __int64 v22; // [sp+8h] [bp-48h]@5
  __int64 *v23; // [sp+10h] [bp-40h]@5
  __int64 v24; // [sp+18h] [bp-38h]@5
  __int64 v25; // [sp+20h] [bp-30h]@1

  v5 = a5;
  v6 = a2;
  v7 = __stack_chk_guard_ptr[0];
  v25 = *(_QWORD *)__stack_chk_guard_ptr[0];
  result = 4294962996LL;
  if ( a1 && v6 && a3 && a5 )
  {
    v22 = a1;
    v23 = &v21;
    v9 = (char *)&v21 - ((24LL * ***(_QWORD ***)a5 + 31) & 0xFFFFFFFFFFFFFFF0LL);
    v10 = ***(_QWORD ***)(a5 + 8);
    v11 = (char *)&v21 - ((8 * v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v12 = ccdh_import_pub(
            **(_QWORD **)a5,
            a4,
            a3,
            (char *)&v21 - ((24LL * ***(_QWORD ***)a5 + 31) & 0xFFFFFFFFFFFFFFF0LL));
    v24 = 0xFFFFFFFFLL;
    if ( !v12 && !ccdh_compute_key(*(_QWORD *)(v5 + 8), v9, v11) )
    {
      LODWORD(v13) = ccn_write_uint_size(v10, v11);
      v14 = v13;
      v15 = v13 < *(_QWORD *)v6;
      v16 = v13 == *(_QWORD *)v6;
      *(_QWORD *)v6 = v13;
      if ( v15 || v16 )
      {
        LODWORD(v17) = ccn_write_uint_size(v10, v11);
        v18 = v14 - v17;
        if ( v14 <= v17 )
          v18 = 0LL;
        v24 = 0LL;
        v19 = v22;
        __bzero(v22);
        ccn_write_uint(v10, v11, v14 - v18, v19 + v18);
      }
    }
    v7 = __stack_chk_guard_ptr[0];
    result = v24;
  }
  v20 = *(_QWORD *)v7;
  return result;
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);
// AAF6: using guessed type int __fastcall ccdh_compute_key(_QWORD, _QWORD, _QWORD);
// AB0E: using guessed type int __fastcall ccdh_import_pub(_QWORD, _QWORD, _QWORD, _QWORD);
// ABE6: using guessed type int __fastcall ccn_write_uint(_QWORD, _QWORD, _QWORD, _QWORD);
// ABEC: using guessed type int __fastcall ccn_write_uint_size(_QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (000000000000437B) ----------------------------------------------------
void *__fastcall CCDHParametersCreateFromData(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r14@1
  __int64 v6; // rbx@1
  __int64 v7; // rcx@1
  void *result; // rax@1
  unsigned __int64 v9; // rsi@3
  unsigned __int64 v10; // rbx@3
  unsigned __int64 v11; // rax@5
  char *v12; // r12@5
  char *v13; // r13@5
  void *v14; // r15@5
  size_t v15; // rdi@6
  void *v16; // rax@6
  void *v17; // r14@6
  int v18; // ecx@7
  __int64 v19; // rcx@13
  __int64 v20; // [sp+0h] [bp-40h]@3
  __int64 *v21; // [sp+8h] [bp-38h]@3
  __int64 v22; // [sp+10h] [bp-30h]@1

  v5 = a5;
  v6 = a4;
  v7 = __stack_chk_guard_ptr[0];
  v22 = *(_QWORD *)__stack_chk_guard_ptr[0];
  result = 0LL;
  if ( a1 && a3 )
  {
    v21 = &v20;
    v9 = (unsigned __int64)(a2 + 7) >> 3;
    v10 = (unsigned __int64)(v6 + 7) >> 3;
    if ( v9 > v10 )
      v10 = v9;
    v11 = (8 * v10 + 15) & 0xFFFFFFFFFFFFFFF0LL;
    v12 = (char *)&v20 - v11;
    v13 = (char *)&v20 - v11;
    v14 = malloc(0x10uLL);
    result = 0LL;
    if ( !v14 )
      goto LABEL_12;
    v20 = v5;
    v15 = 3 * v10 + 32;
    *((_QWORD *)v14 + 1) = v15;
    v16 = malloc(v15);
    v17 = v16;
    *(_QWORD *)v14 = v16;
    if ( v16 )
    {
      v18 = ccdh_init_gp(v16, v10, v12, v13, v20);
      result = 0LL;
      if ( !v18 )
        result = v14;
      if ( !v18 )
        goto LABEL_12;
      free(v17);
    }
    free(v14);
    result = 0LL;
LABEL_12:
    v7 = __stack_chk_guard_ptr[0];
  }
  v19 = *(_QWORD *)v7;
  return result;
}
// AB14: using guessed type int __fastcall ccdh_init_gp(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000004479) ----------------------------------------------------
void __fastcall CCDHParametersRelease(void *a1)
{
  if ( a1 && a1 != kCCDHRFC2409Group2_storage && a1 != kCCDHRFC3526Group5_storage )
  {
    if ( *((_QWORD *)a1 + 1) )
      free(*(void **)a1);
    free(a1);
  }
}

//----- (00000000000044C3) ----------------------------------------------------
__int64 CCDHParametersCreateFromPKCS3()
{
  return 0LL;
}

//----- (00000000000044CB) ----------------------------------------------------
__int64 CCDHParametersPKCS3EncodeLength()
{
  return 0LL;
}

//----- (00000000000044D3) ----------------------------------------------------
__int64 CCDHParametersPKCS3Encode()
{
  return 0LL;
}

//----- (00000000000044DB) ----------------------------------------------------
__int64 __fastcall CCDigestGetDigestInfo(unsigned int a1)
{
  __int64 v1; // rbx@2
  __int64 v3; // rax@5
  __int64 v4; // [sp+8h] [bp-38h]@3
  int v5; // [sp+10h] [bp-30h]@3
  int v6; // [sp+14h] [bp-2Ch]@3
  __int64 (__fastcall *v7)(__int64); // [sp+18h] [bp-28h]@3
  __int64 *v8; // [sp+20h] [bp-20h]@3
  __int64 v9; // [sp+28h] [bp-18h]@3

  if ( *(_QWORD *)(_os_alloc_once_table_ptr[0] + 96) == -1LL )
  {
    v1 = *(_QWORD *)(_os_alloc_once_table_ptr[0] + 104);
  }
  else
  {
    LODWORD(v3) = _os_alloc_once(_os_alloc_once_table_ptr[0] + 96, 3376LL, 0LL);
    v1 = v3;
  }
  v4 = _NSConcreteStackBlock_ptr[0];
  v5 = 0x40000000;
  v6 = 0;
  v7 = __CCDigestGetDigestInfo_block_invoke;
  v8 = &__block_descriptor_tmp_3;
  v9 = v1;
  if ( *(_QWORD *)(v1 + 2112) != -1LL )
    dispatch_once(v1 + 2112, &v4);
  return *(_QWORD *)(*(_QWORD *)(v1 + 2120) + 8LL * a1);
}
// AA12: using guessed type int __fastcall _os_alloc_once(_QWORD, _QWORD, _QWORD);
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// C020: using guessed type __int64 _os_alloc_once_table_ptr[174];
// CC80: using guessed type __int64 __block_descriptor_tmp_3;

//----- (0000000000004576) ----------------------------------------------------
__int64 __fastcall __CCDigestGetDigestInfo_block_invoke(__int64 a1)
{
  __int64 v1; // rax@1
  __int64 v2; // rax@1
  __int64 v3; // rax@1
  __int64 v4; // rax@1
  __int64 v5; // rax@1
  __int64 v6; // rax@1
  __int64 result; // rax@1

  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) = calloc(0x14uLL, 8uLL);
  **(_QWORD **)(*(_QWORD *)(a1 + 32) + 2120LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 8LL) = ccmd2_ltc_di_ptr[0];
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 16LL) = ccmd4_ltc_di_ptr[0];
  LODWORD(v1) = ccmd5_di(20LL, 8LL);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 24LL) = v1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 32LL) = ccrmd128_ltc_di_ptr[0];
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 40LL) = ccrmd160_ltc_di_ptr[0];
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 48LL) = ccrmd256_ltc_di_ptr[0];
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 56LL) = ccrmd320_ltc_di_ptr[0];
  LODWORD(v2) = ccsha1_di(20LL);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 64LL) = v2;
  LODWORD(v3) = ccsha224_di(20LL);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 72LL) = v3;
  LODWORD(v4) = ccsha256_di(20LL);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 80LL) = v4;
  LODWORD(v5) = ccsha384_di(20LL);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 88LL) = v5;
  LODWORD(v6) = ccsha512_di(20LL);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 96LL) = v6;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 104LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 112LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 120LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 128LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 136LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL) + 144LL) = 0LL;
  result = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 2120LL);
  *(_QWORD *)(result + 152) = 0LL;
  return result;
}
// ABA4: using guessed type int __fastcall ccmd5_di(_QWORD, _QWORD);
// ACCA: using guessed type int __cdecl ccsha1_di(_QWORD);
// ACD0: using guessed type int __cdecl ccsha224_di(_QWORD);
// ACD6: using guessed type int __cdecl ccsha256_di(_QWORD);
// ACDC: using guessed type int __cdecl ccsha384_di(_QWORD);
// ACE2: using guessed type int __cdecl ccsha512_di(_QWORD);
// C030: using guessed type __int64 ccmd2_ltc_di_ptr[172];
// C038: using guessed type __int64 ccmd4_ltc_di_ptr[171];
// C048: using guessed type __int64 ccrmd128_ltc_di_ptr[169];
// C050: using guessed type __int64 ccrmd160_ltc_di_ptr[168];
// C058: using guessed type __int64 ccrmd256_ltc_di_ptr[167];
// C060: using guessed type __int64 ccrmd320_ltc_di_ptr[166];

//----- (000000000000473F) ----------------------------------------------------
signed __int64 __fastcall CCDigestInit(unsigned int a1, __int64 a2)
{
  signed __int64 result; // rax@1
  __int64 v3; // rax@3
  __int64 v4; // rcx@3

  result = 4294962996LL;
  if ( a1 - 1 <= 0x12 && a2 )
  {
    v3 = CCDigestGetDigestInfo(a1);
    v4 = v3;
    *(_QWORD *)a2 = v3;
    result = 4294962991LL;
    if ( v4 )
    {
      ccdigest_init(v4, a2 + 8);
      result = 0LL;
    }
  }
  return result;
}
// AB20: using guessed type int __fastcall ccdigest_init(_QWORD, _QWORD);

//----- (0000000000004787) ----------------------------------------------------
signed __int64 __fastcall CCDigestUpdate(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx@1
  signed __int64 result; // rax@1
  __int64 v5; // rdi@4

  v3 = a1;
  result = 4294962996LL;
  if ( a1 )
  {
    if ( !a3 )
      return 0LL;
    if ( a2 )
    {
      v5 = *(_QWORD *)a1;
      result = 4294962991LL;
      if ( *(_QWORD *)v3 )
      {
        ccdigest_update(v5, v3 + 8, a3, a2);
        return 0LL;
      }
    }
  }
  return result;
}
// AB26: using guessed type int __fastcall ccdigest_update(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000047C5) ----------------------------------------------------
signed __int64 __fastcall CCDigestFinal(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx@1
  signed __int64 result; // rax@1
  __int64 v4; // rdi@3

  v2 = a1;
  result = 4294962996LL;
  if ( a1 && a2 )
  {
    v4 = *(_QWORD *)a1;
    result = 4294962991LL;
    if ( *(_QWORD *)v2 )
    {
      (*(void (__fastcall **)(__int64, signed __int64, __int64))(v4 + 56))(v4, v2 + 8, a2);
      result = 0LL;
    }
  }
  return result;
}

//----- (00000000000047F9) ----------------------------------------------------
__int64 __fastcall CCDigest(unsigned int a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r14@1
  __int64 v5; // r15@1
  __int64 v6; // rax@1
  signed int v7; // ecx@1

  v4 = a4;
  v5 = a3;
  v6 = CCDigestGetDigestInfo(a1);
  v7 = -4305;
  if ( v6 )
  {
    ccdigest(v6, v5, a2, v4);
    v7 = 0;
  }
  return (unsigned int)v7;
}
// AB1A: using guessed type int __fastcall ccdigest(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000483B) ----------------------------------------------------
signed __int64 __fastcall CCDigestGetBlockSize(unsigned int a1)
{
  __int64 v1; // rcx@1
  signed __int64 result; // rax@1

  v1 = CCDigestGetDigestInfo(a1);
  result = -4305LL;
  if ( v1 )
    result = *(_QWORD *)(v1 + 16);
  return result;
}

//----- (0000000000004859) ----------------------------------------------------
signed __int64 __fastcall CCDigestGetOutputSize(unsigned int a1)
{
  __int64 v1; // rcx@1
  signed __int64 result; // rax@1

  v1 = CCDigestGetDigestInfo(a1);
  result = -4305LL;
  if ( v1 )
    result = *(_QWORD *)v1;
  return result;
}

//----- (0000000000004876) ----------------------------------------------------
signed __int64 __fastcall CCDigestGetBlockSizeFromRef(__int64 a1)
{
  signed __int64 result; // rax@1

  result = -4305LL;
  if ( *(_QWORD *)a1 )
    result = *(_QWORD *)(*(_QWORD *)a1 + 16LL);
  return result;
}

//----- (000000000000488F) ----------------------------------------------------
signed __int64 __fastcall CCDigestBlockSize(__int64 a1)
{
  signed __int64 result; // rax@1

  result = -4305LL;
  if ( *(_QWORD *)a1 )
    result = *(_QWORD *)(*(_QWORD *)a1 + 16LL);
  return result;
}

//----- (00000000000048A8) ----------------------------------------------------
signed __int64 __fastcall CCDigestOutputSize(signed __int64 **a1)
{
  signed __int64 result; // rax@1

  result = -4305LL;
  if ( *a1 )
    result = **a1;
  return result;
}

//----- (00000000000048C0) ----------------------------------------------------
signed __int64 __fastcall CCDigestGetOutputSizeFromRef(signed __int64 **a1)
{
  signed __int64 result; // rax@1

  result = -4305LL;
  if ( *a1 )
    result = **a1;
  return result;
}

//----- (00000000000048D8) ----------------------------------------------------
void *__fastcall CCDigestCreate(unsigned int a1)
{
  void *v1; // rbx@1
  void *result; // rax@1
  bool v3; // zf@2

  v1 = malloc(0x408uLL);
  result = 0LL;
  if ( v1 )
  {
    v3 = (unsigned int)CCDigestInit(a1, (__int64)v1) == 0;
    result = v1;
    if ( !v3 )
    {
      free(v1);
      result = 0LL;
    }
  }
  return result;
}

//----- (0000000000004917) ----------------------------------------------------
__int64 __fastcall CCDigestOID(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 32LL);
}

//----- (0000000000004924) ----------------------------------------------------
__int64 __fastcall CCDigestOIDLen(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 24LL);
}

//----- (0000000000004931) ----------------------------------------------------
void *__fastcall CCDigestCreateByOID(void *a1, size_t a2)
{
  unsigned int v2; // ebx@1
  __int64 v3; // rax@2

  v2 = 1;
  while ( 1 )
  {
    v3 = CCDigestGetDigestInfo(v2);
    if ( v3 )
    {
      if ( *(_QWORD *)(v3 + 24) == a2 && !memcmp(a1, *(const void **)(v3 + 32), a2) )
        break;
    }
    ++v2;
    if ( v2 >= 0x14 )
      return 0LL;
  }
  return CCDigestCreate(v2);
}

//----- (0000000000004990) ----------------------------------------------------
int __fastcall CCDigestReset(__int64 a1)
{
  __int64 v1; // rax@1
  __int64 v2; // rdi@1

  v1 = a1;
  v2 = *(_QWORD *)a1;
  if ( v2 )
    LODWORD(v1) = ccdigest_init(v2, v1 + 8);
  return v1;
}
// AB20: using guessed type int __fastcall ccdigest_init(_QWORD, _QWORD);

//----- (00000000000049AE) ----------------------------------------------------
void __fastcall CCDigestDestroy(void *a1)
{
  if ( a1 )
  {
    __bzero(a1);
    free(a1);
  }
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);

//----- (00000000000049DE) ----------------------------------------------------
__int64 __fastcall CC_MD2(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rbx@1

  v3 = a3;
  CCDigest(1u, a1, a2, a3);
  return v3;
}

//----- (0000000000004A06) ----------------------------------------------------
__int64 __fastcall CC_MD4_Init(void *a1)
{
  __int64 v1; // r12@1
  __int64 v2; // rax@1
  __int64 v3; // r15@1
  char *v4; // rbx@1
  __int64 result; // rax@1
  __int64 v6; // [sp+0h] [bp-30h]@1
  __int64 v7; // [sp+8h] [bp-28h]@1

  v1 = __stack_chk_guard_ptr[0];
  v7 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v2 = CCDigestGetDigestInfo(2u);
  v3 = v2;
  v4 = (char *)&v6
     - ((((*(_QWORD *)(v2 + 8) + *(_QWORD *)(v2 + 16) + 19LL) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  ccdigest_init(v2, v4);
  memcpy(a1, v4 + 8, *(_QWORD *)(v3 + 8));
  memcpy((char *)a1 + 24, &v4[*(_QWORD *)(v3 + 8) + 8], *(_QWORD *)(v3 + 16));
  *((_QWORD *)a1 + 2) = *(_QWORD *)v4;
  *((_DWORD *)a1 + 22) = *(_DWORD *)(&v4[*(_QWORD *)(v3 + 8) + 8] + *(_QWORD *)(v3 + 16));
  result = *(_QWORD *)v1;
  if ( *(_QWORD *)v1 == v7 )
    result = 1LL;
  return result;
}
// AB20: using guessed type int __fastcall ccdigest_init(_QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000004ABF) ----------------------------------------------------
__int64 __fastcall CC_MD4_Update(void *a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rax@1
  __int64 v4; // r15@1
  size_t v5; // rdx@1
  char *v6; // rbx@1
  __int64 result; // rax@1
  __int64 v8; // [sp+0h] [bp-40h]@1
  unsigned int v9; // [sp+4h] [bp-3Ch]@1
  __int64 v10; // [sp+8h] [bp-38h]@1
  __int64 v11; // [sp+10h] [bp-30h]@1

  v9 = a3;
  v10 = a2;
  v11 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v3 = CCDigestGetDigestInfo(2u);
  v4 = v3;
  v5 = *(_QWORD *)(v3 + 8);
  v6 = (char *)&v8 - ((((v5 + *(_QWORD *)(v3 + 16) + 19) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  memcpy(v6 + 8, a1, v5);
  memcpy(&v6[*(_QWORD *)(v4 + 8) + 8], (char *)a1 + 24, *(_QWORD *)(v4 + 16));
  *(_QWORD *)v6 = *((_QWORD *)a1 + 2);
  *(_DWORD *)(&v6[*(_QWORD *)(v4 + 8) + 8] + *(_QWORD *)(v4 + 16)) = *((_DWORD *)a1 + 22);
  ccdigest_update(v4, v6, v9, v10);
  memcpy(a1, v6 + 8, *(_QWORD *)(v4 + 8));
  memcpy((char *)a1 + 24, &v6[*(_QWORD *)(v4 + 8) + 8], *(_QWORD *)(v4 + 16));
  *((_QWORD *)a1 + 2) = *(_QWORD *)v6;
  *((_DWORD *)a1 + 22) = *(_DWORD *)(&v6[*(_QWORD *)(v4 + 8) + 8] + *(_QWORD *)(v4 + 16));
  result = *(_QWORD *)__stack_chk_guard_ptr[0];
  if ( *(_QWORD *)__stack_chk_guard_ptr[0] == v11 )
    result = 1LL;
  return result;
}
// AB26: using guessed type int __fastcall ccdigest_update(_QWORD, _QWORD, _QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000004BCC) ----------------------------------------------------
signed __int64 __fastcall CC_MD4_Final(__int64 a1, __int64 a2)
{
  __int64 v2; // rax@1
  __int64 v3; // rbx@1
  size_t v4; // rdx@1
  char *v5; // r15@1
  signed __int64 result; // rax@1
  __int64 v7; // [sp+0h] [bp-40h]@1
  __int64 v8; // [sp+8h] [bp-38h]@1
  __int64 v9; // [sp+10h] [bp-30h]@1

  v8 = a1;
  v9 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v2 = CCDigestGetDigestInfo(2u);
  v3 = v2;
  v4 = *(_QWORD *)(v2 + 8);
  v5 = (char *)&v7 - ((((v4 + *(_QWORD *)(v2 + 16) + 19) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  memcpy(v5 + 8, (const void *)a2, v4);
  memcpy(&v5[*(_QWORD *)(v3 + 8) + 8], (const void *)(a2 + 24), *(_QWORD *)(v3 + 16));
  *(_QWORD *)v5 = *(_QWORD *)(a2 + 16);
  *(_DWORD *)(&v5[*(_QWORD *)(v3 + 8) + 8] + *(_QWORD *)(v3 + 16)) = *(_DWORD *)(a2 + 88);
  (*(void (__fastcall **)(__int64, char *, __int64))(v3 + 56))(v3, v5, v8);
  memcpy((void *)a2, v5 + 8, *(_QWORD *)(v3 + 8));
  memcpy((void *)(a2 + 24), &v5[*(_QWORD *)(v3 + 8) + 8], *(_QWORD *)(v3 + 16));
  *(_QWORD *)(a2 + 16) = *(_QWORD *)v5;
  *(_DWORD *)(a2 + 88) = *(_DWORD *)(&v5[*(_QWORD *)(v3 + 8) + 8] + *(_QWORD *)(v3 + 16));
  result = *(_QWORD *)__stack_chk_guard_ptr[0];
  if ( *(_QWORD *)__stack_chk_guard_ptr[0] == v9 )
    result = 1LL;
  return result;
}
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000004CD3) ----------------------------------------------------
__int64 __fastcall CC_MD4(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rbx@1

  v3 = a3;
  CCDigest(2u, a1, a2, a3);
  return v3;
}

//----- (0000000000004CFB) ----------------------------------------------------
__int64 __fastcall CC_MD5_Init(void *a1)
{
  __int64 v1; // r12@1
  __int64 v2; // rax@1
  __int64 v3; // r15@1
  char *v4; // rbx@1
  __int64 result; // rax@1
  __int64 v6; // [sp+0h] [bp-30h]@1
  __int64 v7; // [sp+8h] [bp-28h]@1

  v1 = __stack_chk_guard_ptr[0];
  v7 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v2 = CCDigestGetDigestInfo(3u);
  v3 = v2;
  v4 = (char *)&v6
     - ((((*(_QWORD *)(v2 + 8) + *(_QWORD *)(v2 + 16) + 19LL) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  ccdigest_init(v2, v4);
  memcpy(a1, v4 + 8, *(_QWORD *)(v3 + 8));
  memcpy((char *)a1 + 24, &v4[*(_QWORD *)(v3 + 8) + 8], *(_QWORD *)(v3 + 16));
  *((_QWORD *)a1 + 2) = *(_QWORD *)v4;
  *((_DWORD *)a1 + 22) = *(_DWORD *)(&v4[*(_QWORD *)(v3 + 8) + 8] + *(_QWORD *)(v3 + 16));
  result = *(_QWORD *)v1;
  if ( *(_QWORD *)v1 == v7 )
    result = 1LL;
  return result;
}
// AB20: using guessed type int __fastcall ccdigest_init(_QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000004DB4) ----------------------------------------------------
__int64 __fastcall CC_MD5_Update(void *a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rax@1
  __int64 v4; // r15@1
  size_t v5; // rdx@1
  char *v6; // rbx@1
  __int64 result; // rax@1
  __int64 v8; // [sp+0h] [bp-40h]@1
  unsigned int v9; // [sp+4h] [bp-3Ch]@1
  __int64 v10; // [sp+8h] [bp-38h]@1
  __int64 v11; // [sp+10h] [bp-30h]@1

  v9 = a3;
  v10 = a2;
  v11 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v3 = CCDigestGetDigestInfo(3u);
  v4 = v3;
  v5 = *(_QWORD *)(v3 + 8);
  v6 = (char *)&v8 - ((((v5 + *(_QWORD *)(v3 + 16) + 19) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  memcpy(v6 + 8, a1, v5);
  memcpy(&v6[*(_QWORD *)(v4 + 8) + 8], (char *)a1 + 24, *(_QWORD *)(v4 + 16));
  *(_QWORD *)v6 = *((_QWORD *)a1 + 2);
  *(_DWORD *)(&v6[*(_QWORD *)(v4 + 8) + 8] + *(_QWORD *)(v4 + 16)) = *((_DWORD *)a1 + 22);
  ccdigest_update(v4, v6, v9, v10);
  memcpy(a1, v6 + 8, *(_QWORD *)(v4 + 8));
  memcpy((char *)a1 + 24, &v6[*(_QWORD *)(v4 + 8) + 8], *(_QWORD *)(v4 + 16));
  *((_QWORD *)a1 + 2) = *(_QWORD *)v6;
  *((_DWORD *)a1 + 22) = *(_DWORD *)(&v6[*(_QWORD *)(v4 + 8) + 8] + *(_QWORD *)(v4 + 16));
  result = *(_QWORD *)__stack_chk_guard_ptr[0];
  if ( *(_QWORD *)__stack_chk_guard_ptr[0] == v11 )
    result = 1LL;
  return result;
}
// AB26: using guessed type int __fastcall ccdigest_update(_QWORD, _QWORD, _QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000004EC1) ----------------------------------------------------
signed __int64 __fastcall CC_MD5_Final(__int64 a1, __int64 a2)
{
  __int64 v2; // rax@1
  __int64 v3; // rbx@1
  size_t v4; // rdx@1
  char *v5; // r15@1
  signed __int64 result; // rax@1
  __int64 v7; // [sp+0h] [bp-40h]@1
  __int64 v8; // [sp+8h] [bp-38h]@1
  __int64 v9; // [sp+10h] [bp-30h]@1

  v8 = a1;
  v9 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v2 = CCDigestGetDigestInfo(3u);
  v3 = v2;
  v4 = *(_QWORD *)(v2 + 8);
  v5 = (char *)&v7 - ((((v4 + *(_QWORD *)(v2 + 16) + 19) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  memcpy(v5 + 8, (const void *)a2, v4);
  memcpy(&v5[*(_QWORD *)(v3 + 8) + 8], (const void *)(a2 + 24), *(_QWORD *)(v3 + 16));
  *(_QWORD *)v5 = *(_QWORD *)(a2 + 16);
  *(_DWORD *)(&v5[*(_QWORD *)(v3 + 8) + 8] + *(_QWORD *)(v3 + 16)) = *(_DWORD *)(a2 + 88);
  (*(void (__fastcall **)(__int64, char *, __int64))(v3 + 56))(v3, v5, v8);
  memcpy((void *)a2, v5 + 8, *(_QWORD *)(v3 + 8));
  memcpy((void *)(a2 + 24), &v5[*(_QWORD *)(v3 + 8) + 8], *(_QWORD *)(v3 + 16));
  *(_QWORD *)(a2 + 16) = *(_QWORD *)v5;
  *(_DWORD *)(a2 + 88) = *(_DWORD *)(&v5[*(_QWORD *)(v3 + 8) + 8] + *(_QWORD *)(v3 + 16));
  result = *(_QWORD *)__stack_chk_guard_ptr[0];
  if ( *(_QWORD *)__stack_chk_guard_ptr[0] == v9 )
    result = 1LL;
  return result;
}
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000004FC8) ----------------------------------------------------
__int64 __fastcall CC_MD5(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rbx@1

  v3 = a3;
  CCDigest(3u, a1, a2, a3);
  return v3;
}

//----- (0000000000004FF0) ----------------------------------------------------
__int64 __fastcall CC_SHA1_Init(void *a1)
{
  __int64 v1; // r12@1
  __int64 v2; // rax@1
  __int64 v3; // r15@1
  char *v4; // rbx@1
  __int64 result; // rax@1
  __int64 v6; // [sp+0h] [bp-30h]@1
  __int64 v7; // [sp+8h] [bp-28h]@1

  v1 = __stack_chk_guard_ptr[0];
  v7 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v2 = CCDigestGetDigestInfo(8u);
  v3 = v2;
  v4 = (char *)&v6
     - ((((*(_QWORD *)(v2 + 8) + *(_QWORD *)(v2 + 16) + 19LL) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  ccdigest_init(v2, v4);
  memcpy(a1, v4 + 8, *(_QWORD *)(v3 + 8));
  memcpy((char *)a1 + 28, &v4[*(_QWORD *)(v3 + 8) + 8], *(_QWORD *)(v3 + 16));
  *(_QWORD *)((char *)a1 + 20) = *(_QWORD *)v4;
  *((_DWORD *)a1 + 23) = *(_DWORD *)(&v4[*(_QWORD *)(v3 + 8) + 8] + *(_QWORD *)(v3 + 16));
  result = *(_QWORD *)v1;
  if ( *(_QWORD *)v1 == v7 )
    result = 1LL;
  return result;
}
// AB20: using guessed type int __fastcall ccdigest_init(_QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (00000000000050A9) ----------------------------------------------------
__int64 __fastcall CC_SHA1_Update(void *a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rax@1
  __int64 v4; // r15@1
  size_t v5; // rdx@1
  char *v6; // rbx@1
  __int64 result; // rax@1
  __int64 v8; // [sp+0h] [bp-40h]@1
  unsigned int v9; // [sp+4h] [bp-3Ch]@1
  __int64 v10; // [sp+8h] [bp-38h]@1
  __int64 v11; // [sp+10h] [bp-30h]@1

  v9 = a3;
  v10 = a2;
  v11 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v3 = CCDigestGetDigestInfo(8u);
  v4 = v3;
  v5 = *(_QWORD *)(v3 + 8);
  v6 = (char *)&v8 - ((((v5 + *(_QWORD *)(v3 + 16) + 19) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  memcpy(v6 + 8, a1, v5);
  memcpy(&v6[*(_QWORD *)(v4 + 8) + 8], (char *)a1 + 28, *(_QWORD *)(v4 + 16));
  *(_QWORD *)v6 = *(_QWORD *)((char *)a1 + 20);
  *(_DWORD *)(&v6[*(_QWORD *)(v4 + 8) + 8] + *(_QWORD *)(v4 + 16)) = *((_DWORD *)a1 + 23);
  ccdigest_update(v4, v6, v9, v10);
  memcpy(a1, v6 + 8, *(_QWORD *)(v4 + 8));
  memcpy((char *)a1 + 28, &v6[*(_QWORD *)(v4 + 8) + 8], *(_QWORD *)(v4 + 16));
  *(_QWORD *)((char *)a1 + 20) = *(_QWORD *)v6;
  *((_DWORD *)a1 + 23) = *(_DWORD *)(&v6[*(_QWORD *)(v4 + 8) + 8] + *(_QWORD *)(v4 + 16));
  result = *(_QWORD *)__stack_chk_guard_ptr[0];
  if ( *(_QWORD *)__stack_chk_guard_ptr[0] == v11 )
    result = 1LL;
  return result;
}
// AB26: using guessed type int __fastcall ccdigest_update(_QWORD, _QWORD, _QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (00000000000051B6) ----------------------------------------------------
signed __int64 __fastcall CC_SHA1_Final(__int64 a1, __int64 a2)
{
  __int64 v2; // rax@1
  __int64 v3; // rbx@1
  size_t v4; // rdx@1
  char *v5; // r15@1
  signed __int64 result; // rax@1
  __int64 v7; // [sp+0h] [bp-40h]@1
  __int64 v8; // [sp+8h] [bp-38h]@1
  __int64 v9; // [sp+10h] [bp-30h]@1

  v8 = a1;
  v9 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v2 = CCDigestGetDigestInfo(8u);
  v3 = v2;
  v4 = *(_QWORD *)(v2 + 8);
  v5 = (char *)&v7 - ((((v4 + *(_QWORD *)(v2 + 16) + 19) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  memcpy(v5 + 8, (const void *)a2, v4);
  memcpy(&v5[*(_QWORD *)(v3 + 8) + 8], (const void *)(a2 + 28), *(_QWORD *)(v3 + 16));
  *(_QWORD *)v5 = *(_QWORD *)(a2 + 20);
  *(_DWORD *)(&v5[*(_QWORD *)(v3 + 8) + 8] + *(_QWORD *)(v3 + 16)) = *(_DWORD *)(a2 + 92);
  (*(void (__fastcall **)(__int64, char *, __int64))(v3 + 56))(v3, v5, v8);
  memcpy((void *)a2, v5 + 8, *(_QWORD *)(v3 + 8));
  memcpy((void *)(a2 + 28), &v5[*(_QWORD *)(v3 + 8) + 8], *(_QWORD *)(v3 + 16));
  *(_QWORD *)(a2 + 20) = *(_QWORD *)v5;
  *(_DWORD *)(a2 + 92) = *(_DWORD *)(&v5[*(_QWORD *)(v3 + 8) + 8] + *(_QWORD *)(v3 + 16));
  result = *(_QWORD *)__stack_chk_guard_ptr[0];
  if ( *(_QWORD *)__stack_chk_guard_ptr[0] == v9 )
    result = 1LL;
  return result;
}
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (00000000000052BD) ----------------------------------------------------
__int64 __fastcall CC_SHA1(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rbx@1

  v3 = a3;
  CCDigest(8u, a1, a2, a3);
  return v3;
}

//----- (00000000000052E5) ----------------------------------------------------
__int64 __fastcall CC_SHA224(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rbx@1

  v3 = a3;
  CCDigest(9u, a1, a2, a3);
  return v3;
}

//----- (000000000000530D) ----------------------------------------------------
__int64 __fastcall CC_SHA256(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rbx@1

  v3 = a3;
  CCDigest(0xAu, a1, a2, a3);
  return v3;
}

//----- (0000000000005335) ----------------------------------------------------
__int64 __fastcall CC_SHA384(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rbx@1

  v3 = a3;
  CCDigest(0xBu, a1, a2, a3);
  return v3;
}

//----- (000000000000535D) ----------------------------------------------------
__int64 __fastcall CC_SHA512(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rbx@1

  v3 = a3;
  CCDigest(0xCu, a1, a2, a3);
  return v3;
}

//----- (0000000000005385) ----------------------------------------------------
signed __int64 __fastcall MD5Final(__int64 a1, __int64 a2)
{
  return CC_MD5_Final(a1, a2);
}

//----- (000000000000538F) ----------------------------------------------------
signed __int64 __fastcall CC_MD2_Init(__int64 a1)
{
  __int64 v1; // r12@1
  __int64 v2; // rax@1
  __int64 v3; // r15@1
  char *v4; // rbx@1
  __int64 v5; // rax@1
  __int64 v6; // rax@1
  __int64 v7; // rax@1
  __int64 v8; // rcx@1
  signed __int64 result; // rax@1
  __int64 v10; // [sp+0h] [bp-30h]@1
  __int64 v11; // [sp+8h] [bp-28h]@1

  v1 = __stack_chk_guard_ptr[0];
  v11 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v2 = CCDigestGetDigestInfo(1u);
  v3 = v2;
  v4 = (char *)&v10
     - ((((*(_QWORD *)(v2 + 8) + *(_QWORD *)(v2 + 16) + 19LL) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  ccdigest_init(v2, v4);
  v5 = *((_QWORD *)v4 + 7);
  *(_QWORD *)(a1 + 28) = *((_QWORD *)v4 + 8);
  *(_QWORD *)(a1 + 20) = v5;
  v6 = *((_QWORD *)v4 + 1);
  *(_QWORD *)(a1 + 92) = *((_QWORD *)v4 + 2);
  *(_QWORD *)(a1 + 84) = v6;
  v7 = *(_QWORD *)(v3 + 8);
  v8 = *(_QWORD *)&v4[v7 + 8];
  *(_QWORD *)(a1 + 12) = *(_QWORD *)&v4[v7 + 16];
  *(_QWORD *)(a1 + 4) = v8;
  *(_DWORD *)a1 = *(_DWORD *)(&v4[*(_QWORD *)(v3 + 8) + 8] + *(_QWORD *)(v3 + 16));
  result = *(_QWORD *)v1;
  if ( *(_QWORD *)v1 == v11 )
    result = 1LL;
  return result;
}
// AB20: using guessed type int __fastcall ccdigest_init(_QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000005450) ----------------------------------------------------
signed __int64 __usercall CC_MD2_Update@<rax>(__int64 a1@<rax>, unsigned int a2@<edx>, __int64 a3@<rdi>, __int64 a4@<rsi>)
{
  unsigned int v4; // er13@1
  __int64 v5; // rax@1
  __int64 v6; // r14@1
  char *v7; // rbx@1
  __int64 v8; // rax@1
  __int64 v9; // rax@1
  __int64 v10; // rax@1
  __int64 v11; // rcx@1
  __int64 v12; // rax@1
  __int64 v13; // rax@1
  __int64 v14; // rax@1
  __int64 v15; // rcx@1
  signed __int64 result; // rax@1
  __int64 v17; // [sp+0h] [bp-30h]@1

  v17 = a1;
  v4 = a2;
  v17 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v5 = CCDigestGetDigestInfo(1u);
  v6 = v5;
  v7 = (char *)&v17
     - ((((*(_QWORD *)(v5 + 8) + *(_QWORD *)(v5 + 16) + 19LL) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v8 = *(_QWORD *)(a3 + 20);
  *((_QWORD *)v7 + 8) = *(_QWORD *)(a3 + 28);
  *((_QWORD *)v7 + 7) = v8;
  v9 = *(_QWORD *)(a3 + 84);
  *((_QWORD *)v7 + 2) = *(_QWORD *)(a3 + 92);
  *((_QWORD *)v7 + 1) = v9;
  v10 = *(_QWORD *)(v6 + 8);
  v11 = *(_QWORD *)(a3 + 4);
  *(_QWORD *)&v7[v10 + 16] = *(_QWORD *)(a3 + 12);
  *(_QWORD *)&v7[v10 + 8] = v11;
  *(_DWORD *)(&v7[*(_QWORD *)(v6 + 8) + 8] + *(_QWORD *)(v6 + 16)) = *(_DWORD *)a3;
  ccdigest_update(v6, v7, v4, a4);
  v12 = *((_QWORD *)v7 + 7);
  *(_QWORD *)(a3 + 28) = *((_QWORD *)v7 + 8);
  *(_QWORD *)(a3 + 20) = v12;
  v13 = *((_QWORD *)v7 + 1);
  *(_QWORD *)(a3 + 92) = *((_QWORD *)v7 + 2);
  *(_QWORD *)(a3 + 84) = v13;
  v14 = *(_QWORD *)(v6 + 8);
  v15 = *(_QWORD *)&v7[v14 + 8];
  *(_QWORD *)(a3 + 12) = *(_QWORD *)&v7[v14 + 16];
  *(_QWORD *)(a3 + 4) = v15;
  *(_DWORD *)a3 = *(_DWORD *)(&v7[*(_QWORD *)(v6 + 8) + 8] + *(_QWORD *)(v6 + 16));
  result = *(_QWORD *)__stack_chk_guard_ptr[0];
  if ( *(_QWORD *)__stack_chk_guard_ptr[0] == v17 )
    result = 1LL;
  return result;
}
// AB26: using guessed type int __fastcall ccdigest_update(_QWORD, _QWORD, _QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000005576) ----------------------------------------------------
signed __int64 __usercall CC_MD2_Final@<rax>(__int64 a1@<rax>, __int64 a2@<rdi>, __int64 a3@<rsi>)
{
  __int64 v3; // r13@1
  __int64 v4; // rax@1
  __int64 v5; // r14@1
  char *v6; // rbx@1
  __int64 v7; // rax@1
  __int64 v8; // rax@1
  __int64 v9; // rax@1
  __int64 v10; // rcx@1
  __int64 v11; // rax@1
  __int64 v12; // rax@1
  __int64 v13; // rax@1
  __int64 v14; // rcx@1
  signed __int64 result; // rax@1
  __int64 v16; // [sp+0h] [bp-30h]@1

  v16 = a1;
  v3 = __stack_chk_guard_ptr[0];
  v16 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v4 = CCDigestGetDigestInfo(1u);
  v5 = v4;
  v6 = (char *)&v16
     - ((((*(_QWORD *)(v4 + 8) + *(_QWORD *)(v4 + 16) + 19LL) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v7 = *(_QWORD *)(a3 + 20);
  *((_QWORD *)v6 + 8) = *(_QWORD *)(a3 + 28);
  *((_QWORD *)v6 + 7) = v7;
  v8 = *(_QWORD *)(a3 + 84);
  *((_QWORD *)v6 + 2) = *(_QWORD *)(a3 + 92);
  *((_QWORD *)v6 + 1) = v8;
  v9 = *(_QWORD *)(v5 + 8);
  v10 = *(_QWORD *)(a3 + 4);
  *(_QWORD *)&v6[v9 + 16] = *(_QWORD *)(a3 + 12);
  *(_QWORD *)&v6[v9 + 8] = v10;
  *(_DWORD *)(&v6[*(_QWORD *)(v5 + 8) + 8] + *(_QWORD *)(v5 + 16)) = *(_DWORD *)a3;
  (*(void (__fastcall **)(__int64, char *, __int64))(v5 + 56))(v5, v6, a2);
  v11 = *((_QWORD *)v6 + 7);
  *(_QWORD *)(a3 + 28) = *((_QWORD *)v6 + 8);
  *(_QWORD *)(a3 + 20) = v11;
  v12 = *((_QWORD *)v6 + 1);
  *(_QWORD *)(a3 + 92) = *((_QWORD *)v6 + 2);
  *(_QWORD *)(a3 + 84) = v12;
  v13 = *(_QWORD *)(v5 + 8);
  v14 = *(_QWORD *)&v6[v13 + 8];
  *(_QWORD *)(a3 + 12) = *(_QWORD *)&v6[v13 + 16];
  *(_QWORD *)(a3 + 4) = v14;
  *(_DWORD *)a3 = *(_DWORD *)(&v6[*(_QWORD *)(v5 + 8) + 8] + *(_QWORD *)(v5 + 16));
  result = *(_QWORD *)v3;
  if ( *(_QWORD *)v3 == v16 )
    result = 1LL;
  return result;
}
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000005690) ----------------------------------------------------
signed __int64 __fastcall CC_SHA256_Init(__int64 a1)
{
  __int64 v1; // rax@1

  v1 = CCDigestGetDigestInfo(0xAu);
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)a1 = 0LL;
  memcpy((void *)(a1 + 8), *(const void **)(v1 + 40), *(_QWORD *)(v1 + 8));
  return 1LL;
}

//----- (0000000000005727) ----------------------------------------------------
signed __int64 __fastcall CC_SHA256_Update(__int64 a1, const void *a2, unsigned int a3)
{
  unsigned int v3; // er15@1
  __int64 v4; // rax@1
  __int64 v5; // rcx@1
  __int64 v6; // rax@3

  v3 = a3;
  v4 = CCDigestGetDigestInfo(0xAu);
  v5 = v4;
  if ( v3 && a2 )
  {
    v6 = *(_QWORD *)a1 % *(_QWORD *)(v4 + 16);
    *(_QWORD *)a1 += v3;
    ccdigest_process(v5, a1 + 40, a1 + 8, v6, v3, a2);
  }
  return 1LL;
}

//----- (000000000000578F) ----------------------------------------------------
int __fastcall ccdigest_process(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5, const void *a6)
{
  const void *v6; // r13@1
  unsigned __int64 v7; // r15@2
  unsigned __int64 v8; // r14@3
  int result; // eax@5
  unsigned __int64 v10; // rbx@5
  __int64 v11; // rbx@7
  size_t v12; // r14@7
  __int64 v13; // [sp+8h] [bp-38h]@1
  __int64 v14; // [sp+10h] [bp-30h]@1

  v6 = a6;
  v14 = a4;
  v13 = a3;
  if ( a5 )
  {
    do
    {
      v7 = a5;
      while ( 1 )
      {
        v8 = *(_QWORD *)(a1 + 16);
        if ( v14 || v7 < v8 )
          break;
        result = (*(int (__fastcall **)(__int64, unsigned __int64, const void *))(a1 + 48))(v13, v7 / v8, v6);
        v10 = *(_QWORD *)(a1 + 16) * (v7 / v8);
        v6 = (char *)v6 + v10;
        v7 -= v10;
        if ( !v7 )
          return result;
      }
      v11 = v14;
      v12 = v8 - v14;
      if ( v7 < v12 )
        v12 = v7;
      result = (unsigned __int64)memcpy((void *)(a2 + v14), v6, v12);
      v14 += v12;
      if ( v12 + v11 == *(_QWORD *)(a1 + 16) )
      {
        (*(void (__fastcall **)(__int64, signed __int64, __int64))(a1 + 48))(v13, 1LL, a2);
        result = 0;
        v14 = 0LL;
      }
      a5 = v7 - v12;
      v6 = (char *)v6 + v12;
    }
    while ( v7 != v12 );
  }
  return result;
}

//----- (0000000000005861) ----------------------------------------------------
signed __int64 __fastcall CC_SHA256_Final(__int64 a1, unsigned __int64 *a2)
{
  __int64 v2; // rcx@1
  __int64 v3; // rax@2

  v2 = CCDigestGetDigestInfo(0xAu);
  if ( a1 )
  {
    ccdigest_finalize(v2, (__int64)(a2 + 5), (__int64)(a2 + 1), *a2 % *(_QWORD *)(v2 + 16), *a2);
    v3 = 0LL;
    do
    {
      *(_BYTE *)(a1 + 4 * v3) = *((_BYTE *)a2 + 4 * v3 + 11);
      *(_BYTE *)(a1 + 4 * v3 + 1) = *((_BYTE *)a2 + 4 * v3 + 10);
      *(_BYTE *)(a1 + 4 * v3 + 2) = *((_BYTE *)a2 + 4 * v3 + 9);
      *(_BYTE *)(a1 + 4 * v3 + 3) = *((_BYTE *)a2 + 4 * v3 + 8);
      ++v3;
    }
    while ( v3 != 8 );
  }
  return 1LL;
}

//----- (00000000000058DD) ----------------------------------------------------
int __fastcall ccdigest_finalize(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5)
{
  unsigned __int64 v5; // r12@1
  __int64 v6; // r14@1
  signed __int64 v7; // rcx@1
  unsigned __int64 v8; // rax@1
  signed __int64 v9; // rax@6

  v5 = a5;
  v6 = a3;
  *(_BYTE *)(a2 + a4) = -128;
  v7 = a4 + 1;
  v8 = *(_QWORD *)(a1 + 16);
  if ( v7 > *(_QWORD *)(a1 + 16) - (8 * (unsigned __int64)(v8 == 128) + 8) )
  {
    if ( v7 < v8 )
    {
      do
        *(_BYTE *)(a2 + v7++) = 0;
      while ( (unsigned __int64)v7 < *(_QWORD *)(a1 + 16) );
    }
    (*(void (__fastcall **)(__int64, signed __int64, __int64))(a1 + 48))(a3, 1LL, a2);
    v8 = *(_QWORD *)(a1 + 16);
    v7 = 0LL;
  }
  while ( 1 )
  {
    v9 = v8 - 8;
    if ( v7 >= (unsigned __int64)v9 )
      break;
    *(_BYTE *)(a2 + v7++) = 0;
    v8 = *(_QWORD *)(a1 + 16);
  }
  *(_BYTE *)(a2 + v9) = v5 >> 53;
  *(_BYTE *)(*(_QWORD *)(a1 + 16) + a2 - 7) = v5 >> 45;
  *(_BYTE *)(*(_QWORD *)(a1 + 16) + a2 - 6) = v5 >> 37;
  *(_BYTE *)(*(_QWORD *)(a1 + 16) + a2 - 5) = v5 >> 29;
  *(_BYTE *)(*(_QWORD *)(a1 + 16) + a2 - 4) = v5 >> 21;
  *(_BYTE *)(*(_QWORD *)(a1 + 16) + a2 - 3) = v5 >> 13;
  *(_BYTE *)(*(_QWORD *)(a1 + 16) + a2 - 2) = v5 >> 5;
  *(_BYTE *)(*(_QWORD *)(a1 + 16) + a2 - 1) = 8 * v5;
  return (*(int (__fastcall **)(__int64, signed __int64, __int64))(a1 + 48))(v6, 1LL, a2);
}

//----- (00000000000059EF) ----------------------------------------------------
signed __int64 __fastcall CC_SHA512_Init(__int64 a1)
{
  __int64 v1; // rax@1

  v1 = CCDigestGetDigestInfo(0xCu);
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 200) = 0LL;
  *(_QWORD *)(a1 + 192) = 0LL;
  *(_QWORD *)(a1 + 184) = 0LL;
  *(_QWORD *)(a1 + 176) = 0LL;
  *(_QWORD *)(a1 + 168) = 0LL;
  *(_QWORD *)(a1 + 160) = 0LL;
  *(_QWORD *)(a1 + 152) = 0LL;
  *(_QWORD *)(a1 + 144) = 0LL;
  *(_QWORD *)(a1 + 136) = 0LL;
  *(_QWORD *)(a1 + 128) = 0LL;
  *(_QWORD *)(a1 + 120) = 0LL;
  *(_QWORD *)(a1 + 112) = 0LL;
  *(_QWORD *)(a1 + 104) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_QWORD *)a1 = 0LL;
  memcpy((void *)(a1 + 16), *(const void **)(v1 + 40), *(_QWORD *)(v1 + 8));
  return 1LL;
}

//----- (0000000000005B04) ----------------------------------------------------
signed __int64 __fastcall CC_SHA512_Update(__int64 a1, const void *a2, unsigned int a3)
{
  unsigned int v3; // er15@1
  __int64 v4; // rax@1
  __int64 v5; // rcx@1
  __int64 v6; // rax@3

  v3 = a3;
  v4 = CCDigestGetDigestInfo(0xCu);
  v5 = v4;
  if ( v3 && a2 )
  {
    v6 = *(_QWORD *)a1 % *(_QWORD *)(v4 + 16);
    *(_QWORD *)a1 += v3;
    ccdigest_process(v5, a1 + 80, a1 + 16, v6, v3, a2);
  }
  return 1LL;
}

//----- (0000000000005B6C) ----------------------------------------------------
signed __int64 __fastcall CC_SHA512_Final(__int64 a1, unsigned __int64 *a2)
{
  __int64 v2; // r15@1
  unsigned __int64 v3; // rax@3

  v2 = CCDigestGetDigestInfo(0xCu);
  if ( a1 )
  {
    ccdigest_finalize(v2, (__int64)(a2 + 10), (__int64)(a2 + 2), *a2 % *(_QWORD *)(v2 + 16), *a2);
    if ( *(_QWORD *)v2 >= 8uLL )
    {
      v3 = 0LL;
      do
      {
        *(_BYTE *)(a1 + 8 * v3) = BYTE7(a2[v3 + 2]);
        *(_BYTE *)(a1 + 8 * v3 + 1) = BYTE6(a2[v3 + 2]);
        *(_BYTE *)(a1 + 8 * v3 + 2) = BYTE5(a2[v3 + 2]);
        *(_BYTE *)(a1 + 8 * v3 + 3) = BYTE4(a2[v3 + 2]);
        *(_BYTE *)(a1 + 8 * v3 + 4) = BYTE3(a2[v3 + 2]);
        *(_BYTE *)(a1 + 8 * v3 + 5) = BYTE2(a2[v3 + 2]);
        *(_BYTE *)(a1 + 8 * v3 + 6) = BYTE1(a2[v3 + 2]);
        *(_BYTE *)(a1 + 8 * v3 + 7) = LOBYTE(a2[v3 + 2]);
        ++v3;
      }
      while ( v3 < *(_QWORD *)v2 >> 3 );
    }
  }
  return 1LL;
}

//----- (0000000000005C25) ----------------------------------------------------
signed __int64 __fastcall CC_SHA224_Init(__int64 a1)
{
  __int64 v1; // rax@1

  v1 = CCDigestGetDigestInfo(9u);
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)a1 = 0LL;
  memcpy((void *)(a1 + 8), *(const void **)(v1 + 40), *(_QWORD *)(v1 + 8));
  return 1LL;
}

//----- (0000000000005CBC) ----------------------------------------------------
signed __int64 __fastcall CC_SHA224_Update(__int64 a1, const void *a2, unsigned int a3)
{
  CC_SHA256_Update(a1, a2, a3);
  return 1LL;
}

//----- (0000000000005CCC) ----------------------------------------------------
signed __int64 __fastcall CC_SHA224_Final(__int64 a1, unsigned __int64 *a2)
{
  __int64 v2; // r14@1
  __int64 v3; // rax@1
  signed __int64 result; // rax@1
  __int64 v5; // [sp+0h] [bp-40h]@1
  __int64 v6; // [sp+8h] [bp-38h]@1
  __int64 v7; // [sp+10h] [bp-30h]@1
  int v8; // [sp+18h] [bp-28h]@1
  __int64 v9; // [sp+28h] [bp-18h]@1

  v2 = __stack_chk_guard_ptr[0];
  v9 = *(_QWORD *)__stack_chk_guard_ptr[0];
  CC_SHA256_Final((__int64)&v5, a2);
  *(_DWORD *)(a1 + 24) = v8;
  *(_QWORD *)(a1 + 16) = v7;
  v3 = v5;
  *(_QWORD *)(a1 + 8) = v6;
  *(_QWORD *)a1 = v3;
  result = *(_QWORD *)v2;
  if ( *(_QWORD *)v2 == v9 )
    result = 1LL;
  return result;
}
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000005D2A) ----------------------------------------------------
signed __int64 __fastcall CC_SHA384_Init(__int64 a1)
{
  __int64 v1; // rax@1

  v1 = CCDigestGetDigestInfo(0xBu);
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 200) = 0LL;
  *(_QWORD *)(a1 + 192) = 0LL;
  *(_QWORD *)(a1 + 184) = 0LL;
  *(_QWORD *)(a1 + 176) = 0LL;
  *(_QWORD *)(a1 + 168) = 0LL;
  *(_QWORD *)(a1 + 160) = 0LL;
  *(_QWORD *)(a1 + 152) = 0LL;
  *(_QWORD *)(a1 + 144) = 0LL;
  *(_QWORD *)(a1 + 136) = 0LL;
  *(_QWORD *)(a1 + 128) = 0LL;
  *(_QWORD *)(a1 + 120) = 0LL;
  *(_QWORD *)(a1 + 112) = 0LL;
  *(_QWORD *)(a1 + 104) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)a1 = 0LL;
  memcpy((void *)(a1 + 16), *(const void **)(v1 + 40), *(_QWORD *)(v1 + 8));
  return 1LL;
}

//----- (0000000000005E47) ----------------------------------------------------
signed __int64 __fastcall CC_SHA384_Update(__int64 a1, const void *a2, unsigned int a3)
{
  CC_SHA512_Update(a1, a2, a3);
  return 1LL;
}

//----- (0000000000005E57) ----------------------------------------------------
signed __int64 __fastcall CC_SHA384_Final(__int64 a1, unsigned __int64 *a2)
{
  __int64 v2; // r14@1
  __int64 v3; // rax@1
  signed __int64 result; // rax@1
  __int64 v5; // [sp+0h] [bp-60h]@1
  __int64 v6; // [sp+8h] [bp-58h]@1
  __int64 v7; // [sp+10h] [bp-50h]@1
  __int64 v8; // [sp+18h] [bp-48h]@1
  __int64 v9; // [sp+20h] [bp-40h]@1
  __int64 v10; // [sp+28h] [bp-38h]@1
  __int64 v11; // [sp+48h] [bp-18h]@1

  v2 = __stack_chk_guard_ptr[0];
  v11 = *(_QWORD *)__stack_chk_guard_ptr[0];
  CC_SHA512_Final((__int64)&v5, a2);
  *(_QWORD *)(a1 + 40) = v10;
  *(_QWORD *)(a1 + 32) = v9;
  *(_QWORD *)(a1 + 24) = v8;
  *(_QWORD *)(a1 + 16) = v7;
  v3 = v5;
  *(_QWORD *)(a1 + 8) = v6;
  *(_QWORD *)a1 = v3;
  result = *(_QWORD *)v2;
  if ( *(_QWORD *)v2 == v11 )
    result = 1LL;
  return result;
}
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000005EC7) ----------------------------------------------------
signed __int64 __usercall CCECCryptorGeneratePair@<rax>(__int64 a1@<rdx>, __int64 a2@<rdi>, __int64 a3@<rsi>, __int64 a4@<r8>, __int64 a5@<r9>, __int128 a6@<xmm0>, __int128 a7@<xmm1>, __int128 a8@<xmm2>, __int128 a9@<xmm3>, __int128 a10@<xmm4>, __int128 a11@<xmm5>, __int128 a12@<xmm6>, __int128 a13@<xmm7>)
{
  __int64 v13; // rbx@1
  __int64 v14; // r12@1
  int v15; // ecx@1
  signed __int64 result; // rax@1
  __int64 v17; // rax@2
  __int64 v18; // r14@2
  void *v19; // rax@2
  __int64 v20; // rbx@2
  __int64 v21; // rax@4
  __int64 v22; // r9@4
  __int128 v23; // xmm4@4
  __int128 v24; // xmm5@4
  __int64 v25; // r12@4
  void *v26; // rdi@7
  __int64 v27; // [sp+0h] [bp-30h]@2

  v13 = a1;
  v14 = ccDRBGGetRngState(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
  v15 = ccec_keysize_is_supported(a2);
  result = 4294962996LL;
  if ( v15 )
  {
    v27 = v13;
    LODWORD(v17) = ccec_get_cp(a2);
    v18 = v17;
    v19 = ccMallocECCryptor(a2, 1);
    v20 = (__int64)v19;
    if ( v19 )
    {
      *((_QWORD *)v19 + 1) = a2;
      if ( ccec_generate_key(v18, v14, *(_QWORD *)v19)
        || (*(_DWORD *)(v20 + 16) = 1,
            v21 = CCECCryptorGetPublicKeyFromPrivateKey(v20, a6, a7, a8, a9, a12, a13),
            (v25 = v21) == 0) )
      {
        v26 = (void *)v20;
      }
      else
      {
        if ( ccECpairwiseConsistencyCheck(v20, v21, v22, a6, a7, a8, a9, v23, v24, a12, a13) )
        {
          *(_QWORD *)a3 = v25;
          *(_QWORD *)v27 = v20;
          return 0LL;
        }
        ccECCryptorFree((void *)v20);
        v26 = (void *)v25;
      }
      ccECCryptorFree(v26);
    }
    *(_QWORD *)v27 = 0LL;
    *(_QWORD *)a3 = 0LL;
    result = 4294962992LL;
  }
  return result;
}
// AB38: using guessed type int __fastcall ccec_generate_key(_QWORD, _QWORD, _QWORD);
// AB3E: using guessed type int __cdecl ccec_get_cp(_QWORD);
// AB50: using guessed type int __cdecl ccec_keysize_is_supported(_QWORD);

//----- (0000000000005FA6) ----------------------------------------------------
void *__fastcall ccMallocECCryptor(__int64 a1, int a2)
{
  int v2; // ecx@1
  void *result; // rax@1
  __int64 v4; // rax@2
  __int64 v5; // r15@2
  __int64 v6; // rax@2
  __int64 v7; // rbx@2
  void *v8; // r12@2
  unsigned __int64 v9; // rbx@3
  signed __int64 v10; // rbx@4
  void *v11; // rax@7

  v2 = ccec_keysize_is_supported(a1);
  result = 0LL;
  if ( v2 )
  {
    LODWORD(v4) = ccec_get_cp(a1);
    v5 = v4;
    LODWORD(v6) = ccn_bitlen(*(_QWORD *)v4, v4 + 16);
    v7 = v6;
    v8 = malloc(0x18uLL);
    result = 0LL;
    if ( v8 )
    {
      v9 = (unsigned __int64)(v7 + 7) >> 3;
      *((_QWORD *)v8 + 1) = a1;
      *(_QWORD *)v8 = 0LL;
      if ( a2 == 1 )
      {
        *((_DWORD *)v8 + 4) = 98;
        v10 = 4 * v9;
      }
      else
      {
        if ( a2 )
        {
LABEL_9:
          free(v8);
          return 0LL;
        }
        *((_DWORD *)v8 + 4) = 97;
        v10 = 3 * v9;
      }
      v11 = malloc(v10 + 16);
      *(_QWORD *)v8 = v11;
      if ( v11 )
      {
        *(_QWORD *)v11 = v5;
        return v8;
      }
      goto LABEL_9;
    }
  }
  return result;
}
// AB3E: using guessed type int __cdecl ccec_get_cp(_QWORD);
// AB50: using guessed type int __cdecl ccec_keysize_is_supported(_QWORD);
// ABCE: using guessed type int __fastcall ccn_bitlen(_QWORD, _QWORD);

//----- (000000000000606B) ----------------------------------------------------
__int64 __usercall CCECCryptorGetPublicKeyFromPrivateKey@<rax>(__int64 a1@<rdi>, __int128 a2@<xmm0>, __int128 a3@<xmm1>, __int128 a4@<xmm2>, __int128 a5@<xmm3>, __int128 a6@<xmm6>, __int128 a7@<xmm7>)
{
  __int64 v7; // rbx@1
  __int64 v8; // r15@1
  __int64 v9; // rax@2
  __int64 v10; // rax@2
  __int64 v11; // r9@2
  __int128 v12; // xmm4@2
  __int128 v13; // xmm5@2
  bool v14; // al@2

  v7 = 0LL;
  v8 = (__int64)ccMallocECCryptor(*(_QWORD *)(a1 + 8), 0);
  if ( v8 )
  {
    LODWORD(v9) = ccec_get_cp(*(_QWORD *)(a1 + 8));
    LODWORD(v10) = ccn_bitlen(*(_QWORD *)v9, v9 + 16);
    memcpy(*(void **)v8, *(const void **)a1, 3 * ((unsigned __int64)(v10 + 7) >> 3) + 16);
    *(_QWORD *)(v8 + 8) = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(v8 + 16) = 0;
    v14 = ccECpairwiseConsistencyCheck(a1, v8, v11, a2, a3, a4, a5, v12, v13, a6, a7);
    v7 = 0LL;
    if ( v14 )
      v7 = v8;
    if ( !v14 )
    {
      ccECCryptorFree((void *)v8);
      v7 = 0LL;
    }
  }
  return v7;
}
// AB3E: using guessed type int __cdecl ccec_get_cp(_QWORD);
// ABCE: using guessed type int __fastcall ccn_bitlen(_QWORD, _QWORD);

//----- (00000000000060F7) ----------------------------------------------------
bool __usercall ccECpairwiseConsistencyCheck@<al>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r9>, __int128 a4@<xmm0>, __int128 a5@<xmm1>, __int128 a6@<xmm2>, __int128 a7@<xmm3>, __int128 a8@<xmm4>, __int128 a9@<xmm5>, __int128 a10@<xmm6>, __int128 a11@<xmm7>)
{
  __int64 v11; // r14@1
  bool result; // al@2
  int v13; // eax@3
  __int64 v14; // rcx@4
  int v15; // [sp+4h] [bp-103Ch]@1
  __int64 v16; // [sp+8h] [bp-1038h]@1
  char v17; // [sp+10h] [bp-1030h]@1
  __int64 v18; // [sp+1010h] [bp-30h]@1
  __int64 v19; // [sp+1018h] [bp-28h]@1
  int v20; // [sp+1020h] [bp-20h]@1
  __int64 v21; // [sp+1028h] [bp-18h]@1

  v11 = __stack_chk_guard_ptr[0];
  v21 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v16 = 4096LL;
  v15 = 0;
  v19 = 723401728380766730LL;
  v18 = 723401728380766730LL;
  v20 = 168430090;
  if ( (unsigned int)CCECCryptorSignHash(
                       20LL,
                       (__int64)&v17,
                       a1,
                       (__int64)&v18,
                       (__int64)&v16,
                       a3,
                       a4,
                       a5,
                       a6,
                       a7,
                       a8,
                       a9,
                       a10,
                       a11) )
  {
    result = 0;
  }
  else
  {
    v13 = CCECCryptorVerifyHash(a2, (__int64)&v18, 20LL, (__int64)&v17, v16, (__int64)&v15);
    result = v13 == 0 && v15 == 1;
  }
  v14 = *(_QWORD *)v11;
  return result;
}
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (00000000000061B9) ----------------------------------------------------
void __fastcall ccECCryptorFree(void *a1)
{
  void *v1; // rbx@1
  __int64 v2; // rax@1
  signed int v3; // ecx@2
  __int64 v4; // rdi@10

  v1 = a1;
  LODWORD(v2) = ccec_get_cp(*((_QWORD *)a1 + 1));
  ccn_bitlen(*(_QWORD *)v2, v2 + 16);
  if ( a1 )
  {
    v3 = *((_DWORD *)a1 + 4);
    if ( v3 > 96 )
    {
      if ( v3 != 98 && v3 != 97 )
        goto LABEL_12;
    }
    else if ( v3 && v3 != 1 )
    {
      goto LABEL_12;
    }
    v4 = *(_QWORD *)a1;
    if ( *(_QWORD *)v1 )
    {
      __bzero(v4);
      free(*(void **)v1);
    }
LABEL_12:
    *((_QWORD *)v1 + 2) = 0LL;
    *((_QWORD *)v1 + 1) = 0LL;
    *(_QWORD *)v1 = 0LL;
    free(v1);
  }
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);
// AB3E: using guessed type int __cdecl ccec_get_cp(_QWORD);
// ABCE: using guessed type int __fastcall ccn_bitlen(_QWORD, _QWORD);

//----- (0000000000006253) ----------------------------------------------------
signed __int64 __fastcall CCECCryptorGetKeyComponents(__int64 a1)
{
  int v1; // er10@1
  int v2; // eax@2
  signed __int64 result; // rax@3
  int v4; // ecx@5

  v1 = *(_DWORD *)(a1 + 16);
  if ( v1 == 1 )
  {
    v2 = ccec_get_fullkey_components(*(_QWORD *)a1);
  }
  else
  {
    result = 4294962996LL;
    if ( v1 )
      return result;
    v2 = ccec_get_pubkey_components(*(_QWORD *)a1);
  }
  v4 = v2;
  result = 4294962994LL;
  if ( !v4 )
    result = 0LL;
  return result;
}
// AB44: using guessed type int __fastcall ccec_get_fullkey_components(_QWORD);
// AB4A: using guessed type int __fastcall ccec_get_pubkey_components(_QWORD);

//----- (00000000000062A5) ----------------------------------------------------
signed __int64 __fastcall CCECCryptorCreateFromData(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r14@1
  __int64 v7; // r15@1
  void *v8; // rbx@1
  signed __int64 result; // rax@1
  __int64 v10; // [sp+8h] [bp-38h]@1
  __int64 v11; // [sp+10h] [bp-30h]@1

  v6 = a6;
  v10 = a5;
  v11 = a4;
  v7 = a3;
  *(_QWORD *)a6 = 0LL;
  v8 = ccMallocECCryptor(a1, 0);
  result = 4294962994LL;
  if ( v8 )
  {
    if ( ccec_make_pub(a1, v7, a2, v10, v11, *(_QWORD *)v8) )
    {
      ccECCryptorFree(v8);
      result = 4294962992LL;
    }
    else
    {
      *((_DWORD *)v8 + 4) = 0;
      *(_QWORD *)v6 = v8;
      result = 0LL;
    }
  }
  return result;
}
// AB56: using guessed type int __fastcall ccec_make_pub(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000632C) ----------------------------------------------------
signed __int64 __fastcall CCECGetKeyType(__int64 a1)
{
  signed __int64 result; // rax@1
  unsigned int v2; // ecx@2

  result = 97LL;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 16);
    result = 99LL;
    if ( v2 <= 1 )
      result = v2;
  }
  return result;
}

//----- (000000000000634A) ----------------------------------------------------
signed __int64 __fastcall CCECGetKeySize(__int64 a1)
{
  signed __int64 result; // rax@1

  result = 4294962996LL;
  if ( a1 )
    result = *(_DWORD *)(a1 + 8);
  return result;
}

//----- (000000000000635D) ----------------------------------------------------
void __fastcall CCECCryptorRelease(void *a1)
{
  ccECCryptorFree(a1);
}

//----- (0000000000006367) ----------------------------------------------------
signed __int64 __fastcall CCECCryptorImportPublicKey(__int64 a1, __int64 a2, __int64 a3)
{
  return CCECCryptorImportKey(0, a1, a2, 0, a3);
}

//----- (0000000000006381) ----------------------------------------------------
signed __int64 __fastcall CCECCryptorImportKey(int a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  __int64 v5; // r15@1
  int v6; // er14@1
  __int64 v7; // r12@1
  signed __int64 result; // rax@1
  signed int v9; // ecx@2
  __int64 v10; // rax@5
  void *v11; // r13@5
  __int64 v12; // rax@6
  int v13; // eax@6
  __int64 v14; // rax@11
  __int64 v15; // rax@12
  __int64 v16; // [sp+0h] [bp-30h]@5

  v5 = a5;
  v6 = a4;
  v7 = a3;
  result = 4294962996LL;
  if ( !a2 )
    return result;
  v9 = -4305;
  if ( a1 == 1 )
  {
LABEL_8:
    *(_QWORD *)a5 = 0LL;
    return (unsigned int)v9;
  }
  if ( a1 )
  {
    v9 = -4300;
    goto LABEL_8;
  }
  if ( !v6 )
  {
    LODWORD(v10) = ccec_x963_import_pub_size(a3, a2, a3, 4294962991LL);
    v16 = v10;
    v11 = ccMallocECCryptor(v10, 0);
    result = 4294962994LL;
    if ( !v11 )
      return result;
    LODWORD(v12) = ccec_get_cp(v16);
    v13 = ccec_x963_import_pub(v12, v7, a2, *(_QWORD *)v11);
    goto LABEL_13;
  }
  if ( v6 == 1 )
  {
    LODWORD(v14) = ccec_x963_import_priv_size(a3, a2, a3, 4294962991LL);
    v16 = v14;
    v11 = ccMallocECCryptor(v14, 1);
    result = 4294962994LL;
    if ( v11 )
    {
      LODWORD(v15) = ccec_get_cp(v16);
      v13 = ccec_x963_import_priv(v15, v7, a2, *(_QWORD *)v11);
LABEL_13:
      if ( v13 )
      {
        *(_QWORD *)v5 = 0LL;
        ccECCryptorFree(v11);
        result = 4294962992LL;
      }
      else
      {
        *((_QWORD *)v11 + 1) = v16;
        *((_DWORD *)v11 + 4) = v6;
        *(_QWORD *)v5 = v11;
        result = 0LL;
      }
      return result;
    }
  }
  return result;
}
// AB3E: using guessed type int __cdecl ccec_get_cp(_QWORD);
// AB6E: using guessed type int __fastcall ccec_x963_import_priv(_QWORD, _QWORD, _QWORD, _QWORD);
// AB74: using guessed type int __fastcall ccec_x963_import_priv_size(_QWORD, _QWORD, _QWORD, _QWORD);
// AB7A: using guessed type int __fastcall ccec_x963_import_pub(_QWORD, _QWORD, _QWORD, _QWORD);
// AB80: using guessed type int __fastcall ccec_x963_import_pub_size(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000648C) ----------------------------------------------------
signed __int64 __fastcall CCECCryptorExportPublicKey(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax@3

  if ( a1 && a2 )
    result = CCECCryptorExportKey(0, a2, a3, 0, a1);
  else
    result = 4294962996LL;
  return result;
}

//----- (00000000000064B1) ----------------------------------------------------
signed __int64 __fastcall CCECCryptorExportKey(int a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  __int64 v5; // rbx@1
  int v6; // er15@1
  __int64 v7; // r12@1
  signed __int64 result; // rax@1
  bool v9; // r13@5
  __int64 v10; // rax@5
  unsigned __int64 v11; // rcx@5
  bool v12; // cf@5
  bool v13; // zf@5

  v5 = a5;
  v6 = a4;
  v7 = a3;
  result = 4294962996LL;
  if ( a5 )
  {
    if ( a2 )
    {
      result = 4294962991LL;
      if ( a1 != 1 )
      {
        if ( a1 )
        {
          result = 4294962996LL;
        }
        else
        {
          v9 = a4 == 1;
          LODWORD(v10) = ccn_bitlen(***(_QWORD ***)a5, **(_QWORD **)a5 + 16LL);
          v11 = ((unsigned __int64)(v10 + 7) >> 3) * (v9 | 2LL) + 1;
          v12 = v11 < *(_QWORD *)v7;
          v13 = v11 == *(_QWORD *)v7;
          *(_QWORD *)v7 = v11;
          result = 4294962994LL;
          if ( v12 || v13 )
          {
            ccec_x963_export(v6 == 1, a2, *(_QWORD *)v5);
            result = 0LL;
          }
        }
      }
    }
  }
  return result;
}
// AB68: using guessed type int __fastcall ccec_x963_export(_QWORD, _QWORD, _QWORD);
// ABCE: using guessed type int __fastcall ccn_bitlen(_QWORD, _QWORD);

//----- (0000000000006555) ----------------------------------------------------
signed __int64 __usercall CCECCryptorSignHash@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5@<r8>, __int64 a6@<r9>, __int128 a7@<xmm0>, __int128 a8@<xmm1>, __int128 a9@<xmm2>, __int128 a10@<xmm3>, __int128 a11@<xmm4>, __int128 a12@<xmm5>, __int128 a13@<xmm6>, __int128 a14@<xmm7>)
{
  __int64 v14; // r14@1
  __int64 v15; // r15@1
  __int64 v16; // r12@1
  signed __int64 result; // rax@1
  __int64 v18; // rax@5
  int v19; // eax@5
  int v20; // ecx@5
  bool v21; // zf@5

  v14 = a5;
  v15 = a2;
  v16 = a1;
  result = 4294962996LL;
  if ( a3 && a4 && a2 && a5 )
  {
    v18 = ccDRBGGetRngState(a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
    v19 = ccec_sign(*(_QWORD *)a3, v16, a4, v14, v15, v18);
    v20 = v19;
    v21 = v19 == 0;
    result = 4294962992LL;
    if ( v21 )
      result = (unsigned int)v20;
  }
  return result;
}
// AB5C: using guessed type int __fastcall ccec_sign(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000065C2) ----------------------------------------------------
signed __int64 __fastcall CCECCryptorVerifyHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r14@1
  signed __int64 result; // rax@1
  int v8; // eax@4
  int v9; // ecx@4
  bool v10; // zf@4
  unsigned __int8 v11; // [sp+Fh] [bp-11h]@1

  v6 = a6;
  v11 = 0;
  result = 4294962996LL;
  if ( a1 && a2 && a4 )
  {
    v8 = ccec_verify(*(_QWORD *)a1, a3, a2, a5, a4, &v11);
    v9 = v8;
    v10 = v8 == 0;
    result = 4294962992LL;
    if ( v10 )
      result = (unsigned int)v9;
    *(_DWORD *)v6 = v11;
  }
  return result;
}
// AB62: using guessed type int __fastcall ccec_verify(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000006622) ----------------------------------------------------
signed __int64 CCECCryptorWrapKey()
{
  return 4294962991LL;
}

//----- (000000000000662D) ----------------------------------------------------
signed __int64 CCECCryptorUnwrapKey()
{
  return 4294962991LL;
}

//----- (0000000000006638) ----------------------------------------------------
signed __int64 __fastcall CCECCryptorComputeSharedSecret(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  signed __int64 result; // rax@1
  int v5; // eax@4
  int v6; // ecx@4
  bool v7; // zf@4

  result = 4294962996LL;
  if ( a1 && a2 && a3 )
  {
    v5 = ccec_compute_key(*(_QWORD *)a1, *(_QWORD *)a2, a4, a3);
    v6 = v5;
    v7 = v5 == 0;
    result = 4294962992LL;
    if ( v7 )
      result = (unsigned int)v6;
  }
  return result;
}
// AB32: using guessed type int __fastcall ccec_compute_key(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000006672) ----------------------------------------------------
signed __int64 __fastcall CCCryptorGCMAddIV(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax@1
  __int64 v4; // rax@2

  result = 4294962996LL;
  if ( a1 )
  {
    v4 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v4 = a1;
    ccmode_gcm_set_iv(*(_QWORD *)(v4 + 8LL * *(_DWORD *)(v4 + 72) + 104), a3, a2);
    result = 0LL;
  }
  return result;
}
// ABC8: using guessed type int __fastcall ccmode_gcm_set_iv(_QWORD, _QWORD, _QWORD);

//----- (00000000000066A4) ----------------------------------------------------
signed __int64 __fastcall CCCryptorGCMAddAAD(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax@1
  __int64 v4; // rax@2

  result = 4294962996LL;
  if ( a1 )
  {
    v4 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v4 = a1;
    ccmode_gcm_gmac(*(_QWORD *)(v4 + 8LL * *(_DWORD *)(v4 + 72) + 104), a3, a2);
    result = 0LL;
  }
  return result;
}
// ABBC: using guessed type int __fastcall ccmode_gcm_gmac(_QWORD, _QWORD, _QWORD);

//----- (00000000000066D6) ----------------------------------------------------
signed __int64 __fastcall CCCryptorGCMAddADD(__int64 a1, __int64 a2, __int64 a3)
{
  return CCCryptorGCMAddAAD(a1, a2, a3);
}

//----- (00000000000066E0) ----------------------------------------------------
signed __int64 __fastcall CCCryptorGCMaddAAD(__int64 a1, __int64 a2, __int64 a3)
{
  return CCCryptorGCMAddAAD(a1, a2, a3);
}

//----- (00000000000066EA) ----------------------------------------------------
signed __int64 __fastcall CCCryptorGCMEncrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r8@1
  signed __int64 result; // rax@1
  __int64 v6; // rsi@2

  v4 = a2;
  result = 4294962996LL;
  if ( a1 )
  {
    v6 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v6 = a1;
    if ( v4 )
    {
      if ( a4 )
      {
        ccmode_gcm_encrypt(*(_QWORD *)(v6 + 8LL * *(_DWORD *)(v6 + 72) + 104), a3, v4);
        result = 0LL;
      }
    }
  }
  return result;
}
// ABB0: using guessed type int __fastcall ccmode_gcm_encrypt(_QWORD, _QWORD, _QWORD);

//----- (0000000000006726) ----------------------------------------------------
signed __int64 __fastcall CCCryptorGCMDecrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r8@1
  signed __int64 result; // rax@1
  __int64 v6; // rsi@2

  v4 = a2;
  result = 4294962996LL;
  if ( a1 )
  {
    v6 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v6 = a1;
    if ( v4 )
    {
      if ( a4 )
      {
        ccmode_gcm_decrypt(*(_QWORD *)(v6 + 8LL * *(_DWORD *)(v6 + 72) + 104), a3, v4);
        result = 0LL;
      }
    }
  }
  return result;
}
// ABAA: using guessed type int __fastcall ccmode_gcm_decrypt(_QWORD, _QWORD, _QWORD);

//----- (0000000000006762) ----------------------------------------------------
signed __int64 __fastcall CCCryptorGCMFinal(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx@1
  signed __int64 result; // rax@1
  __int64 v5; // rsi@2

  v3 = a2;
  result = 4294962996LL;
  if ( a1 )
  {
    v5 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v5 = a1;
    if ( v3 )
    {
      if ( a3 )
      {
        ccmode_gcm_finalize(*(_QWORD *)(v5 + 8LL * *(_DWORD *)(v5 + 72) + 104), *(_QWORD *)a3, v3);
        result = 0LL;
      }
    }
  }
  return result;
}
// ABB6: using guessed type int __fastcall ccmode_gcm_finalize(_QWORD, _QWORD, _QWORD);

//----- (000000000000679E) ----------------------------------------------------
signed __int64 __fastcall CCCryptorGCMReset(__int64 a1)
{
  signed __int64 result; // rax@1
  __int64 v2; // rax@2

  result = 4294962996LL;
  if ( a1 )
  {
    v2 = *(_QWORD *)a1;
    if ( !*(_QWORD *)a1 )
      v2 = a1;
    ccmode_gcm_reset(*(_QWORD *)(v2 + 8LL * *(_DWORD *)(v2 + 72) + 104));
    result = 0LL;
  }
  return result;
}
// ABC2: using guessed type int __fastcall ccmode_gcm_reset(_QWORD);

//----- (00000000000067C7) ----------------------------------------------------
__int64 __fastcall CCCryptorGCM(unsigned int a1, int a2, __int64 a3, size_t a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13)
{
  __int64 v13; // r14@1
  __int64 v14; // r15@1
  signed int v15; // ebx@1
  signed int v16; // eax@6
  __int64 v18; // [sp+18h] [bp-48h]@0
  void *v19; // [sp+38h] [bp-28h]@1

  v13 = a6;
  v14 = a5;
  LODWORD(v18) = 0;
  v15 = CCCryptorCreateWithMode(a1, 11, a2, 0, 0LL, a3, a4, 0LL, 0LL, v18, 0, (__int64)&v19);
  if ( !v15 )
  {
    if ( !v13 || (v15 = CCCryptorGCMAddIV((__int64)v19, v14, v13)) == 0 )
    {
      v15 = CCCryptorGCMAddAAD((__int64)v19, a7, a8);
      if ( !v15 )
      {
        if ( a1 == 1 )
        {
          v16 = CCCryptorGCMDecrypt((__int64)v19, a9, a10, a11);
        }
        else
        {
          v15 = -4300;
          if ( a1 )
            return (unsigned int)v15;
          v16 = CCCryptorGCMEncrypt((__int64)v19, a9, a10, a11);
        }
        v15 = v16;
        if ( !v16 )
        {
          v15 = CCCryptorGCMFinal((__int64)v19, a12, a13);
          CCCryptorRelease(v19);
        }
      }
    }
  }
  return (unsigned int)v15;
}

//----- (00000000000068C7) ----------------------------------------------------
void __fastcall CCHmacInit(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r14@1
  __int64 v5; // r15@1
  __int64 v6; // rax@2

  v4 = a4;
  v5 = a3;
  if ( a1 )
  {
    __bzero(a1);
    v6 = convertccHmacSelector(a2);
    *(_QWORD *)a1 = v6;
    if ( v6 )
      cchmac_init(v6, a1 + 8, v4, v5);
  }
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);
// AB98: using guessed type int __fastcall cchmac_init(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000006926) ----------------------------------------------------
__int64 __fastcall convertccHmacSelector(int a1)
{
  unsigned int *v1; // rax@1
  signed int v2; // ecx@1

  v1 = (unsigned int *)&dword_CCA4;
  v2 = 0;
  while ( *(v1 - 1) != a1 )
  {
    v1 += 4;
    ++v2;
    if ( v2 > 5 )
      return 0LL;
  }
  return CCDigestGetDigestInfo(*v1);
}
// CCA4: using guessed type int dword_CCA4;

//----- (000000000000694F) ----------------------------------------------------
int __fastcall CCHmacUpdate(__int64 a1, __int64 a2, __int64 a3)
{
  return cchmac_update(*(_QWORD *)a1, a1 + 8, a3, a2);
}
// AB9E: using guessed type int __fastcall cchmac_update(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000006969) ----------------------------------------------------
int __fastcall CCHmacFinal(__int64 a1, __int64 a2)
{
  return cchmac_final(*(_QWORD *)a1, a1 + 8, a2);
}
// AB92: using guessed type int __fastcall cchmac_final(_QWORD, _QWORD, _QWORD);

//----- (0000000000006983) ----------------------------------------------------
void __fastcall CCHmacDestroy(void *a1)
{
  __bzero(a1);
  free(a1);
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);

//----- (00000000000069A4) ----------------------------------------------------
__int64 __fastcall CCHmacOutputSizeFromRef(__int64 a1)
{
  return **(_QWORD **)a1;
}

//----- (00000000000069B0) ----------------------------------------------------
signed __int64 __fastcall CCHmacOutputSize(unsigned int a1)
{
  return CCDigestGetOutputSize(a1);
}

//----- (00000000000069BA) ----------------------------------------------------
int __fastcall CCHmac(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r14@1
  __int64 v7; // r12@1
  __int64 v8; // r15@1
  __int64 v9; // rbx@1
  __int64 v10; // rax@1

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = convertccHmacSelector(a1);
  return cchmac(v10, v9, a2, v7, v8, v6);
}
// AB8C: using guessed type int __fastcall cchmac(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000006A01) ----------------------------------------------------
void *__fastcall CCHmacCreate(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14@1
  void *v4; // rbx@1
  void *result; // rax@1
  __int64 v6; // rax@2

  v3 = a3;
  v4 = malloc(0x158uLL);
  result = 0LL;
  if ( v4 )
  {
    __bzero(v4);
    v6 = CCDigestGetDigestInfo(a1);
    *(_QWORD *)v4 = v6;
    if ( v6 )
    {
      cchmac_init(v6, (char *)v4 + 8, v3, a2);
      result = v4;
    }
    else
    {
      free(v4);
      result = 0LL;
    }
  }
  return result;
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);
// AB98: using guessed type int __fastcall cchmac_init(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000006A70) ----------------------------------------------------
int __fastcall CCHmacOneShot(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r14@1
  __int64 v7; // r12@1
  __int64 v8; // r15@1
  __int64 v9; // rbx@1
  __int64 v10; // rax@1

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = CCDigestGetDigestInfo(a1);
  return cchmac(v10, v9, a2, v7, v8, v6);
}
// AB8C: using guessed type int __fastcall cchmac(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000006AB7) ----------------------------------------------------
void *__fastcall CCHmacClone(void *a1)
{
  void *v1; // rbx@1
  void *result; // rax@1

  v1 = malloc(0x158uLL);
  result = 0LL;
  if ( v1 )
  {
    memcpy(v1, a1, 0x158uLL);
    result = v1;
  }
  return result;
}

//----- (0000000000006AF0) ----------------------------------------------------
__int64 __fastcall CCKeyDerivationPBKDF(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, unsigned int a7, __int64 a8, __int64 a9)
{
  __int64 v9; // r15@1
  __int64 v10; // r14@1
  __int64 v11; // r13@1
  signed int v12; // ebx@1
  unsigned int v13; // edi@3
  __int64 v14; // rax@8

  v9 = a5;
  v10 = a4;
  v11 = a3;
  v12 = -1;
  if ( a1 == 2 )
  {
    switch ( a6 )
    {
      case 1:
        v13 = 8;
        goto LABEL_8;
      case 2:
        v13 = 9;
        goto LABEL_8;
      case 3:
        v13 = 10;
        goto LABEL_8;
      case 4:
        v13 = 11;
        goto LABEL_8;
      case 5:
        v13 = 12;
LABEL_8:
        v14 = CCDigestGetDigestInfo(v13);
        if ( a9 && a8 != 0 && v10 != 0 && a2 != 0 && a7 )
        {
          ccpbkdf2_hmac(v14, v11, a2, v9, v10, a7);
          v12 = 0;
        }
        break;
      default:
        return (unsigned int)v12;
    }
  }
  return (unsigned int)v12;
}
// AC46: using guessed type int __fastcall ccpbkdf2_hmac(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000006BD4) ----------------------------------------------------
signed __int64 __fastcall CCCalibratePBKDF(int a1, unsigned __int64 a2, size_t a3, int a4, size_t a5, int a6)
{
  int v6; // er13@1
  size_t v7; // r12@1
  size_t v8; // r14@1
  signed __int64 result; // rax@1
  size_t v10; // rbx@3
  void *v11; // rax@6
  size_t v12; // rdx@7
  void *v13; // rbx@9
  void *v14; // r15@9
  __int64 v15; // rax@10
  signed __int64 v16; // rbx@12
  uint64_t v17; // r13@14
  uint64_t v18; // rax@15
  uint64_t v19; // rcx@15
  void *v20; // rbx@19
  int v21; // [sp+1Ch] [bp-54h]@13
  unsigned __int64 v22; // [sp+20h] [bp-50h]@12
  void *v23; // [sp+28h] [bp-48h]@12
  __int64 v24; // [sp+30h] [bp-40h]@7
  void *v25; // [sp+38h] [bp-38h]@10
  int v26; // [sp+44h] [bp-2Ch]@1

  v6 = a6;
  v7 = a5;
  v26 = a4;
  v8 = a3;
  result = 0xFFFFFFFFLL;
  if ( !a5 || a3 - 1 > 0x83 )
    return result;
  v10 = 1LL;
  if ( a2 )
    v10 = a2;
  if ( a1 != 2 )
    return result;
  v11 = malloc(v10);
  if ( !v11 )
    return 0xFFFFFFFFLL;
  v24 = v10;
  v12 = 1LL;
  if ( a2 > 1 )
    v12 = a2;
  v13 = v11;
  memset(v11, 97, v12);
  v14 = malloc(v8);
  if ( !v14 )
  {
    free(v13);
    return 0xFFFFFFFFLL;
  }
  v25 = v13;
  v15 = 0LL;
  if ( v8 )
  {
    do
    {
      *((_BYTE *)v14 + v15) = v15;
      ++v15;
    }
    while ( v8 != v15 );
  }
  v23 = malloc(v7);
  v22 = 0xFFFFFFFFLL;
  v16 = 1LL;
  if ( v23 )
  {
    v21 = v6;
    while ( 1 )
    {
      v17 = timer();
      if ( (unsigned int)CCKeyDerivationPBKDF(2, (__int64)v25, v24, (__int64)v14, v8, v26, 0x186A0u, (__int64)v23, v7) )
        break;
      v18 = timer();
      v19 = v18;
      if ( (unsigned __int64)v16 <= 4 )
      {
        ++v16;
        if ( v18 == v17 )
          continue;
      }
      result = 123456LL;
      if ( v19 == v17 )
        return result;
      v22 = (unsigned int)(100000 * v21) / (v19 - v17);
      break;
    }
    v20 = v23;
  }
  else
  {
    v20 = 0LL;
  }
  free(v25);
  if ( v14 )
    free(v14);
  if ( v20 )
    free(v20);
  return v22;
}

//----- (0000000000006D6C) ----------------------------------------------------
uint64_t timer()
{
  __int64 v0; // rbx@2
  __int64 v2; // rax@6

  if ( *(_QWORD *)(_os_alloc_once_table_ptr[0] + 96) == -1LL )
  {
    v0 = *(_QWORD *)(_os_alloc_once_table_ptr[0] + 104);
  }
  else
  {
    LODWORD(v2) = _os_alloc_once(_os_alloc_once_table_ptr[0] + 96, 3376LL, 0LL);
    v0 = v2;
  }
  if ( !*(_DWORD *)(v0 + 2228) )
    mach_timebase_info((mach_timebase_info_t)(v0 + 2224));
  return mach_absolute_time() * *(_DWORD *)(v0 + 2224) / (unsigned int)(1000000 * *(_DWORD *)(v0 + 2228));
}
// AA12: using guessed type int __fastcall _os_alloc_once(_QWORD, _QWORD, _QWORD);
// C020: using guessed type __int64 _os_alloc_once_table_ptr[174];

//----- (0000000000006DD6) ----------------------------------------------------
__int64 __usercall ccDevRandomGetRngState@<rax>(__int64 a1@<r8>, __int64 a2@<r9>, __int128 a3@<xmm0>, __int128 a4@<xmm1>, __int128 a5@<xmm2>, __int128 a6@<xmm3>, __int128 a7@<xmm4>, __int128 a8@<xmm5>, __int128 a9@<xmm6>, __int128 a10@<xmm7>)
{
  __int64 v10; // rbx@2
  __int64 result; // rax@4
  __int64 v12; // rax@6
  __int64 v13; // [sp+0h] [bp-30h]@3
  int v14; // [sp+8h] [bp-28h]@3
  int v15; // [sp+Ch] [bp-24h]@3
  int (__fastcall *v16)(__int64); // [sp+10h] [bp-20h]@3
  __int64 *v17; // [sp+18h] [bp-18h]@3
  __int64 v18; // [sp+20h] [bp-10h]@3

  if ( *(_QWORD *)(_os_alloc_once_table_ptr[0] + 96) == -1LL )
  {
    v10 = *(_QWORD *)(_os_alloc_once_table_ptr[0] + 104);
  }
  else
  {
    LODWORD(v12) = _os_alloc_once(_os_alloc_once_table_ptr[0] + 96, 3376LL, 0LL);
    v10 = v12;
  }
  v13 = _NSConcreteStackBlock_ptr[0];
  v14 = 0x40000000;
  v15 = 0;
  v16 = __ccDevRandomGetRngState_block_invoke;
  v17 = &__block_descriptor_tmp_4;
  v18 = v10;
  if ( *(_QWORD *)(v10 + 2128) != -1LL )
    dispatch_once(v10 + 2128, &v13);
  result = *(_QWORD *)(v10 + 2152);
  if ( !result )
  {
    ccdebug_imp(
      2,
      0,
      "Init DevRandom state error, status (%d). aborting\n",
      *(_DWORD *)(v10 + 2176),
      (__int64)"ccDevRandomGetRngState",
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      a10,
      v13);
    abort();
  }
  return result;
}
// AA12: using guessed type int __fastcall _os_alloc_once(_QWORD, _QWORD, _QWORD);
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// C020: using guessed type __int64 _os_alloc_once_table_ptr[174];
// CD10: using guessed type __int64 __block_descriptor_tmp_4;

//----- (0000000000006E93) ----------------------------------------------------
int __fastcall __ccDevRandomGetRngState_block_invoke(__int64 a1)
{
  __int64 v1; // rbx@1
  __int64 v2; // rax@1
  __int64 v3; // rcx@1

  v1 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(v1 + 2144) = 2;
  *(_QWORD *)(v1 + 2152) = malloc(0x10uLL);
  LODWORD(v2) = ccrng_system_init(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 2152LL));
  v3 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(v3 + 2176) = v2;
  if ( (signed int)v2 < 0 )
  {
    free(*(void **)(v3 + 2152));
    v2 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(v2 + 2152) = 0LL;
  }
  return v2;
}
// AC58: using guessed type int __fastcall ccrng_system_init(_QWORD);

//----- (0000000000006EFA) ----------------------------------------------------
__int64 __usercall ccDRBGGetRngState@<rax>(__int64 a1@<r8>, __int64 a2@<r9>, __int128 a3@<xmm0>, __int128 a4@<xmm1>, __int128 a5@<xmm2>, __int128 a6@<xmm3>, __int128 a7@<xmm4>, __int128 a8@<xmm5>, __int128 a9@<xmm6>, __int128 a10@<xmm7>)
{
  __int64 v10; // rbx@2
  __int64 result; // rax@4
  __int64 v12; // rax@6
  __int64 v13; // [sp+0h] [bp-30h]@3
  int v14; // [sp+8h] [bp-28h]@3
  int v15; // [sp+Ch] [bp-24h]@3
  int (__fastcall *v16)(__int64); // [sp+10h] [bp-20h]@3
  __int64 *v17; // [sp+18h] [bp-18h]@3
  __int64 v18; // [sp+20h] [bp-10h]@3

  if ( *(_QWORD *)(_os_alloc_once_table_ptr[0] + 96) == -1LL )
  {
    v10 = *(_QWORD *)(_os_alloc_once_table_ptr[0] + 104);
  }
  else
  {
    LODWORD(v12) = _os_alloc_once(_os_alloc_once_table_ptr[0] + 96, 3376LL, 0LL);
    v10 = v12;
  }
  v13 = _NSConcreteStackBlock_ptr[0];
  v14 = 0x40000000;
  v15 = 0;
  v16 = __ccDRBGGetRngState_block_invoke;
  v17 = &__block_descriptor_tmp2;
  v18 = v10 + 2184;
  if ( *(_QWORD *)(v10 + 2136) != -1LL )
    dispatch_once(v10 + 2136, &v13);
  result = *(_QWORD *)(v10 + 2192);
  if ( !result )
  {
    ccdebug_imp(
      2,
      0,
      "Init DRBG state error, status (%d). aborting\n",
      *(_DWORD *)(v10 + 2216),
      (__int64)"ccDRBGGetRngState",
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      a10,
      v13);
    abort();
  }
  return result;
}
// AA12: using guessed type int __fastcall _os_alloc_once(_QWORD, _QWORD, _QWORD);
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// C020: using guessed type __int64 _os_alloc_once_table_ptr[174];
// CD50: using guessed type __int64 __block_descriptor_tmp2;

//----- (0000000000006FBE) ----------------------------------------------------
int __fastcall __ccDRBGGetRngState_block_invoke(__int64 a1)
{
  __int64 v1; // r14@1
  __int64 v2; // r14@1
  __int64 v3; // rax@1
  __int64 v4; // rcx@1

  v1 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)v1 = 1;
  *(_QWORD *)(v1 + 16) = calloc(1uLL, 0x30uLL);
  ccdrbg_factory_nistctr(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16LL), &DRBGcustom);
  v2 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v2 + 24) = calloc(1uLL, **(_QWORD **)(v2 + 16));
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8LL) = calloc(1uLL, 0x28uLL);
  LODWORD(v3) = ccrng_CommonCrypto_init(
                  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8LL),
                  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16LL),
                  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24LL),
                  0LL);
  v4 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(v4 + 32) = v3;
  if ( (_DWORD)v3 )
  {
    free(*(void **)(v4 + 24));
    free(*(void **)(*(_QWORD *)(a1 + 32) + 8LL));
    free(*(void **)(*(_QWORD *)(a1 + 32) + 16LL));
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16LL) = 0LL;
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8LL) = 0LL;
    v3 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(v3 + 24) = 0LL;
  }
  return v3;
}
// AB2C: using guessed type int __fastcall ccdrbg_factory_nistctr(_QWORD, _QWORD);
// AC52: using guessed type int __fastcall ccrng_CommonCrypto_init(_QWORD, _QWORD, _QWORD, _QWORD);
// CD30: using guessed type __int64 *DRBGcustom;

//----- (0000000000007098) ----------------------------------------------------
__int64 __usercall CCRNGCreate@<rax>(unsigned int a1@<edi>, __int64 a2@<rsi>, __int128 a3@<xmm0>, __int128 a4@<xmm1>, __int128 a5@<xmm2>, __int128 a6@<xmm3>, __int128 a7@<xmm6>, __int128 a8@<xmm7>)
{
  void *v8; // r12@1
  signed int v9; // er15@1
  void *v10; // rax@2
  size_t *v11; // r14@2
  void *v12; // r13@3
  void *v13; // rax@4
  int v14; // eax@5
  __int64 v15; // r8@5
  __int64 v16; // r9@5
  __int128 v17; // xmm4@5
  __int128 v18; // xmm5@5
  char v21; // [sp+0h] [bp-50h]@0
  __int64 v22; // [sp+10h] [bp-40h]@2
  __int64 v23; // [sp+18h] [bp-38h]@2
  int v24; // [sp+20h] [bp-30h]@2
  int v25; // [sp+24h] [bp-2Ch]@2

  v8 = malloc(0x28uLL);
  v9 = -4302;
  if ( !v8 )
    return (unsigned int)v9;
  v22 = ccaes_ltc_ecb_encrypt_mode_ptr[0];
  v23 = 16LL;
  v24 = 1;
  v25 = 1;
  *(_DWORD *)v8 = 99;
  v10 = malloc(0x30uLL);
  v11 = (size_t *)v10;
  *((_QWORD *)v8 + 2) = v10;
  if ( !v10 )
    goto LABEL_13;
  ccdrbg_factory_nistctr(v10, &v22);
  v12 = malloc(*v11);
  *((_QWORD *)v8 + 3) = v12;
  if ( !v12 )
  {
LABEL_10:
    if ( v12 )
      free(v12);
    free(*((void **)v8 + 2));
    goto LABEL_13;
  }
  v13 = malloc(0x28uLL);
  *((_QWORD *)v8 + 1) = v13;
  if ( !v13 )
  {
    if ( v11 )
      goto LABEL_10;
LABEL_13:
    free(v8);
    *(_QWORD *)a2 = 0LL;
    return (unsigned int)v9;
  }
  v14 = ccrng_CommonCrypto_init(v13, v11, v12, a1);
  *((_DWORD *)v8 + 8) = v14;
  if ( v14 )
  {
    ccdebug_imp(
      2,
      0,
      "Init DRBG error, status (%d). aborting\n",
      (unsigned int)v14,
      (__int64)"ccInitDRBG",
      v15,
      v16,
      a3,
      a4,
      a5,
      a6,
      v17,
      v18,
      a7,
      a8,
      v21);
    abort();
  }
  *(_QWORD *)a2 = v8;
  v9 = 0;
  return (unsigned int)v9;
}
// AB2C: using guessed type int __fastcall ccdrbg_factory_nistctr(_QWORD, _QWORD);
// AC52: using guessed type int __fastcall ccrng_CommonCrypto_init(_QWORD, _QWORD, _QWORD, _QWORD);
// C028: using guessed type __int64 ccaes_ltc_ecb_encrypt_mode_ptr[173];

//----- (00000000000071E0) ----------------------------------------------------
__int64 __fastcall CCRNGRelease(void *a1)
{
  if ( *(_DWORD *)a1 == 99 )
  {
    ccrng_CommonCrypto_done(*((_QWORD *)a1 + 1));
    free(a1);
  }
  return 0LL;
}
// AC4C: using guessed type int __fastcall ccrng_CommonCrypto_done(_QWORD);

//----- (0000000000007208) ----------------------------------------------------
int __usercall CCRandomCopyBytes@<eax>(__int64 a1@<rdx>, __int64 a2@<rdi>, __int64 a3@<rsi>, __int64 a4@<r8>, __int64 a5@<r9>, __int128 a6@<xmm0>, __int128 a7@<xmm1>, __int128 a8@<xmm2>, __int128 a9@<xmm3>, __int128 a10@<xmm4>, __int128 a11@<xmm5>, __int128 a12@<xmm6>, __int128 a13@<xmm7>)
{
  __int64 v13; // r14@1
  signed int v14; // er15@1
  __int64 v15; // r13@6
  signed int v16; // ebx@6
  __int64 v19; // rax@11

  v13 = a1;
  v14 = -1;
  if ( !a3 )
    return v14;
  v14 = 0;
  if ( !a1 )
    return v14;
  if ( a2 )
  {
    if ( *(_DWORD *)a2 == 99 )
      return (**(int (__fastcall ***)(_QWORD, _QWORD, _QWORD))(a2 + 8))(a2, a1, a3);
    if ( *(_DWORD *)a2 == 2 )
    {
      v15 = ccDevRandomGetRngState(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
      v16 = -4;
      do
      {
        if ( !(*(int (__fastcall **)(__int64, __int64, __int64))v15)(v15, v13, a3) )
          break;
      }
      while ( v16++ != 0 );
      return v14;
    }
  }
  v19 = ccDRBGGetRngState(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
  return (*(int (__fastcall **)(__int64, __int64, __int64))v19)(v19, v13, a3);
}

//----- (00000000000072BA) ----------------------------------------------------
__int64 __usercall CCRandomGenerateBytes@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r8>, __int64 a4@<r9>, __int128 a5@<xmm0>, __int128 a6@<xmm1>, __int128 a7@<xmm2>, __int128 a8@<xmm3>, __int128 a9@<xmm4>, __int128 a10@<xmm5>, __int128 a11@<xmm6>, __int128 a12@<xmm7>)
{
  int v12; // eax@1
  signed int v13; // ecx@1

  v12 = CCRandomCopyBytes(a2, (__int64)ccRandomDefaultStruct, a1, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
  v13 = -4307;
  if ( !v12 )
    v13 = 0;
  return (unsigned int)v13;
}
// BA28: using guessed type __int64 ccRandomDefaultStruct[5];

//----- (00000000000072E4) ----------------------------------------------------
__int64 __usercall CCRSACryptorGeneratePair@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, unsigned int a4@<esi>, __int64 a5@<r8>, __int64 a6@<r9>, __int128 a7@<xmm0>, __int128 a8@<xmm1>, __int128 a9@<xmm2>, __int128 a10@<xmm3>, __int128 a11@<xmm4>, __int128 a12@<xmm5>, __int128 a13@<xmm6>, __int128 a14@<xmm7>)
{
  __int64 v14; // r12@1
  __int64 v15; // r15@1
  __int64 v16; // r8@1
  __int64 v17; // r9@1
  __int128 v18; // xmm4@1
  __int128 v19; // xmm5@1
  __int64 v20; // rax@1
  __int64 v21; // r13@1
  char *v22; // r14@1
  __int64 v23; // rbx@1
  signed int v24; // er15@1
  __int64 v25; // rdi@2
  unsigned __int64 v26; // rax@2
  void *v27; // rax@3
  void *v28; // r12@3
  int v29; // eax@4
  __int64 v30; // r13@5
  int v31; // ecx@5
  unsigned __int64 v32; // r15@8
  int v33; // eax@12
  void *v34; // rdi@14
  __int64 result; // rax@18
  __int64 v36; // [sp+0h] [bp-670h]@1
  __int64 v37; // [sp+8h] [bp-668h]@1
  __int64 v38; // [sp+10h] [bp-660h]@1
  __int64 v39; // [sp+18h] [bp-658h]@1
  __int64 *v40; // [sp+20h] [bp-650h]@1
  __int64 v41; // [sp+28h] [bp-648h]@1
  unsigned __int64 v42; // [sp+30h] [bp-640h]@10
  unsigned __int64 v43; // [sp+38h] [bp-638h]@8
  char v44; // [sp+40h] [bp-630h]@10
  char v45; // [sp+240h] [bp-430h]@8
  char v46; // [sp+440h] [bp-230h]@8
  __int64 v47; // [sp+640h] [bp-30h]@1

  v14 = a2;
  v39 = a2;
  v15 = a1;
  v40 = (__int64 *)a1;
  v38 = a3;
  v47 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v37 = ccDRBGGetRngState(a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  v36 = ccDevRandomGetRngState(v16, v17, a7, a8, a9, a10, v18, v19, a13, a14);
  v41 = a4;
  LODWORD(v20) = ccn_write_int_size(1LL, &v41);
  v21 = v20;
  v22 = (char *)&v36 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  ccn_write_int(1LL, &v41, v20, v22);
  *(_QWORD *)v14 = 0LL;
  *(_QWORD *)v15 = 0LL;
  v23 = (__int64)malloc(0x7890uLL);
  v24 = -4302;
  if ( !v23 )
    goto LABEL_17;
  v25 = v38;
  v26 = (unsigned __int64)(v38 + 63) >> 6;
  *(_QWORD *)(v23 + 30848) = v38;
  *(_QWORD *)v23 = v26;
  v24 = -4304;
  if ( ccrsa_generate_931_key(v25, v23, v21, v22, v37, v36)
    || (*(_DWORD *)(v23 + 30856) = 1, v27 = CCRSACryptorGetPublicKeyFromPrivateKey(v23), v28 = v27, v24 = -4302, !v27) )
  {
    v34 = (void *)v23;
    goto LABEL_16;
  }
  *v40 = (__int64)v27;
  *(_QWORD *)v39 = v23;
  v29 = *(_DWORD *)(v23 + 30848) / 8;
  if ( (unsigned int)v29 > 0x200 )
    goto LABEL_22;
  v30 = *v40;
  v31 = -537;
  if ( *v40 )
    v31 = *(_DWORD *)(v30 + 30848) / 8;
  if ( v29 != v31
    || (v32 = v29,
        __memset_chk(&v46, 10LL, v29, 512LL),
        v43 = v32,
        (unsigned int)CCRSACryptorCrypt(v23, (__int64)&v46, v32, (__int64)&v45, (__int64)&v43))
    || !memcmp(&v46, &v45, v32)
    || (v42 = v32, (unsigned int)CCRSACryptorCrypt(v30, (__int64)&v45, v43, (__int64)&v44, (__int64)&v42))
    || v42 != v32
    || (v33 = memcmp(&v46, &v44, v32), v24 = 0, v33) )
  {
LABEL_22:
    ccRSACryptorClear((void *)v23);
    v24 = -4304;
    if ( !v28 )
    {
LABEL_17:
      *(_QWORD *)v39 = 0LL;
      *v40 = 0LL;
      goto LABEL_18;
    }
    v34 = v28;
LABEL_16:
    ccRSACryptorClear(v34);
    goto LABEL_17;
  }
LABEL_18:
  result = *(_QWORD *)__stack_chk_guard_ptr[0];
  if ( *(_QWORD *)__stack_chk_guard_ptr[0] == v47 )
    result = (unsigned int)v24;
  return result;
}
// AA2A: using guessed type int __fastcall __memset_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// ABDA: using guessed type int __fastcall ccn_write_int(_QWORD, _QWORD, _QWORD, _QWORD);
// ABE0: using guessed type int __fastcall ccn_write_int_size(_QWORD, _QWORD);
// AC82: using guessed type int __fastcall ccrsa_generate_931_key(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (000000000000758B) ----------------------------------------------------
void *__fastcall CCRSACryptorGetPublicKeyFromPrivateKey(__int64 a1)
{
  __int64 v1; // r15@1
  void *v2; // rbx@1
  void *result; // rax@1

  v1 = *(_QWORD *)(a1 + 30848);
  v2 = malloc(0x7890uLL);
  result = 0LL;
  if ( v2 )
  {
    *((_QWORD *)v2 + 3856) = v1;
    *(_QWORD *)v2 = (unsigned __int64)(v1 + 63) >> 6;
    ccrsa_init_pub(v2, a1 + 16, 16LL * *(_QWORD *)a1 + a1 + 24);
    *((_DWORD *)v2 + 7714) = 0;
    result = v2;
  }
  return result;
}
// AC9A: using guessed type int __fastcall ccrsa_init_pub(_QWORD, _QWORD, _QWORD);

//----- (00000000000075F5) ----------------------------------------------------
void __fastcall ccRSACryptorClear(void *a1)
{
  if ( a1 )
  {
    __bzero(a1);
    free(a1);
  }
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);

//----- (0000000000007625) ----------------------------------------------------
signed __int64 __fastcall CCRSAGetKeyType(__int64 a1)
{
  signed __int64 result; // rax@1
  unsigned int v2; // ecx@2

  result = 99LL;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 30856);
    result = 99LL;
    if ( v2 <= 1 )
      result = v2;
  }
  return result;
}

//----- (0000000000007646) ----------------------------------------------------
signed __int64 __fastcall CCRSAGetKeySize(__int64 a1)
{
  signed __int64 result; // rax@1

  result = 4294962996LL;
  if ( a1 )
    result = *(_DWORD *)(a1 + 30848);
  return result;
}

//----- (000000000000765C) ----------------------------------------------------
void __fastcall CCRSACryptorRelease(void *a1)
{
  ccRSACryptorClear(a1);
}

//----- (0000000000007666) ----------------------------------------------------
signed __int64 __fastcall CCRSACryptorImport(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14@1
  signed __int64 result; // rax@1
  __int64 v5; // rax@3
  __int64 v6; // r12@3
  __int64 v7; // rax@5
  void *v8; // rax@7
  void *v9; // rbx@7
  __int64 v10; // rax@9
  __int64 v11; // rax@14
  __int64 v12; // [sp+8h] [bp-38h]@4
  signed int v13; // [sp+14h] [bp-2Ch]@4

  v3 = a3;
  result = 4294962996LL;
  if ( a1 && a3 )
  {
    LODWORD(v5) = ccder_decode_rsa_priv_n(a1, a1 + a2);
    v6 = v5;
    if ( v5 )
    {
      v12 = a1 + a2;
      v13 = 1;
    }
    else
    {
      LODWORD(v7) = ccder_decode_rsa_pub_n(a1, a1 + a2);
      v6 = v7;
      result = 4294962992LL;
      if ( !v6 )
        return result;
      v12 = a1 + a2;
      v13 = 0;
    }
    v8 = malloc(0x7890uLL);
    v9 = v8;
    if ( !v8 )
    {
      *(_QWORD *)v3 = 0LL;
      return 4294962994LL;
    }
    *((_QWORD *)v8 + 3856) = 4096LL;
    *(_QWORD *)v8 = 64LL;
    if ( v13 )
    {
      *(_QWORD *)v8 = v6;
      LODWORD(v10) = ccder_decode_rsa_priv(v8, a1, v12);
      if ( !v10 )
        goto LABEL_13;
    }
    else
    {
      *(_QWORD *)v8 = v6;
      if ( ccrsa_import_pub(v8, a2, a1) )
      {
LABEL_13:
        ccRSACryptorClear(v9);
        return 4294962992LL;
      }
    }
    *((_DWORD *)v9 + 7714) = v13;
    *(_QWORD *)v3 = v9;
    LODWORD(v11) = ccn_bitlen(*(_QWORD *)v9, (char *)v9 + 16);
    *((_QWORD *)v9 + 3856) = v11;
    result = 0LL;
  }
  return result;
}
// AAC0: using guessed type int __fastcall ccder_decode_rsa_priv(_QWORD, _QWORD, _QWORD);
// AAC6: using guessed type int __fastcall ccder_decode_rsa_priv_n(_QWORD, _QWORD);
// AACC: using guessed type int __fastcall ccder_decode_rsa_pub_n(_QWORD, _QWORD);
// ABCE: using guessed type int __fastcall ccn_bitlen(_QWORD, _QWORD);
// AC94: using guessed type int __fastcall ccrsa_import_pub(_QWORD, _QWORD, _QWORD);

//----- (000000000000778A) ----------------------------------------------------
signed __int64 __fastcall CCRSACryptorExport(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // r15@1
  signed __int64 result; // rax@1
  int v5; // eax@3
  unsigned __int64 v6; // rax@4
  unsigned __int64 v7; // rcx@4
  bool v8; // cf@4
  __int64 v9; // rax@5
  __int64 v10; // rcx@5
  signed int v11; // edx@5
  unsigned __int64 v12; // rax@8
  unsigned __int64 v13; // rcx@8
  unsigned __int64 v14; // rdx@8
  int v15; // ecx@9

  v3 = a3;
  result = 4294962996LL;
  if ( a1 && a2 )
  {
    v5 = *(_DWORD *)(a1 + 30856);
    if ( v5 == 1 )
    {
      LODWORD(v6) = ccder_encode_rsa_priv_size(a1);
      v7 = v6;
      v8 = *v3 < v6;
      *v3 = v6;
      result = 4294962995LL;
      if ( !v8 )
      {
        LODWORD(v9) = ccder_encode_rsa_priv(a1, a2, a2 + v7);
        v10 = v9;
        result = 4294962992LL;
        v11 = 0;
        if ( v10 == a2 )
          return (unsigned int)v11;
      }
    }
    else
    {
      v11 = -4300;
      if ( v5 )
        return (unsigned int)v11;
      LODWORD(v12) = ccder_encode_rsa_pub_size(a1, a2, 4294962996LL);
      v13 = v12;
      v14 = *v3;
      *v3 = v12;
      result = 4294962995LL;
      if ( v14 > v13 )
      {
        v15 = ccrsa_export_pub(a1, v13, a2);
        result = 4294962992LL;
        v11 = 0;
        if ( !v15 )
          return (unsigned int)v11;
      }
    }
  }
  return result;
}
// AAD2: using guessed type int __fastcall ccder_encode_rsa_priv(_QWORD, _QWORD, _QWORD);
// AAD8: using guessed type int __cdecl ccder_encode_rsa_priv_size(_QWORD);
// AADE: using guessed type int __fastcall ccder_encode_rsa_pub_size(_QWORD, _QWORD, _QWORD);
// AC7C: using guessed type int __fastcall ccrsa_export_pub(_QWORD, _QWORD, _QWORD);

//----- (0000000000007845) ----------------------------------------------------
signed __int64 __usercall CCRSACryptorEncrypt@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, int a4@<esi>, __int64 a5@<r8>, __int64 a6@<r9>, __int128 a7@<xmm0>, __int128 a8@<xmm1>, __int128 a9@<xmm2>, __int128 a10@<xmm3>, __int128 a11@<xmm4>, __int128 a12@<xmm5>, __int128 a13@<xmm6>, __int128 a14@<xmm7>, __int64 a15, __int64 a16, unsigned int a17)
{
  __int64 v17; // r15@1
  __int64 v18; // r12@1
  __int64 v19; // r14@1
  __int64 v20; // r13@1
  signed __int64 result; // rax@1
  __int64 v22; // ST20_8@6
  __int64 v23; // r8@6
  __int64 v24; // r9@6
  __int128 v25; // xmm4@6
  __int128 v26; // xmm5@6
  __int64 v27; // rax@6
  int v28; // eax@6
  signed int v29; // ecx@6
  __int64 v30; // rax@10
  int v31; // eax@10
  int v32; // ecx@10
  bool v33; // zf@10

  v17 = a6;
  v18 = a5;
  v19 = a2;
  v20 = a1;
  result = 4294962996LL;
  if ( a3 && a5 && a1 && a6 )
  {
    if ( a4 == 1002 )
    {
      v22 = CCDigestGetDigestInfo(a17);
      v27 = ccDRBGGetRngState(v23, v24, a7, a8, a9, a10, v25, v26, a13, a14);
      v28 = ccrsa_encrypt_oaep(a3, v22, v27, v17, v18, v19);
      v29 = -4304;
      if ( !v28 )
        v29 = 0;
      result = (unsigned int)v29;
    }
    else if ( a4 == 1001 )
    {
      v30 = ccDRBGGetRngState(a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
      v31 = ccrsa_encrypt_eme_pkcs1v15(a3, v30, v17, v18, v19, v20);
      v32 = v31;
      v33 = v31 == 0;
      result = 4294962992LL;
      if ( v33 )
        result = (unsigned int)v32;
    }
  }
  return result;
}
// AC70: using guessed type int __fastcall ccrsa_encrypt_eme_pkcs1v15(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// AC76: using guessed type int __fastcall ccrsa_encrypt_oaep(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000007922) ----------------------------------------------------
signed __int64 __fastcall CCRSACryptorDecrypt(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned int a9)
{
  __int64 v9; // r12@1
  __int64 v10; // r15@1
  __int64 v11; // r14@1
  __int64 v12; // r13@1
  signed __int64 result; // rax@1
  __int64 v14; // rax@6
  int v15; // eax@6
  signed int v16; // ecx@6
  int v17; // eax@10
  int v18; // ecx@10
  bool v19; // zf@10

  v9 = a6;
  v10 = a5;
  v11 = a4;
  v12 = a3;
  result = 4294962996LL;
  if ( a1 && a3 && a5 && a6 )
  {
    if ( a2 == 1002 )
    {
      v14 = CCDigestGetDigestInfo(a9);
      v15 = ccrsa_decrypt_oaep(a1, v14, v9, v10, v11, v12);
      v16 = -4304;
      if ( !v15 )
        v16 = 0;
      result = (unsigned int)v16;
    }
    else
    {
      result = 0LL;
      if ( a2 == 1001 )
      {
        v17 = ccrsa_decrypt_eme_pkcs1v15(a1, a6, a5, a4, a3);
        v18 = v17;
        v19 = v17 == 0;
        result = 4294962992LL;
        if ( v19 )
          result = (unsigned int)v18;
      }
    }
  }
  return result;
}
// AC64: using guessed type int __fastcall ccrsa_decrypt_eme_pkcs1v15(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// AC6A: using guessed type int __fastcall ccrsa_decrypt_oaep(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000079DA) ----------------------------------------------------
__int64 __fastcall CCRSACryptorCrypt(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r12@1
  __int64 v6; // r14@1
  unsigned __int64 v7; // r15@1
  __int64 v8; // rdx@1
  signed int v9; // ebx@1
  char *v10; // rbx@7
  int v11; // eax@7
  __int64 v12; // r13@8
  __int64 v13; // rcx@9
  __int64 v14; // rbx@11
  unsigned __int64 v15; // rax@11
  __int64 v16; // r13@11
  unsigned __int64 v17; // r12@11
  __int64 result; // rax@15
  __int64 v19; // [sp+0h] [bp-50h]@7
  __int64 v20; // [sp+8h] [bp-48h]@11
  __int64 v21; // [sp+10h] [bp-40h]@7
  __int64 *v22; // [sp+18h] [bp-38h]@7
  __int64 v23; // [sp+20h] [bp-30h]@1

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = __stack_chk_guard_ptr[0];
  v23 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v9 = -4300;
  if ( !a1 )
    goto LABEL_15;
  if ( !a2 )
    goto LABEL_15;
  if ( !a4 )
    goto LABEL_15;
  if ( !a5 )
    goto LABEL_15;
  v9 = -4302;
  if ( (unsigned __int64)(*(_QWORD *)(a1 + 30848) + 7LL) >> 3 != v7 || *(_QWORD *)a5 < v7 )
    goto LABEL_15;
  v22 = &v19;
  v21 = *(_QWORD *)a1;
  v10 = (char *)&v19 - ((8 * v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  ccn_read_uint(v21, v10, v7, a2);
  v11 = *(_DWORD *)(a1 + 30856);
  if ( v11 == 1 )
  {
    ccrsa_priv_crypt(a1 + 32LL * *(_QWORD *)a1 + 24, v10, v10);
    v12 = (__int64)v10;
LABEL_11:
    v20 = v12;
    *(_QWORD *)v5 = v7;
    v14 = v21;
    LODWORD(v15) = ccn_write_uint_size(v21, v12);
    v16 = v14;
    v9 = 0;
    v17 = v7 - v15;
    if ( v7 <= v15 )
      v17 = 0LL;
    __bzero(v6);
    ccn_write_uint(v16, v20, v7 - v17, v6 + v17);
    goto LABEL_14;
  }
  v13 = (__int64)v10;
  v9 = -4300;
  if ( !v11 )
  {
    v12 = v13;
    ccrsa_pub_crypt(a1, v13, v13);
    goto LABEL_11;
  }
LABEL_14:
  v8 = __stack_chk_guard_ptr[0];
LABEL_15:
  result = *(_QWORD *)v8;
  if ( *(_QWORD *)v8 == v23 )
    result = (unsigned int)v9;
  return result;
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);
// ABD4: using guessed type int __fastcall ccn_read_uint(_QWORD, _QWORD, _QWORD, _QWORD);
// ABE6: using guessed type int __fastcall ccn_write_uint(_QWORD, _QWORD, _QWORD, _QWORD);
// ABEC: using guessed type int __fastcall ccn_write_uint_size(_QWORD, _QWORD);
// ACA6: using guessed type int __fastcall ccrsa_priv_crypt(_QWORD, _QWORD, _QWORD);
// ACAC: using guessed type int __fastcall ccrsa_pub_crypt(_QWORD, _QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000007B40) ----------------------------------------------------
__int64 __fastcall CCRSACryptorCreatePairFromData(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16, __int64 a17, __int64 a18, __int64 a19, __int64 a20, __int64 a21, __int64 a22, __int64 a23)
{
  unsigned __int64 v23; // rax@1
  char *v24; // r14@1
  unsigned __int64 v25; // rax@1
  unsigned __int64 v26; // rax@1
  unsigned __int64 v27; // rax@1
  unsigned __int64 v28; // rax@1
  unsigned __int64 v29; // rax@1
  char *v30; // rbx@1
  unsigned __int64 v31; // r12@1
  unsigned __int64 v32; // rax@1
  void *v33; // rax@1
  signed int v34; // ecx@1
  __int64 v35; // r13@2
  int v36; // eax@2
  signed int v37; // ecx@2
  __int64 v38; // r15@3
  char *v39; // rbx@7
  unsigned __int64 v40; // r14@7
  int v41; // eax@7
  __int64 v42; // r12@7
  __int64 v43; // r13@7
  int v44; // eax@8
  void *v45; // rax@9
  unsigned __int64 v46; // r14@10
  __int64 *v47; // rbx@10
  unsigned __int64 v48; // rax@10
  unsigned __int64 v49; // rbx@12
  __int64 *v50; // r14@12
  unsigned __int64 v51; // rax@12
  __int64 v52; // r12@12
  unsigned __int64 v53; // rbx@14
  unsigned __int64 v54; // rax@14
  unsigned __int64 v55; // rbx@16
  unsigned __int64 v56; // rax@16
  signed int v57; // ebx@20
  __int64 result; // rax@22
  __int64 v59; // [sp+90h] [bp-F0h]@1
  unsigned __int64 v60; // [sp+98h] [bp-E8h]@1
  __int64 v61; // [sp+A0h] [bp-E0h]@1
  __int64 v62; // [sp+A8h] [bp-D8h]@1
  __int64 v63; // [sp+B0h] [bp-D0h]@1
  __int64 v64; // [sp+B8h] [bp-C8h]@1
  __int64 v65; // [sp+C0h] [bp-C0h]@1
  __int64 *v66; // [sp+C8h] [bp-B8h]@1
  __int64 *v67; // [sp+D0h] [bp-B0h]@1
  unsigned __int64 v68; // [sp+D8h] [bp-A8h]@1
  unsigned __int64 v69; // [sp+E0h] [bp-A0h]@1
  unsigned __int64 v70; // [sp+E8h] [bp-98h]@1
  unsigned __int64 v71; // [sp+F0h] [bp-90h]@1
  unsigned __int64 v72; // [sp+F8h] [bp-88h]@1
  unsigned __int64 v73; // [sp+100h] [bp-80h]@1
  unsigned __int64 v74; // [sp+108h] [bp-78h]@1
  __int64 *v75; // [sp+110h] [bp-70h]@1
  __int64 *v76; // [sp+118h] [bp-68h]@1
  __int64 *v77; // [sp+120h] [bp-60h]@1
  unsigned __int64 v78; // [sp+128h] [bp-58h]@1
  unsigned __int64 v79; // [sp+130h] [bp-50h]@1
  unsigned __int64 v80; // [sp+138h] [bp-48h]@1
  unsigned __int64 v81; // [sp+140h] [bp-40h]@1
  __int64 *v82; // [sp+148h] [bp-38h]@1
  __int64 v83; // [sp+150h] [bp-30h]@1

  v62 = a6;
  v63 = a5;
  v64 = a4;
  v65 = a3;
  v83 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v23 = (unsigned __int64)(a3 + 7) >> 3;
  v77 = (__int64 *)v23;
  v24 = (char *)&v59 - ((8 * v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v25 = (unsigned __int64)(a5 + 7) >> 3;
  v76 = (__int64 *)v25;
  v75 = (__int64 *)((char *)&v59 - ((8 * v25 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  v26 = (unsigned __int64)(a7 + 7) >> 3;
  v74 = v26;
  v73 = (unsigned __int64)((char *)v75 - ((8 * v26 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  v27 = (unsigned __int64)(a9 + 7) >> 3;
  v72 = v27;
  v71 = v73 - ((8 * v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v28 = (unsigned __int64)(a11 + 7) >> 3;
  v70 = v28;
  v69 = v71 - ((8 * v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v29 = (unsigned __int64)(a13 + 7) >> 3;
  v60 = v29;
  v30 = (char *)&v59 - ((8 * v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v31 = (unsigned __int64)(8 * a7 + 8 * a13 + 63) >> 6;
  v32 = (8 * v31 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  v66 = (__int64 *)((char *)&v59 - v32);
  v67 = (__int64 *)((char *)&v59 + -v32 - v32);
  v68 = (unsigned __int64)((char *)v67 - v32);
  v61 = (__int64)((char *)v67 + -v32 - v32);
  v78 = (unsigned __int64)(8 * a7 + 8 * a13 + 63) >> 6;
  v79 = (unsigned __int64)(8 * a7 + 8 * a13 + 63) >> 6;
  v80 = (unsigned __int64)(8 * a7 + 8 * a13 + 63) >> 6;
  v81 = (unsigned __int64)(8 * a7 + 8 * a13 + 63) >> 6;
  v82 = (__int64 *)a1;
  v33 = malloc(0x7890uLL);
  v34 = -4302;
  if ( !v33 )
    goto LABEL_21;
  v59 = 8 * a7 + 8 * a13;
  *((_QWORD *)v33 + 3856) = v59;
  *(_QWORD *)v33 = v31;
  v35 = (__int64)v33;
  v36 = ccn_read_uint(v77, v24, v65, a2);
  v37 = -4300;
  if ( v36 )
  {
    v42 = v35;
    goto LABEL_20;
  }
  v38 = (__int64)v30;
  if ( ccn_read_uint(v76, v75, v63, v64)
    || ccn_read_uint(v74, v73, a7, v62)
    || ccn_read_uint(v72, v71, a9, a8)
    || ccn_read_uint(v70, v69, a11, a10) )
  {
    v42 = v35;
    v37 = -4300;
LABEL_20:
    v57 = v37;
    ccRSACryptorClear((void *)v42);
    v34 = v57;
LABEL_21:
    *(_QWORD *)a15 = 0LL;
    *(_QWORD *)a14 = 0LL;
    goto LABEL_22;
  }
  v39 = v24;
  v40 = v60;
  v41 = ccn_read_uint(v60, v38, a13, a12);
  v42 = v35;
  v43 = v61;
  v37 = -4300;
  if ( v41 )
    goto LABEL_20;
  v83 = v61;
  v82 = (__int64 *)&v78;
  v81 = v68;
  v80 = (unsigned __int64)&v79;
  v79 = (unsigned __int64)v67;
  v78 = (unsigned __int64)&v80;
  v77 = v66;
  v76 = (__int64 *)&v81;
  v75 = (__int64 *)v42;
  v74 = v38;
  v73 = v40;
  v72 = v69;
  v71 = v70;
  v68 = v40;
  v67 = (__int64 *)v38;
  v66 = (__int64 *)v42;
  v44 = ccrsa_make_931_key(v59, 1LL, &v82, v77, v39, &v81);
  v37 = -4304;
  if ( v44 )
    goto LABEL_20;
  *(_DWORD *)(v42 + 30856) = 1;
  v45 = CCRSACryptorGetPublicKeyFromPrivateKey(v42);
  v37 = -4302;
  if ( !v45 )
    goto LABEL_20;
  *(_QWORD *)a14 = v45;
  *(_QWORD *)a15 = v42;
  v46 = v81;
  v47 = v66;
  LODWORD(v48) = ccn_write_uint_size(v81, v66);
  if ( v48 <= *(_QWORD *)a17 )
  {
    *(_QWORD *)a17 = v48;
    ccn_write_uint(v46, v47, v48, a16);
  }
  v49 = v80;
  v50 = v67;
  LODWORD(v51) = ccn_write_uint_size(v80, v67);
  v52 = v68;
  if ( v51 <= *(_QWORD *)a19 )
  {
    *(_QWORD *)a19 = v51;
    ccn_write_uint(v49, v50, v51, a18);
  }
  v53 = v79;
  LODWORD(v54) = ccn_write_uint_size(v79, v52);
  if ( v54 <= *(_QWORD *)a21 )
  {
    *(_QWORD *)a21 = v54;
    ccn_write_uint(v53, v52, v54, a20);
  }
  v55 = v78;
  LODWORD(v56) = ccn_write_uint_size(v78, v43);
  v34 = 0;
  if ( v56 <= *(_QWORD *)a23 )
  {
    *(_QWORD *)a23 = v56;
    ccn_write_uint(v55, v43, v56, a22);
    v34 = 0;
  }
LABEL_22:
  result = *(_QWORD *)__stack_chk_guard_ptr[0];
  if ( *(_QWORD *)__stack_chk_guard_ptr[0] == v83 )
    result = (unsigned int)v34;
  return result;
}
// ABD4: using guessed type int __fastcall ccn_read_uint(_QWORD, _QWORD, _QWORD, _QWORD);
// ABE6: using guessed type int __fastcall ccn_write_uint(_QWORD, _QWORD, _QWORD, _QWORD);
// ABEC: using guessed type int __fastcall ccn_write_uint_size(_QWORD, _QWORD);
// ACA0: using guessed type int __fastcall ccrsa_make_931_key(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (000000000000803E) ----------------------------------------------------
signed __int64 __fastcall CCRSACryptorCreateFromData(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10)
{
  __int64 v10; // r12@1
  __int64 v11; // r13@1
  __int64 v12; // r15@1
  unsigned __int64 v13; // r14@1
  char *v14; // rbx@1
  int v15; // ecx@1
  signed __int64 result; // rax@1
  __int64 v17; // rax@2
  __int64 v18; // r12@2
  void *v19; // r13@2
  __int64 v20; // rax@5
  signed __int64 v21; // rbx@6
  unsigned __int64 v22; // rdi@6
  signed __int64 v23; // rbx@7
  unsigned __int64 v24; // rdi@7
  signed __int64 v25; // rax@7
  signed __int64 v26; // rsi@8
  signed __int64 v27; // rdx@8
  signed __int64 v28; // r8@8
  signed __int64 v29; // r9@8
  signed __int64 v30; // rcx@8
  __int64 v31; // rcx@13
  __int64 v32; // [sp+10h] [bp-60h]@1
  __int64 v33; // [sp+18h] [bp-58h]@2
  __int64 v34; // [sp+20h] [bp-50h]@2
  int v35; // [sp+2Ch] [bp-44h]@1
  __int64 v36; // [sp+30h] [bp-40h]@1
  __int64 v37; // [sp+38h] [bp-38h]@1
  __int64 v38; // [sp+40h] [bp-30h]@1

  v10 = a6;
  v36 = a5;
  v11 = a4;
  v12 = a3;
  v37 = a2;
  v35 = a1;
  v38 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v13 = (unsigned __int64)(a3 + 7) >> 3;
  v14 = (char *)&v32 - ((8 * v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v15 = ccn_read_uint(v13, v14, a3, a2);
  result = 4294962996LL;
  if ( !v15 )
  {
    v34 = v11;
    v33 = v10;
    LODWORD(v17) = ccn_bitlen(v13, v14);
    v18 = v17;
    v19 = malloc(0x7890uLL);
    result = 4294962994LL;
    if ( v19 )
    {
      *((_QWORD *)v19 + 3856) = v18;
      *(_QWORD *)v19 = (unsigned __int64)(v18 + 63) >> 6;
      if ( !ccn_read_uint(v13, (char *)v19 + 16, v12, v37)
        && !ccn_read_uint(v13, (char *)v19 + 16 * *(_QWORD *)v19 + 24, v36, v34) )
      {
        cczp_init(v19);
        LODWORD(v20) = ccn_bitlen(v13, (char *)v19 + 16);
        *((_QWORD *)v19 + 3856) = v20;
        if ( v35 == 1 )
        {
          v21 = 32LL * *(_QWORD *)v19;
          v22 = (unsigned __int64)(a7 + 7) >> 3;
          *(_QWORD *)((char *)v19 + v21 + 24) = v22;
          if ( !ccn_read_uint(v22, (char *)v19 + v21 + 40, a7, v33) )
          {
            v23 = (signed __int64)((char *)v19 + v21 + 24);
            v24 = (unsigned __int64)(a9 + 7) >> 3;
            v25 = 16LL * *(_QWORD *)v23;
            *(_QWORD *)(v25 + v23 + 24) = v24;
            if ( !ccn_read_uint(v24, v25 + v23 + 40, a9, a8) )
            {
              v26 = (signed __int64)((char *)v19 + 16 * *(_QWORD *)v19 + 24);
              v27 = (signed __int64)((char *)v19 + 24 * *(_QWORD *)v19 + 24);
              v28 = 32LL * *(_QWORD *)v23 + v23 + 48;
              v29 = v23 + 48LL * *(_QWORD *)v23 + 48;
              v30 = 16LL * *(_QWORD *)v23 + v23 + 24;
              v38 = v23 + 40LL * *(_QWORD *)v23 + 48;
              v37 = v30;
              ccrsa_crt_makekey(v19, v26, v27, v23, v28, v29);
              *((_DWORD *)v19 + 7714) = 1;
LABEL_11:
              *(_QWORD *)a10 = v19;
              result = 0LL;
              goto LABEL_13;
            }
          }
        }
        else if ( !v35 )
        {
          *((_DWORD *)v19 + 7714) = 0;
          goto LABEL_11;
        }
      }
      ccRSACryptorClear(v19);
      result = 4294962996LL;
      goto LABEL_13;
    }
  }
LABEL_13:
  v31 = *(_QWORD *)__stack_chk_guard_ptr[0];
  return result;
}
// ABCE: using guessed type int __fastcall ccn_bitlen(_QWORD, _QWORD);
// ABD4: using guessed type int __fastcall ccn_read_uint(_QWORD, _QWORD, _QWORD, _QWORD);
// AC5E: using guessed type int __fastcall ccrsa_crt_makekey(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// ADD8: using guessed type int __fastcall cczp_init(_QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000008279) ----------------------------------------------------
__int64 __fastcall CCRSAGetKeyComponents(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // eax@1
  signed int v4; // ebx@1
  int v5; // eax@2

  v3 = *(_DWORD *)(a1 + 30856);
  v4 = -4300;
  if ( v3 == 1 )
  {
    v5 = ccrsa_get_fullkey_components(a1, a2, a3);
  }
  else
  {
    if ( v3 )
      return (unsigned int)v4;
    v5 = ccrsa_get_pubkey_components();
  }
  if ( !v5 )
    v4 = 0;
  return (unsigned int)v4;
}
// AC88: using guessed type int __cdecl ccrsa_get_fullkey_components(_QWORD, _QWORD, _QWORD);
// AC8E: using guessed type int ccrsa_get_pubkey_components(void);

//----- (00000000000082CB) ----------------------------------------------------
signed __int64 __usercall CCRSACryptorSign@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, int a4@<esi>, unsigned int a5@<r8d>, __int128 a6@<xmm0>, __int128 a7@<xmm1>, __int128 a8@<xmm2>, __int128 a9@<xmm3>, __int128 a10@<xmm6>, __int128 a11@<xmm7>, __int64 a12, __int64 a13)
{
  __int64 v13; // r14@1
  __int64 v14; // r15@1
  signed __int64 result; // rax@1
  __int64 v16; // r12@5
  __int64 v17; // r8@5
  __int64 v18; // r9@5
  __int128 v19; // xmm4@5
  __int128 v20; // xmm5@5
  __int64 v21; // rax@5
  int v22; // eax@5
  __int64 v23; // rax@7
  int v24; // ecx@8

  v13 = a2;
  v14 = a1;
  result = 4294962996LL;
  if ( a3 && a1 && a12 )
  {
    if ( a4 == 1002 )
    {
      v16 = CCDigestGetDigestInfo(a5);
      v21 = ccDRBGGetRngState(v17, v18, a6, a7, a8, a9, v19, v20, a10, a11);
      v22 = ccrsa_sign_oaep(a3, v16, v21, v13, v14, a13);
    }
    else
    {
      if ( a4 != 1001 )
        return result;
      v23 = CCDigestGetDigestInfo(a5);
      v22 = ccrsa_sign_pkcs1v15(a3, *(_QWORD *)(v23 + 32), v13, v14, a13, a12);
    }
    v24 = v22;
    result = 4294962992LL;
    if ( !v24 )
      result = 0LL;
  }
  return result;
}
// ACB2: using guessed type int __fastcall ccrsa_sign_oaep(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// ACB8: using guessed type int __fastcall ccrsa_sign_pkcs1v15(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000008378) ----------------------------------------------------
signed __int64 __usercall CCRSACryptorVerify@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, int a4@<esi>, unsigned int a5@<r8d>, __int64 a6, __int64 a7)
{
  __int64 v7; // r14@1
  __int64 v8; // r12@1
  signed __int64 result; // rax@1
  __int64 v10; // rax@5
  int v11; // eax@5
  __int64 v12; // rax@7
  bool v13; // zf@8
  char v14; // [sp+17h] [bp-29h]@9

  v7 = a2;
  v8 = a1;
  result = 4294962996LL;
  if ( a3 && a1 && a6 )
  {
    if ( a4 == 1002 )
    {
      v10 = CCDigestGetDigestInfo(a5);
      v11 = ccrsa_verify_oaep(a3, v10, v7, v8, a7, a6);
    }
    else
    {
      if ( a4 != 1001 )
        return result;
      v12 = CCDigestGetDigestInfo(a5);
      v11 = ccrsa_verify_pkcs1v15(a3, *(_QWORD *)(v12 + 32), v7, v8, a7, a6);
    }
    v13 = v11 == 0;
    result = 4294962992LL;
    if ( v13 )
    {
      if ( v14 )
        result = 0LL;
    }
  }
  return result;
}
// ACBE: using guessed type int __fastcall ccrsa_verify_oaep(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// ACC4: using guessed type int __fastcall ccrsa_verify_pkcs1v15(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000008438) ----------------------------------------------------
signed __int64 __fastcall CCSymmetricKeyWrap(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int64 a7, __int64 a8, __int64 a9)
{
  __int64 v9; // r15@1
  __int64 v10; // r13@1
  unsigned __int64 v11; // rbx@1
  __int64 v12; // rax@1
  unsigned __int64 v13; // rax@1
  char *v14; // r12@1
  void *v15; // r8@1
  signed __int64 result; // rax@1
  __int64 v17; // r14@3
  int v18; // eax@4
  __int64 v19; // rsi@4
  __int64 v20; // rdi@4
  __int64 v21; // r10@4
  signed __int64 v22; // rcx@5
  void *v23; // r14@8
  unsigned __int64 v24; // r9@8
  __int64 v25; // rax@8
  __int64 v26; // rcx@8
  __int64 v27; // r15@9
  void *v28; // rbx@9
  unsigned __int64 v29; // r14@9
  void *v30; // r13@10
  unsigned __int64 v31; // r12@10
  signed __int64 v34; // rax@13
  __int64 v35; // rcx@13
  int v36; // edx@13
  void *v37; // rbx@16
  unsigned int v38; // ebx@19
  __int64 v39; // rcx@20
  __int64 v40; // [sp+0h] [bp-50h]@1
  __int64 v41; // [sp+8h] [bp-48h]@1
  __int64 *v42; // [sp+10h] [bp-40h]@1
  __int64 v43; // [sp+18h] [bp-38h]@1
  __int64 v44; // [sp+20h] [bp-30h]@1

  v41 = a6;
  v9 = a5;
  v40 = a4;
  v10 = a2;
  v44 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v11 = a7 >> 3;
  v12 = getCipherMode(0, 1, 0);
  v43 = v12;
  v13 = (*(_QWORD *)v12 + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
  v14 = (char *)&v40 - v13;
  v42 = (__int64 *)((char *)&v40 - v13);
  v15 = calloc(a7 >> 3, 0x10uLL);
  result = 0xFFFFFFFFLL;
  if ( v9 != 32 && (v9 & 0xFFFFFFFFFFFFFFF7LL) != 16 || !a9 )
  {
    v17 = __stack_chk_guard_ptr[0];
  }
  else
  {
    v17 = __stack_chk_guard_ptr[0];
    if ( *(_QWORD *)a9 >= a7 + 8 )
    {
      v18 = 0;
      v19 = 0LL;
      v20 = 0LL;
      v21 = v41;
      if ( (signed int)v11 > 0 )
      {
        v22 = (signed __int64)((char *)v15 + 8);
        do
        {
          *(_QWORD *)v22 = *(_QWORD *)(v21 + v18);
          v22 += 16LL;
          v18 += 8;
          LODWORD(v11) = v11 - 1;
          v19 = 0LL;
          v20 = 0LL;
        }
        while ( (_DWORD)v11 );
      }
      do
        v20 = (v20 << 8) | *(_BYTE *)(v10 + v19++);
      while ( v19 != 8 );
      *(_QWORD *)v15 = v20;
      v23 = v15;
      (*(void (__fastcall **)(__int64, char *, __int64, __int64))(v43 + 16))(v43, v14, v9, v40);
      v24 = a7 >> 3;
      v15 = v23;
      v25 = 0LL;
      v26 = 1LL;
      do
      {
        v40 = v26;
        v41 = v25;
        v27 = v26;
        v28 = v15;
        v29 = 0LL;
        if ( (signed int)v24 > 0 )
        {
          do
          {
            v30 = v15;
            v31 = v24;
            (*(void (__fastcall **)(__int64 *, signed __int64, void *, void *))(v43 + 24))(v42, 1LL, v28, v28);
            v24 = v31;
            v15 = v30;
            _RCX = v27;
            __asm { bswap   rcx }
            ++v29;
            *((_QWORD *)v30 + 2 * (v29 % v31)) = *(_QWORD *)v28 ^ _RCX;
            v28 = (char *)v28 + 16;
            ++v27;
          }
          while ( (_DWORD)v31 != (_DWORD)v29 );
        }
        v25 = v41 + 1;
        v26 = v24 + v40;
      }
      while ( v41 != 5 );
      *(_QWORD *)a8 = *(_QWORD *)v15;
      result = 0LL;
      v17 = __stack_chk_guard_ptr[0];
      if ( (signed int)v24 > 0 )
      {
        v34 = (signed __int64)((char *)v15 + 8);
        LODWORD(v35) = 0;
        v36 = v24;
        do
        {
          v35 = (signed int)v35;
          *(_QWORD *)(v35 + a8 + 8) = *(_QWORD *)v34;
          v34 += 16LL;
          LODWORD(v35) = v35 + 8;
          --v36;
        }
        while ( v36 );
        result = 0LL;
        if ( (signed int)v24 > 0 )
        {
          v37 = v15;
          __bzero(v15);
          result = 0LL;
          v15 = v37;
        }
      }
    }
  }
  if ( v15 )
  {
    v38 = result;
    free(v15);
    result = v38;
  }
  v39 = *(_QWORD *)v17;
  return result;
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000008686) ----------------------------------------------------
signed __int64 __fastcall CCSymmetricKeyUnwrap(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5, __int64 a6, unsigned __int64 a7, __int64 a8)
{
  __int64 v8; // rbx@1
  unsigned __int64 v9; // r13@1
  unsigned __int64 v10; // r14@1
  __int64 v11; // rax@1
  __int64 v12; // rcx@1
  char *v13; // r12@1
  unsigned __int64 v14; // r15@1
  signed __int64 result; // rax@1
  void *v16; // rcx@2
  unsigned __int64 v17; // rdx@2
  signed __int64 v18; // rax@3
  __int64 v19; // rdi@3
  signed __int64 v20; // rbx@4
  signed __int64 v21; // rax@4
  void *v22; // r13@4
  unsigned __int64 v23; // rcx@4
  __int64 v24; // rsi@6
  __int64 v25; // rax@6
  __int64 v26; // r13@7
  __int64 v27; // rbx@7
  unsigned __int64 v28; // r14@7
  unsigned __int64 v31; // r12@8
  void *v32; // r15@8
  __int64 v33; // rax@10
  __int64 v34; // rdi@10
  __int64 v35; // rbx@10
  signed __int64 v36; // rax@13
  unsigned __int64 v37; // rsi@13
  void *v38; // rbx@15
  __int64 v39; // rcx@19
  __int64 v40; // [sp+0h] [bp-80h]@1
  unsigned __int64 v41; // [sp+8h] [bp-78h]@6
  __int64 v42; // [sp+10h] [bp-70h]@1
  unsigned int v43; // [sp+1Ch] [bp-64h]@2
  unsigned __int64 v44; // [sp+20h] [bp-60h]@6
  __int64 v45; // [sp+28h] [bp-58h]@6
  __int64 v46; // [sp+30h] [bp-50h]@7
  __int64 v47; // [sp+38h] [bp-48h]@1
  __int64 v48; // [sp+40h] [bp-40h]@2
  __int64 v49; // [sp+48h] [bp-38h]@2
  __int64 v50; // [sp+50h] [bp-30h]@1

  v8 = a6;
  v9 = a5;
  v47 = a4;
  v42 = a2;
  v50 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v10 = a7 >> 3;
  v11 = getCipherMode(0, 1, 1u);
  v12 = v11;
  v13 = (char *)&v40 - ((*(_QWORD *)v11 + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  v14 = (a7 >> 3) - 1;
  result = 0xFFFFFFFFLL;
  if ( a7 >> 3 != 1 )
  {
    v48 = (__int64)v13;
    v49 = v12;
    v16 = calloc(v10 - 1, 0x10uLL);
    v43 = -1;
    v17 = v9;
    if ( v9 <= 0x20 )
    {
      v18 = 4311810048LL;
      v19 = v49;
      if ( _bittest((const unsigned __int64 *)&v18, v9) )
      {
        *(_QWORD *)v16 = *(_QWORD *)v8;
        v20 = v8 + 8;
        v21 = (signed __int64)((char *)v16 + 8);
        v22 = v16;
        v23 = 0LL;
        do
        {
          ++v23;
          *(_QWORD *)v21 = *(_QWORD *)v20;
          v20 += 8LL;
          v21 += 16LL;
        }
        while ( v23 < v14 );
        (*(void (__fastcall **)(__int64, char *, unsigned __int64, __int64))(v19 + 16))(v19, v13, v17, v47);
        v41 = 16 * v10;
        v16 = v22;
        v45 = (__int64)((char *)v22 + 16 * v10 - 32);
        v24 = 6 * v10 - 6;
        v44 = 1 - v10;
        v25 = 5LL;
        do
        {
          v46 = v25;
          v47 = v24;
          v26 = v24;
          v27 = v45;
          v28 = v14;
          do
          {
            _RAX = v26;
            __asm { bswap   rax }
            *(_QWORD *)v27 = *((_QWORD *)v16 + 2 * (v28 % v14)) ^ _RAX;
            v31 = v14;
            v32 = v16;
            (*(void (__fastcall **)(__int64, signed __int64, __int64, __int64))(v49 + 24))(v48, 1LL, v27, v27);
            v16 = v32;
            v14 = v31;
            v27 -= 16LL;
            --v26;
            --v28;
          }
          while ( v28 );
          v24 = v44 + v47;
          v25 = v46 - 1;
        }
        while ( (signed int)v46 > 0 );
        v33 = 0LL;
        v34 = a8;
        v35 = 0LL;
        do
          v33 = (v33 << 8) | *(_BYTE *)(v42 + v35++);
        while ( v35 != 8 );
        if ( *(_QWORD *)v16 == v33 )
        {
          v36 = (signed __int64)((char *)v16 + 8);
          v37 = 0LL;
          do
          {
            *(_QWORD *)v34 = *(_QWORD *)v36;
            ++v37;
            v34 += 8LL;
            v36 += 16LL;
          }
          while ( v37 < v31 );
          v38 = v16;
          __bzero(v16);
          v16 = v38;
          v43 = 0;
        }
      }
    }
    if ( v16 )
      free(v16);
    result = v43;
  }
  v39 = *(_QWORD *)__stack_chk_guard_ptr[0];
  return result;
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (00000000000088A1) ----------------------------------------------------
signed __int64 __fastcall CCSymmetricWrappedSize(__int64 a1, __int64 a2)
{
  return a2 + 8;
}

//----- (00000000000088AB) ----------------------------------------------------
signed __int64 __fastcall CCSymmetricUnwrappedSize(__int64 a1, __int64 a2)
{
  return a2 - 8;
}

//----- (00000000000088B5) ----------------------------------------------------
__int64 noMode()
{
  return 0LL;
}

//----- (00000000000088BD) ----------------------------------------------------
__int64 cc_rc4_crypt_mode()
{
  return (__int64)rc4mode;
}
// D500: using guessed type __int64 rc4mode[2];

//----- (00000000000088CA) ----------------------------------------------------
__int64 __fastcall ccecb_mode_get_ctx_size(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (00000000000088D3) ----------------------------------------------------
__int64 __fastcall ccecb_mode_get_block_size(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (00000000000088DD) ----------------------------------------------------
int __usercall ccecb_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4, __int64 a5)
{
  return (*(int (__fastcall **)(__int64, __int64, __int64, __int64))(a3 + 16))(a3, a5, a2, a1);
}

//----- (00000000000088F5) ----------------------------------------------------
int __fastcall ccecb_mode_crypt(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5)
{
  return (*(int (__fastcall **)(__int64, unsigned __int64, __int64, __int64))(a1 + 24))(
           a5,
           a4 / *(_QWORD *)(a1 + 8),
           a2,
           a3);
}

//----- (000000000000891C) ----------------------------------------------------
signed __int64 __fastcall cccbc_mode_get_ctx_size(__int64 a1)
{
  return *(_QWORD *)a1 + 16LL;
}

//----- (0000000000008929) ----------------------------------------------------
__int64 __fastcall cccbc_mode_get_block_size(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (0000000000008933) ----------------------------------------------------
int __usercall cccbc_mode_setup@<eax>(void *a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, const void *a4@<rsi>, __int64 a5, void *a6)
{
  __int64 v6; // r15@1
  void *v7; // r14@1

  v6 = a2;
  v7 = a1;
  memcpy(a6, a4, *(_QWORD *)(a3 + 8));
  return (*(int (__fastcall **)(__int64, char *, __int64, void *))(a3 + 16))(a3, (char *)a6 + 16, v6, v7);
}

//----- (0000000000008977) ----------------------------------------------------
int __fastcall cccbc_mode_crypt(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5)
{
  return (*(int (__fastcall **)(__int64, __int64, unsigned __int64, __int64, __int64))(a1 + 24))(
           a5 + 16,
           a5,
           a4 / *(_QWORD *)(a1 + 8),
           a2,
           a3);
}

//----- (00000000000089A5) ----------------------------------------------------
signed __int64 __fastcall cccbc_setiv(__int64 a1, const void *a2, size_t a3, void *a4)
{
  signed __int64 result; // rax@1

  a3 = (unsigned int)a3;
  result = 0xFFFFFFFFLL;
  if ( (unsigned int)a3 == *(_QWORD *)(a1 + 8) )
  {
    memcpy(a4, a2, a3);
    result = 0LL;
  }
  return result;
}

//----- (00000000000089C2) ----------------------------------------------------
signed __int64 __fastcall cccbc_getiv(__int64 a1, void *a2, __int64 a3, const void *a4)
{
  unsigned __int64 v4; // rdi@1
  bool v5; // cf@1
  signed __int64 result; // rax@1

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_DWORD *)a3 < v4;
  *(_DWORD *)a3 = v4;
  result = 0xFFFFFFFFLL;
  if ( !v5 )
  {
    memcpy(a2, a4, (unsigned int)v4);
    result = 0LL;
  }
  return result;
}

//----- (00000000000089E9) ----------------------------------------------------
__int64 __fastcall cccfb_mode_get_ctx_size(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (00000000000089F2) ----------------------------------------------------
__int64 __fastcall cccfb_mode_get_block_size(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (00000000000089FC) ----------------------------------------------------
int __usercall cccfb_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5, __int64 a6)
{
  return (*(int (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(a3 + 16))(a3, a6, a2, a1, a4);
}

//----- (0000000000008A17) ----------------------------------------------------
int __fastcall cccfb_mode_crypt(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5)
{
  return (*(int (__fastcall **)(__int64, unsigned __int64, __int64, __int64))(a1 + 24))(
           a5,
           a4 / *(_QWORD *)(a1 + 8),
           a2,
           a3);
}

//----- (0000000000008A3E) ----------------------------------------------------
__int64 __fastcall cccfb8_mode_get_ctx_size(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000000008A47) ----------------------------------------------------
__int64 __fastcall cccfb8_mode_get_block_size(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (0000000000008A51) ----------------------------------------------------
int __usercall cccfb8_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5, __int64 a6)
{
  return (*(int (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(a3 + 16))(a3, a6, a2, a1, a4);
}

//----- (0000000000008A6C) ----------------------------------------------------
int __fastcall cccfb8_mode_crypt(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5)
{
  return (*(int (__fastcall **)(__int64, unsigned __int64, __int64, __int64))(a1 + 24))(
           a5,
           a4 / *(_QWORD *)(a1 + 8),
           a2,
           a3);
}

//----- (0000000000008A93) ----------------------------------------------------
__int64 __fastcall ccctr_mode_get_ctx_size(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000000008A9C) ----------------------------------------------------
__int64 __fastcall ccctr_mode_get_block_size(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (0000000000008AA6) ----------------------------------------------------
int __usercall ccctr_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5, __int64 a6)
{
  return (*(int (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(a3 + 16))(a3, a6, a2, a1, a4);
}

//----- (0000000000008AC1) ----------------------------------------------------
int __fastcall ccctr_mode_crypt(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5)
{
  return (*(int (__fastcall **)(__int64, unsigned __int64, __int64, __int64))(a1 + 24))(
           a5,
           a4 / *(_QWORD *)(a1 + 8),
           a2,
           a3);
}

//----- (0000000000008AE8) ----------------------------------------------------
__int64 __fastcall ccofb_mode_get_ctx_size(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000000008AF1) ----------------------------------------------------
__int64 __fastcall ccofb_mode_get_block_size(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (0000000000008AFB) ----------------------------------------------------
int __usercall ccofb_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5, __int64 a6)
{
  return (*(int (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(a3 + 16))(a3, a6, a2, a1, a4);
}

//----- (0000000000008B16) ----------------------------------------------------
int __fastcall ccofb_mode_crypt(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5)
{
  return (*(int (__fastcall **)(__int64, unsigned __int64, __int64, __int64))(a1 + 24))(
           a5,
           a4 / *(_QWORD *)(a1 + 8),
           a2,
           a3);
}

//----- (0000000000008B3D) ----------------------------------------------------
__int64 __fastcall ccxts_mode_get_ctx_size(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000000008B46) ----------------------------------------------------
__int64 __fastcall ccxts_mode_get_block_size(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}

//----- (0000000000008B50) ----------------------------------------------------
int __usercall ccxts_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4, __int64 a5)
{
  return (*(int (__fastcall **)(__int64, __int64, __int64, __int64))(a3 + 24))(a3, a5, a2, a1);
}

//----- (0000000000008B68) ----------------------------------------------------
__int64 __fastcall ccxts_mode_encrypt_tweak(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r13@1
  __int64 v7; // r15@1
  char *v8; // r14@1
  __int64 v10; // [sp+0h] [bp-40h]@1
  __int64 v11; // [sp+8h] [bp-38h]@1
  __int64 v12; // [sp+10h] [bp-30h]@1

  v6 = a6;
  v11 = a4;
  v7 = a3;
  v12 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v8 = (char *)&v10 - ((*(_QWORD *)a1 + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (__fastcall **)(__int64, char *, __int64))(a1 + 32))(a6, v8, a5);
  ccpad_xts_encrypt(a1, v6, v8, v7, a2, v11);
  return *(_QWORD *)__stack_chk_guard_ptr[0];
}
// AC40: using guessed type int __fastcall ccpad_xts_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000008BF3) ----------------------------------------------------
__int64 __fastcall ccxts_mode_decrypt_tweak(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r13@1
  __int64 v7; // r15@1
  char *v8; // r14@1
  __int64 v10; // [sp+0h] [bp-40h]@1
  __int64 v11; // [sp+8h] [bp-38h]@1
  __int64 v12; // [sp+10h] [bp-30h]@1

  v6 = a6;
  v11 = a4;
  v7 = a3;
  v12 = *(_QWORD *)__stack_chk_guard_ptr[0];
  v8 = (char *)&v10 - ((*(_QWORD *)a1 + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (__fastcall **)(__int64, char *, __int64))(a1 + 32))(a6, v8, a5);
  ccpad_xts_decrypt(a1, v6, v8, v7, a2, v11);
  return *(_QWORD *)__stack_chk_guard_ptr[0];
}
// AC3A: using guessed type int __fastcall ccpad_xts_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// C018: using guessed type __int64 __stack_chk_guard_ptr[175];

//----- (0000000000008C7E) ----------------------------------------------------
__int64 __fastcall ccgcm_mode_get_ctx_size(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000000008C87) ----------------------------------------------------
__int64 __fastcall ccgcm_mode_get_block_size(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (0000000000008C91) ----------------------------------------------------
int __usercall ccgcm_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4, __int64 a5)
{
  return (*(int (__fastcall **)(__int64, __int64, __int64, __int64))(a3 + 16))(a3, a5, a2, a1);
}

//----- (0000000000008CA9) ----------------------------------------------------
int __fastcall ccgcm_mode_crypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  return (*(int (__fastcall **)(__int64, __int64, __int64, __int64))(a1 + 40))(a5, a4, a2, a3);
}

//----- (0000000000008CC3) ----------------------------------------------------
__int64 __fastcall ccgcm_setiv(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  (*(void (__fastcall **)(__int64, _QWORD, __int64))(a1 + 24))(a4, a3, a2);
  return 0LL;
}

//----- (0000000000008CDD) ----------------------------------------------------
signed __int64 __fastcall ccccm_mode_get_ctx_size(__int64 a1)
{
  return *(_QWORD *)a1 + 176LL;
}

//----- (0000000000008CEB) ----------------------------------------------------
__int64 __fastcall ccccm_mode_get_block_size(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}

//----- (0000000000008CF5) ----------------------------------------------------
int __usercall ccccm_mode_setup@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4, __int64 a5)
{
  int result; // eax@1

  result = (*(int (__fastcall **)(__int64, signed __int64, __int64, __int64))(a3 + 24))(a3, a5 + 160, a2, a1);
  *(_QWORD *)(a5 + 24) = -1LL;
  *(_QWORD *)(a5 + 16) = -1LL;
  *(_QWORD *)(a5 + 8) = -1LL;
  *(_QWORD *)a5 = -1LL;
  return result;
}

//----- (0000000000008D38) ----------------------------------------------------
int __fastcall ccccm_mode_crypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  return (*(int (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(a1 + 48))(a5 + 160, a5 + 64, a4, a2, a3);
}

//----- (0000000000008D5E) ----------------------------------------------------
__int64 __fastcall ccccm_mode_done(__int64 a1, __int64 a2)
{
  (*(void (__fastcall **)(signed __int64, signed __int64, signed __int64))(a1 + 56))(a2 + 160, a2 + 64, a2 + 48);
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a2 + 152);
  return 0LL;
}

//----- (0000000000008D90) ----------------------------------------------------
__int64 __usercall ccpkcs7_encrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5@<r8>, __int64 a6)
{
  __int64 v6; // rbx@1
  __int64 v7; // rax@1

  v6 = a1;
  ccpad_pkcs7_encrypt(a1, a3 + 16, a3, a5, a2);
  LODWORD(v7) = (*(int (__fastcall **)(__int64))(a4 + 8))(v6);
  *(_QWORD *)a6 = v7;
  return 0LL;
}
// AC34: using guessed type int __fastcall ccpad_pkcs7_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000008DD6) ----------------------------------------------------
__int64 __usercall ccpkcs7_decrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5)
{
  __int64 v5; // rax@1

  LODWORD(v5) = ccpad_pkcs7_decrypt(a1, a3 + 16, a3, a4, a2);
  *(_QWORD *)a5 = v5;
  return 0LL;
}
// AC22: using guessed type int __fastcall ccpad_pkcs7_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000008E07) ----------------------------------------------------
unsigned __int64 __fastcall ccpkcs7_padlen(int a1, __int64 a2, __int64 a3, unsigned __int64 a4, char a5)
{
  unsigned __int64 v5; // r13@1
  __int64 v6; // r15@1
  __int64 v7; // rax@3
  unsigned __int64 v8; // rbx@3
  unsigned __int64 v9; // rax@3
  unsigned __int64 v10; // rax@5
  unsigned __int64 v11; // r12@6
  unsigned __int64 v12; // rax@7
  unsigned __int64 v13; // rax@8

  v5 = a4;
  v6 = a3;
  if ( a5 )
  {
    if ( a1 )
    {
      LODWORD(v7) = (*(int (__fastcall **)(__int64))(a2 + 8))(a3);
      v8 = v5 + v7;
      LODWORD(v9) = (*(int (__fastcall **)(__int64))(a2 + 8))(v6);
      v5 = v8 - v8 % v9;
    }
  }
  else if ( a1 )
  {
    LODWORD(v10) = (*(int (__fastcall **)(__int64))(a2 + 8))(a3);
    v5 -= v5 % v10;
  }
  else
  {
    v11 = 0LL;
    if ( a4 )
    {
      LODWORD(v12) = (*(int (__fastcall **)(_QWORD))(a2 + 8))(a3);
      v11 = v5 - (v5 % v12 < 1);
    }
    LODWORD(v13) = (*(int (__fastcall **)(__int64))(a2 + 8))(v6);
    v5 = v11 - v11 % v13;
  }
  return v5;
}

//----- (0000000000008EB8) ----------------------------------------------------
int __fastcall ccpkcs7_reserve(int a1, __int64 a2, __int64 a3)
{
  int result; // eax@2

  if ( a1 )
    result = 0;
  else
    result = (*(int (__fastcall **)(__int64))(a2 + 8))(a3);
  return result;
}

//----- (0000000000008ECB) ----------------------------------------------------
__int64 __fastcall ccpkcs7_encrypt_ecb_pad(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v7; // rbx@1
  __int64 v8; // rax@1

  v7 = a3;
  ccpad_pkcs7_ecb_encrypt(a3, a1, a5, a4, a6);
  LODWORD(v8) = (*(int (__fastcall **)(__int64))(a2 + 8))(v7);
  *(_QWORD *)a7 = v8;
  return 0LL;
}
// AC2E: using guessed type int __fastcall ccpad_pkcs7_ecb_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000008F0A) ----------------------------------------------------
__int64 __fastcall ccpkcs7_decrypt_ecb_pad(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v7; // rax@1

  LODWORD(v7) = ccpad_pkcs7_ecb_decrypt(a3, a1, a5, a4, a6);
  *(_QWORD *)a7 = v7;
  return 0LL;
}
// AC28: using guessed type int __fastcall ccpad_pkcs7_ecb_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000008F34) ----------------------------------------------------
__int64 __usercall cccts1_encrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5)
{
  __int64 v5; // rbx@1

  v5 = a4;
  ccpad_cts1_encrypt(a1, a3 + 16, a3, a4, a2);
  *(_QWORD *)a5 = v5;
  return 0LL;
}
// AC04: using guessed type int __fastcall ccpad_cts1_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000008F67) ----------------------------------------------------
__int64 __usercall cccts1_decrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5)
{
  __int64 v5; // rbx@1

  v5 = a4;
  ccpad_cts1_decrypt(a1, a3 + 16, a3, a4, a2);
  *(_QWORD *)a5 = v5;
  return 0LL;
}
// ABFE: using guessed type int __fastcall ccpad_cts1_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000008F9A) ----------------------------------------------------
unsigned __int64 __fastcall ccctsX_padlen(int a1, __int64 a2, __int64 a3, unsigned __int64 a4, char a5)
{
  char v5; // bl@1
  unsigned __int64 v6; // r14@1
  __int64 v7; // r12@1
  unsigned __int64 v8; // rax@1
  __int64 v9; // rax@3
  unsigned __int64 v10; // rbx@3
  unsigned __int64 v11; // rax@3
  __int64 v12; // rbx@3
  unsigned __int64 v13; // r14@6
  unsigned __int64 v14; // rax@6

  v5 = a5;
  v6 = a4;
  v7 = a3;
  LODWORD(v8) = (*(int (__fastcall **)(__int64))(a2 + 8))(a3);
  if ( !v5 )
  {
    if ( a1 )
    {
      v12 = 0LL;
      if ( v8 >= v6 )
        return v12;
      v13 = v6 - v8;
      LODWORD(v14) = (*(int (__fastcall **)(__int64))(a2 + 8))(v7);
      v6 = v13 - v13 % v14;
    }
    return v6;
  }
  if ( !a1 )
    return v6;
  LODWORD(v9) = (*(int (__fastcall **)(__int64))(a2 + 8))(v7);
  v10 = v6 + v9 - 1;
  LODWORD(v11) = (*(int (__fastcall **)(_QWORD))(a2 + 8))(v7);
  return v10 - v10 % v11;
}

//----- (0000000000009023) ----------------------------------------------------
signed __int64 __fastcall ccctsX_reserve(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax@1

  LODWORD(v3) = (*(int (__fastcall **)(__int64))(a2 + 8))(a3);
  return 2 * v3;
}

//----- (0000000000009032) ----------------------------------------------------
__int64 __usercall cccts2_encrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5)
{
  __int64 v5; // rbx@1

  v5 = a4;
  ccpad_cts2_encrypt(a1, a3 + 16, a3, a4, a2);
  *(_QWORD *)a5 = v5;
  return 0LL;
}
// AC10: using guessed type int __fastcall ccpad_cts2_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000009065) ----------------------------------------------------
__int64 __usercall cccts2_decrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5)
{
  __int64 v5; // rbx@1

  v5 = a4;
  ccpad_cts2_decrypt(a1, a3 + 16, a3, a4, a2);
  *(_QWORD *)a5 = v5;
  return 0LL;
}
// AC0A: using guessed type int __fastcall ccpad_cts2_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000009098) ----------------------------------------------------
__int64 __usercall cccts3_encrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5)
{
  __int64 v5; // rbx@1

  v5 = a4;
  ccpad_cts3_encrypt(a1, a3 + 16, a3, a4, a2);
  *(_QWORD *)a5 = v5;
  return 0LL;
}
// AC1C: using guessed type int __fastcall ccpad_cts3_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000090CB) ----------------------------------------------------
__int64 __usercall cccts3_decrypt_pad@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r8>, __int64 a5)
{
  __int64 v5; // rbx@1

  v5 = a4;
  ccpad_cts3_decrypt(a1, a3 + 16, a3, a4, a2);
  *(_QWORD *)a5 = v5;
  return 0LL;
}
// AC16: using guessed type int __fastcall ccpad_cts3_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000090FE) ----------------------------------------------------
__int64 __usercall ccnopad_encrypt_pad@<rax>(__int64 a1@<r8>, __int64 a2)
{
  *(_QWORD *)a2 = 0LL;
  return (unsigned int)-(a1 != 0);
}

//----- (0000000000009114) ----------------------------------------------------
__int64 __usercall ccnopad_decrypt_pad@<rax>(__int64 a1@<r8>, __int64 a2)
{
  *(_QWORD *)a2 = 0LL;
  return (unsigned int)-(a1 != 0);
}

//----- (000000000000912A) ----------------------------------------------------
unsigned __int64 __fastcall ccnopad_padlen(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbx@1
  unsigned __int64 v5; // rax@1

  v4 = a4;
  LODWORD(v5) = (*(int (__fastcall **)(__int64))(a2 + 8))(a3);
  return v4 - v4 % v5;
}

//----- (0000000000009151) ----------------------------------------------------
__int64 ccnopad_reserve()
{
  return 0LL;
}

//----- (0000000000009159) ----------------------------------------------------
int __fastcall rc4ModeInit(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return (*(int (__fastcall **)(__int64, __int64, __int64))(ccrc4_eay_ptr[0] + 8))(a2, a3, a4);
}
// C040: using guessed type __int64 ccrc4_eay_ptr[170];

//----- (0000000000009171) ----------------------------------------------------
int rc4crypt()
{
  return (*(int (**)(void))(ccrc4_eay_ptr[0] + 16))();
}
// C040: using guessed type __int64 ccrc4_eay_ptr[170];

//----- (0000000000009180) ----------------------------------------------------
int __fastcall CC_RC4_set_key(__int64 a1, int a2)
{
  return (*(int (__fastcall **)(__int64, _QWORD))(ccrc4_eay_ptr[0] + 8))(a1, a2);
}
// C040: using guessed type __int64 ccrc4_eay_ptr[170];

//----- (0000000000009192) ----------------------------------------------------
int CC_RC4()
{
  return (*(int (**)(void))(ccrc4_eay_ptr[0] + 16))();
}
// C040: using guessed type __int64 ccrc4_eay_ptr[170];

//----- (00000000000091A1) ----------------------------------------------------
int CCDesIsWeakKey()
{
  return ccdes_key_is_weak();
}
// AAEA: using guessed type int ccdes_key_is_weak(void);

//----- (00000000000091AB) ----------------------------------------------------
int CCDesSetOddParity()
{
  return ccdes_key_set_odd_parity();
}
// AAF0: using guessed type int ccdes_key_set_odd_parity(void);

//----- (00000000000091B5) ----------------------------------------------------
int CCDesCBCCksum()
{
  return ccdes_cbc_cksum();
}
// AAE4: using guessed type int ccdes_cbc_cksum(void);

//----- (00000000000091BF) ----------------------------------------------------
signed __int64 __fastcall CNCRC(unsigned int a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r14@1
  __int64 v5; // r15@1
  __int64 v6; // rbx@2
  signed __int64 v7; // rdx@4
  __int64 v8; // rcx@4
  signed __int64 result; // rax@4
  unsigned __int64 v10; // rax@6
  __int64 v11; // rdi@7
  __int64 v12; // rax@12
  __int64 v13; // [sp+0h] [bp-50h]@3
  int v14; // [sp+8h] [bp-48h]@3
  int v15; // [sp+Ch] [bp-44h]@3
  __int64 (__fastcall *v16)(__int64); // [sp+10h] [bp-40h]@3
  __int64 *v17; // [sp+18h] [bp-38h]@3
  __int64 v18; // [sp+20h] [bp-30h]@3

  v4 = a4;
  v5 = a3;
  if ( *(_QWORD *)(_os_alloc_once_table_ptr[0] + 96) == -1LL )
  {
    v6 = *(_QWORD *)(_os_alloc_once_table_ptr[0] + 104);
  }
  else
  {
    LODWORD(v12) = _os_alloc_once(_os_alloc_once_table_ptr[0] + 96, 3376LL, 0LL);
    v6 = v12;
  }
  v13 = _NSConcreteStackBlock_ptr[0];
  v14 = 0x40000000;
  v15 = 0;
  v16 = __getDesc_block_invoke;
  v17 = &__block_descriptor_tmp_5;
  v18 = v6;
  if ( *(_QWORD *)v6 != -1LL )
    dispatch_once(v6, &v13);
  v7 = 32LL * a1;
  v8 = *(_QWORD *)(v6 + v7 + 16);
  result = 4294962991LL;
  if ( v8 )
  {
    if ( *(_DWORD *)(v8 + 8) )
    {
      LODWORD(v10) = (*(int (__fastcall **)(__int64, __int64))(v8 + 40))(v5, a2);
    }
    else
    {
      v11 = v6 + v7 + 8;
      if ( *(_DWORD *)(v8 + 20) )
        v10 = crc_reverse_oneshot(v11, a2, v5);
      else
        v10 = crc_normal_oneshot(v11, a2, v5);
    }
    *(_QWORD *)v4 = v10;
    result = 0LL;
  }
  return result;
}
// AA12: using guessed type int __fastcall _os_alloc_once(_QWORD, _QWORD, _QWORD);
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// C020: using guessed type __int64 _os_alloc_once_table_ptr[174];
// D530: using guessed type __int64 __block_descriptor_tmp_5;

//----- (00000000000092B2) ----------------------------------------------------
signed __int64 __fastcall CNCRCInit(unsigned int a1, __int64 a2)
{
  void *v2; // r12@1
  signed __int64 result; // rax@1
  __int64 v4; // rbx@3
  signed __int64 v5; // rax@5
  __int64 v6; // rdi@5
  __int64 v7; // rax@5
  __int64 v8; // rax@7
  __int64 v9; // rax@14
  __int64 v10; // [sp+8h] [bp-48h]@4
  int v11; // [sp+10h] [bp-40h]@4
  int v12; // [sp+14h] [bp-3Ch]@4
  __int64 (__fastcall *v13)(__int64); // [sp+18h] [bp-38h]@4
  __int64 *v14; // [sp+20h] [bp-30h]@4
  __int64 v15; // [sp+28h] [bp-28h]@4

  v2 = malloc(0x18uLL);
  result = 4294962994LL;
  if ( v2 )
  {
    if ( *(_QWORD *)(_os_alloc_once_table_ptr[0] + 96) == -1LL )
    {
      v4 = *(_QWORD *)(_os_alloc_once_table_ptr[0] + 104);
    }
    else
    {
      LODWORD(v9) = _os_alloc_once(_os_alloc_once_table_ptr[0] + 96, 3376LL, 0LL);
      v4 = v9;
    }
    v10 = _NSConcreteStackBlock_ptr[0];
    v11 = 0x40000000;
    v12 = 0;
    v13 = __getDesc_block_invoke;
    v14 = &__block_descriptor_tmp_5;
    v15 = v4;
    if ( *(_QWORD *)v4 != -1LL )
      dispatch_once(v4, &v10);
    v5 = 32LL * a1;
    v6 = v4 + v5 + 8;
    *(_QWORD *)v2 = v6;
    v7 = *(_QWORD *)(v4 + v5 + 16);
    if ( v7 )
    {
      *((_QWORD *)v2 + 2) = 0LL;
      *((_QWORD *)v2 + 1) = 0LL;
      if ( *(_DWORD *)(v7 + 8) )
      {
        LODWORD(v8) = (*(int (**)(void))(v7 + 16))();
      }
      else if ( *(_DWORD *)(v7 + 20) )
      {
        v8 = crc_reverse_init(v6);
      }
      else
      {
        v8 = crc_normal_init(v6);
      }
      *((_QWORD *)v2 + 1) = v8;
      *(_QWORD *)a2 = v2;
      result = 0LL;
    }
    else
    {
      free(v2);
      result = 4294962991LL;
    }
  }
  return result;
}
// AA12: using guessed type int __fastcall _os_alloc_once(_QWORD, _QWORD, _QWORD);
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// C020: using guessed type __int64 _os_alloc_once_table_ptr[174];
// D530: using guessed type __int64 __block_descriptor_tmp_5;

//----- (00000000000093CD) ----------------------------------------------------
__int64 __fastcall CNCRCRelease(void *a1)
{
  free(a1);
  return 0LL;
}

//----- (00000000000093DA) ----------------------------------------------------
__int64 __fastcall CNCRCUpdate(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14@1
  __int64 *v4; // rbx@1
  __int64 v5; // rdi@1
  __int64 v6; // rax@1
  unsigned __int64 v7; // rax@2
  unsigned __int64 v8; // rcx@3

  v3 = a3;
  v4 = a1;
  v5 = *a1;
  v6 = *(_QWORD *)(v5 + 8);
  if ( *(_DWORD *)(v6 + 8) == 1 )
  {
    LODWORD(v7) = (*(int (__fastcall **)(__int64, __int64, __int64))(v6 + 24))(a3, a2, v4[1]);
  }
  else
  {
    v8 = v4[1];
    if ( *(_DWORD *)(v6 + 20) )
      v7 = crc_reverse_update(v5, a2, a3, v8);
    else
      v7 = crc_normal_update(v5, a2, a3, v8);
  }
  v4[1] = v7;
  v4[2] += v3;
  return 0LL;
}

//----- (000000000000942B) ----------------------------------------------------
__int64 __fastcall CNCRCFinal(__int64 *a1, __int64 a2)
{
  __int64 v2; // r14@1
  __int64 *v3; // rbx@1
  __int64 v4; // rdi@1
  __int64 v5; // rax@1
  __int64 v6; // rax@2
  __int64 v7; // rsi@3

  v2 = a2;
  v3 = a1;
  v4 = *a1;
  v5 = *(_QWORD *)(v4 + 8);
  if ( *(_DWORD *)(v5 + 8) == 1 )
  {
    LODWORD(v6) = (*(int (__fastcall **)(__int64, __int64))(v5 + 32))(v3[2], v3[1]);
  }
  else
  {
    v7 = v3[1];
    if ( *(_DWORD *)(v5 + 20) )
      v6 = crc_reverse_final(v4, v7);
    else
      v6 = crc_normal_final(v4, v7);
  }
  v3[1] = v6;
  *(_QWORD *)v2 = v6;
  return 0LL;
}

//----- (0000000000009476) ----------------------------------------------------
signed __int64 __fastcall CNCRCDumpTable(unsigned int a1)
{
  __int64 v1; // rbx@2
  signed __int64 v2; // rcx@4
  __int64 v3; // rdx@4
  signed __int64 result; // rax@4
  __int64 v5; // rbx@6
  __int64 v6; // rax@7
  __int64 v7; // rax@11
  __int64 v8; // [sp+8h] [bp-38h]@3
  int v9; // [sp+10h] [bp-30h]@3
  int v10; // [sp+14h] [bp-2Ch]@3
  __int64 (__fastcall *v11)(__int64); // [sp+18h] [bp-28h]@3
  __int64 *v12; // [sp+20h] [bp-20h]@3
  __int64 v13; // [sp+28h] [bp-18h]@3

  if ( *(_QWORD *)(_os_alloc_once_table_ptr[0] + 96) == -1LL )
  {
    v1 = *(_QWORD *)(_os_alloc_once_table_ptr[0] + 104);
  }
  else
  {
    LODWORD(v7) = _os_alloc_once(_os_alloc_once_table_ptr[0] + 96, 3376LL, 0LL);
    v1 = v7;
  }
  v8 = _NSConcreteStackBlock_ptr[0];
  v9 = 0x40000000;
  v10 = 0;
  v11 = __getDesc_block_invoke;
  v12 = &__block_descriptor_tmp_5;
  v13 = v1;
  if ( *(_QWORD *)v1 != -1LL )
    dispatch_once(v1, &v8);
  v2 = 32LL * a1;
  v3 = *(_QWORD *)(v1 + v2 + 16);
  result = 4294962991LL;
  if ( v3 )
  {
    result = 4294962996LL;
    if ( !*(_DWORD *)(v3 + 8) )
    {
      v5 = v1 + v2 + 8;
      if ( *(_DWORD *)(v3 + 20) )
        v6 = crc_reverse_init(v5);
      else
        v6 = crc_normal_init(v5);
      dump_crc_table(v6, v5);
      result = 0LL;
    }
  }
  return result;
}
// AA12: using guessed type int __fastcall _os_alloc_once(_QWORD, _QWORD, _QWORD);
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// C020: using guessed type __int64 _os_alloc_once_table_ptr[174];
// D530: using guessed type __int64 __block_descriptor_tmp_5;

//----- (000000000000954A) ----------------------------------------------------
__int64 __fastcall CNCRCWeakTest(unsigned int a1)
{
  __int64 v1; // rbx@2
  signed __int64 v2; // rcx@4
  __int64 v3; // rdx@4
  __int64 result; // rax@4
  __int64 v5; // rdi@6
  signed __int64 v6; // rbx@6
  unsigned __int64 v7; // rax@7
  __int64 v8; // rax@11
  __int64 v9; // [sp+8h] [bp-38h]@3
  int v10; // [sp+10h] [bp-30h]@3
  int v11; // [sp+14h] [bp-2Ch]@3
  __int64 (__fastcall *v12)(__int64); // [sp+18h] [bp-28h]@3
  __int64 *v13; // [sp+20h] [bp-20h]@3
  __int64 v14; // [sp+28h] [bp-18h]@3

  if ( *(_QWORD *)(_os_alloc_once_table_ptr[0] + 96) == -1LL )
  {
    v1 = *(_QWORD *)(_os_alloc_once_table_ptr[0] + 104);
  }
  else
  {
    LODWORD(v8) = _os_alloc_once(_os_alloc_once_table_ptr[0] + 96, 3376LL, 0LL);
    v1 = v8;
  }
  v9 = _NSConcreteStackBlock_ptr[0];
  v10 = 0x40000000;
  v11 = 0;
  v12 = __getDesc_block_invoke;
  v13 = &__block_descriptor_tmp_5;
  v14 = v1;
  if ( *(_QWORD *)v1 != -1LL )
    dispatch_once(v1, &v9);
  v2 = 32LL * a1;
  v3 = *(_QWORD *)(v1 + v2 + 16);
  result = 0LL;
  if ( v3 && *(_DWORD *)(v3 + 8) != 1 )
  {
    v5 = v1 + v2 + 8;
    v6 = v1 + v2 + 16;
    if ( *(_DWORD *)(v3 + 20) )
      v7 = crc_reverse_oneshot(v5, (__int64)"123456789", 9LL);
    else
      v7 = crc_normal_oneshot(v5, (__int64)"123456789", 9LL);
    result = v7 != *(_QWORD *)(*(_QWORD *)v6 + 56LL);
  }
  return result;
}
// AA12: using guessed type int __fastcall _os_alloc_once(_QWORD, _QWORD, _QWORD);
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// C020: using guessed type __int64 _os_alloc_once_table_ptr[174];
// D530: using guessed type __int64 __block_descriptor_tmp_5;

//----- (0000000000009633) ----------------------------------------------------
__int64 __fastcall __getDesc_block_invoke(__int64 a1)
{
  __int64 result; // rax@1

  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 336LL) = &crc8;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 368LL) = &crc8_icode;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 400LL) = &crc8_itu;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 432LL) = &crc8_rohc;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 464LL) = &crc8_wcdma;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 656LL) = &crc16;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 688LL) = &crc16_ccitt_true;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 720LL) = &crc16_ccitt_false;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 752LL) = &crc16_usb;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 784LL) = &crc16_xmodem;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 816LL) = &crc16_dect_r;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 848LL) = &crc16_dect_x;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 880LL) = &crc16_icode;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 912LL) = &crc16_verifone;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 944LL) = &crc16_a;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 976LL) = &crc16_b;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1008LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1296LL) = adler32;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1328LL) = crc32;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1360LL) = &crc32_castagnoli;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1392LL) = &crc32_bzip2;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1424LL) = &crc32_mpeg_2;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1456LL) = &crc32_posix;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1488LL) = &crc32_xfer;
  result = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(result + 1936) = &crc64_ecma_182;
  return result;
}
// C5D0: using guessed type char *crc16_a;
// C610: using guessed type char *crc16_b;
// C650: using guessed type char *crc16_ccitt_false;
// C690: using guessed type char *crc16_ccitt_true;
// C6D0: using guessed type char *crc16_dect_r;
// C710: using guessed type char *crc16_dect_x;
// C750: using guessed type char *crc16_icode;
// C790: using guessed type char *crc16_usb;
// C7D0: using guessed type char *crc16_verifone;
// C810: using guessed type char *crc16_xmodem;
// C850: using guessed type char *crc16;
// C890: using guessed type char *crc32_bzip2;
// C8D0: using guessed type char *crc32_castagnoli;
// C910: using guessed type char *crc32_mpeg_2;
// C950: using guessed type char *crc32_posix;
// C990: using guessed type char *crc32_xfer;
// CA10: using guessed type char *crc64_ecma_182;
// CA50: using guessed type char *crc8_icode;
// CA90: using guessed type char *crc8_itu;
// CAD0: using guessed type char *crc8_rohc;
// CB10: using guessed type char *crc8_wcdma;
// CB50: using guessed type char *crc8;

//----- (00000000000097F8) ----------------------------------------------------
__int64 __fastcall CNEncoderCreate(unsigned int a1, int a2, __int64 a3)
{
  __int64 v3; // r15@1
  signed int v4; // ecx@1
  __int64 v5; // r13@4
  __int64 v6; // rdx@6
  signed __int64 v7; // r14@7
  void *v8; // rax@9
  void *v9; // rbx@9
  __int64 v10; // rax@10
  size_t v11; // rdi@10
  __int64 v12; // rax@11
  void *v13; // rax@13
  void *v14; // r12@13
  __int64 v15; // rax@13
  size_t v16; // rdi@13
  __int64 v17; // rax@14
  void *v18; // rax@16
  __int64 v20; // rax@25
  __int64 v21; // r14@26
  signed __int64 v22; // [sp+8h] [bp-88h]@7
  __int64 v23; // [sp+10h] [bp-80h]@7
  int v24; // [sp+18h] [bp-78h]@7
  int v25; // [sp+1Ch] [bp-74h]@7
  __int64 (__fastcall *v26)(__int64); // [sp+20h] [bp-70h]@7
  __int64 *v27; // [sp+28h] [bp-68h]@7
  __int64 v28; // [sp+30h] [bp-60h]@7
  unsigned int v29; // [sp+38h] [bp-58h]@7
  __int64 v30; // [sp+40h] [bp-50h]@6
  int v31; // [sp+48h] [bp-48h]@6
  int v32; // [sp+4Ch] [bp-44h]@6
  __int64 (__fastcall *v33)(__int64); // [sp+50h] [bp-40h]@6
  __int64 *v34; // [sp+58h] [bp-38h]@6
  __int64 v35; // [sp+60h] [bp-30h]@6

  v3 = a3;
  v4 = -4300;
  if ( (unsigned int)(a2 - 1) <= 1 && a3 )
  {
    *(_QWORD *)a3 = 0LL;
    if ( *(_QWORD *)(_os_alloc_once_table_ptr[0] + 96) == -1LL )
    {
      v5 = *(_QWORD *)(_os_alloc_once_table_ptr[0] + 104);
    }
    else
    {
      LODWORD(v20) = _os_alloc_once(_os_alloc_once_table_ptr[0] + 96, 3376LL, 0LL);
      v4 = -4300;
      v5 = v20;
    }
    if ( a1 <= 6 )
    {
      v6 = _NSConcreteStackBlock_ptr[0];
      v30 = _NSConcreteStackBlock_ptr[0];
      v31 = 0x40000000;
      v32 = 0;
      v33 = __getCodeFrame_block_invoke;
      v34 = &__block_descriptor_tmp_6;
      v35 = v5;
      if ( *(_QWORD *)(v5 + 1960) != -1LL )
      {
        v21 = _NSConcreteStackBlock_ptr[0];
        dispatch_once(v5 + 1960, &v30);
        v6 = v21;
        v4 = -4300;
      }
      v7 = 3LL * a1;
      v22 = v5 + 24LL * a1 + 1968;
      v23 = v6;
      v24 = 0x40000000;
      v25 = 0;
      v26 = __getCodeFrame_block_invoke_2;
      v27 = &__block_descriptor_tmp1_1;
      v28 = v5;
      v29 = a1;
      if ( *(_QWORD *)v22 != -1LL )
      {
        dispatch_once(v22, &v23);
        v4 = -4300;
      }
      if ( *(_QWORD *)(v5 + 24LL * a1 + 1976) )
      {
        v8 = malloc(0x20uLL);
        v9 = v8;
        v4 = -4302;
        if ( v8 )
        {
          *((_DWORD *)v8 + 2) = a2;
          *(_QWORD *)v8 = v22;
          *((_QWORD *)v8 + 3) = 0LL;
          *((_QWORD *)v8 + 2) = 0LL;
          v10 = *(_QWORD *)(v5 + 24LL * a1 + 1984);
          v11 = 0LL;
          if ( v10 )
          {
            v12 = *(_QWORD *)(v10 + 24);
            v11 = 0LL;
            if ( v12 )
              v11 = *(_DWORD *)(v12 + 8);
          }
          v13 = CNBufferCreate(v11);
          *((_QWORD *)v9 + 2) = v13;
          v14 = v13;
          v15 = *(_QWORD *)(v5 + 8 * v7 + 1984);
          v16 = 0LL;
          if ( v15 )
          {
            v17 = *(_QWORD *)(v15 + 24);
            v16 = 0LL;
            if ( v17 )
              v16 = *(_DWORD *)(v17 + 12);
          }
          v18 = CNBufferCreate(v16);
          *((_QWORD *)v9 + 3) = v18;
          if ( v14 && v18 )
          {
            *(_QWORD *)v3 = v9;
            v4 = 0;
          }
          else
          {
            if ( v14 )
            {
              CNBufferRelease((void **)v9 + 2);
              v18 = (void *)*((_QWORD *)v9 + 3);
            }
            if ( v18 )
              CNBufferRelease((void **)v9 + 3);
            free(v9);
            v4 = -4302;
          }
        }
      }
    }
  }
  return (unsigned int)v4;
}
// AA12: using guessed type int __fastcall _os_alloc_once(_QWORD, _QWORD, _QWORD);
// AA84: using guessed type int __fastcall dispatch_once(_QWORD, _QWORD);
// C010: using guessed type __int64 _NSConcreteStackBlock_ptr[176];
// C020: using guessed type __int64 _os_alloc_once_table_ptr[174];
// D550: using guessed type __int64 __block_descriptor_tmp_6;
// D570: using guessed type __int64 __block_descriptor_tmp1_1;

//----- (0000000000009A35) ----------------------------------------------------
__int64 __fastcall CNEncoderCreateCustom(__int64 a1, unsigned __int8 a2, __int64 a3, char a4, int a5, __int64 a6)
{
  int v6; // ebx@1
  __int64 v7; // r12@1
  signed int v8; // er15@1
  unsigned __int64 v9; // rax@2
  signed __int64 v10; // rdx@3
  __int64 v11; // r15@6
  void *v12; // rax@6
  void *v13; // rdx@9
  bool v14; // cl@9
  size_t v15; // rdi@12
  void *v16; // rcx@13
  __int64 v17; // rax@14
  bool v18; // r12@18
  void *v19; // rbx@18
  void *v20; // rdi@18
  void *v22; // rbx@31
  size_t v23; // rdi@31
  __int64 v24; // rax@32
  __int64 v25; // rax@33
  void *v26; // rax@35
  __int64 v27; // [sp+8h] [bp-48h]@6
  char v28; // [sp+14h] [bp-3Ch]@6
  void *v29; // [sp+18h] [bp-38h]@6
  void *v30; // [sp+20h] [bp-30h]@6

  v6 = a5;
  v7 = a3;
  v8 = -4300;
  if ( (unsigned int)(a5 - 1) <= 1 )
  {
    v9 = (unsigned __int8)(a2 - 16);
    if ( (unsigned int)v9 <= 0x30 )
    {
      v10 = 281474976776193LL;
      if ( _bittest((const unsigned __int64 *)&v10, v9) )
      {
        if ( a6 && v7 )
        {
          v28 = a4;
          *(_QWORD *)a6 = 0LL;
          v27 = a6;
          v11 = (__int64)malloc(0x18uLL);
          v30 = malloc(0x28uLL);
          v12 = malloc(0x20uLL);
          v29 = v12;
          if ( v11 )
          {
            v12 = malloc(0x100uLL);
            *(_QWORD *)(v11 + 8) = v12;
          }
          if ( v29 )
          {
            v13 = v30;
            v14 = v30 != 0LL;
            *((_QWORD *)v29 + 3) = 0LL;
            *((_QWORD *)v29 + 2) = 0LL;
            if ( v11 )
            {
              if ( v30 )
              {
                v14 = 1;
                if ( v12 )
                {
                  *((_BYTE *)v30 + 32) = a2;
                  *((_QWORD *)v30 + 3) = (char *)encoderValue + 20 * (a2 >> 5);
                  *(_QWORD *)v30 = a1;
                  *((_QWORD *)v30 + 2) = v7;
                  *((_BYTE *)v30 + 33) = v28;
                  *((_DWORD *)v30 + 2) = 51966;
                  *(_QWORD *)(v11 + 16) = v30;
                  setReverseMap(v11);
                  *(_QWORD *)v29 = v11;
                  *((_DWORD *)v29 + 2) = v6;
                  v15 = 0LL;
                  if ( v11 )
                  {
                    v16 = v30;
                    if ( v30 )
                    {
                      v17 = *((_QWORD *)v30 + 3);
                      v15 = 0LL;
                      if ( v17 )
                        v15 = *(_DWORD *)(v17 + 8);
                    }
                  }
                  else
                  {
                    v16 = v30;
                  }
                  v22 = v16;
                  *((_QWORD *)v29 + 2) = CNBufferCreate(v15);
                  v23 = 0LL;
                  if ( *(_QWORD *)v29 )
                  {
                    v24 = *(_QWORD *)(*(_QWORD *)v29 + 16LL);
                    v23 = 0LL;
                    if ( v24 )
                    {
                      v25 = *(_QWORD *)(v24 + 24);
                      v23 = 0LL;
                      if ( v25 )
                        v23 = *(_DWORD *)(v25 + 12);
                    }
                  }
                  v26 = CNBufferCreate(v23);
                  *((_QWORD *)v29 + 3) = v26;
                  if ( *((_QWORD *)v29 + 2) )
                  {
                    v13 = v22;
                    v14 = 1;
                    if ( v26 )
                    {
                      *(_QWORD *)v27 = v29;
                      v8 = 0;
                      return (unsigned int)v8;
                    }
                  }
                  else
                  {
                    v13 = v22;
                    v14 = 1;
                  }
                }
              }
            }
          }
          else
          {
            v13 = v30;
            v14 = v30 != 0LL;
          }
          if ( v11 )
          {
            v18 = v14;
            v19 = v13;
            v20 = *(void **)(v11 + 8);
            if ( v20 )
              free(v20);
            free((void *)v11);
            v13 = v19;
            v14 = v18;
          }
          if ( v14 )
            free(v13);
          v8 = -4302;
          if ( v29 )
          {
            if ( *((_QWORD *)v29 + 2) )
              CNBufferRelease((void **)v29 + 2);
            if ( *((_QWORD *)v29 + 3) )
              CNBufferRelease((void **)v29 + 3);
            free(v29);
          }
        }
      }
    }
  }
  return (unsigned int)v8;
}
// BA60: using guessed type __int64 encoderValue[7];

//----- (0000000000009CA6) ----------------------------------------------------
__int64 __fastcall setReverseMap(__int64 a1)
{
  __int64 v1; // rcx@1
  __int64 result; // rax@1

  memset(*(void **)(a1 + 8), 128, 0x100uLL);
  v1 = *(_QWORD *)(a1 + 16);
  result = 0LL;
  if ( *(_BYTE *)(v1 + 32) )
  {
    do
    {
      *(_BYTE *)(*(_QWORD *)(a1 + 8) + *(_BYTE *)(*(_QWORD *)(v1 + 16) + result)) = result;
      ++result;
      v1 = *(_QWORD *)(a1 + 16);
    }
    while ( (signed int)result < *(_BYTE *)(v1 + 32) );
  }
  return result;
}

//----- (0000000000009CF4) ----------------------------------------------------
__int64 __fastcall CNEncoderRelease(void **a1)
{
  void *v1; // rbx@1
  __int64 v2; // r14@2
  __int64 v3; // rax@2

  v1 = *a1;
  *a1 = 0LL;
  if ( v1 )
  {
    v2 = *(_QWORD *)v1;
    v3 = *(_QWORD *)(*(_QWORD *)v1 + 16LL);
    if ( v3 && *(_DWORD *)(v3 + 8) == 51966 )
    {
      free(*(void **)(v2 + 8));
      free(*(void **)(v2 + 16));
    }
    if ( *((_QWORD *)v1 + 2) )
      CNBufferRelease((void **)v1 + 2);
    if ( *((_QWORD *)v1 + 3) )
      CNBufferRelease((void **)v1 + 3);
    free(v1);
  }
  return 0LL;
}

//----- (0000000000009D60) ----------------------------------------------------
unsigned __int64 __fastcall CNEncoderGetOutputLength(__int64 a1, __int64 a2)
{
  unsigned __int64 result; // rax@1
  int v3; // ecx@2
  __int64 v4; // rsi@3
  __int64 v5; // rax@4
  __int64 v6; // rcx@5
  __int64 v7; // rcx@6
  __int64 v8; // rax@10
  bool v9; // zf@10
  __int64 v10; // rsi@10
  __int64 v11; // rcx@12
  __int64 v12; // rdx@13

  result = 0LL;
  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 8);
    result = 0LL;
    if ( v3 == 2 )
    {
      result = 0LL;
      v4 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL) + a2;
      if ( v4 )
      {
        v5 = 0LL;
        if ( *(_QWORD *)a1 )
        {
          v6 = *(_QWORD *)(*(_QWORD *)a1 + 16LL);
          v5 = 0LL;
          if ( v6 )
          {
            v7 = *(_QWORD *)(v6 + 24);
            v5 = 0LL;
            if ( v7 )
              v5 = *(_DWORD *)(v7 + 4);
          }
        }
        result = (unsigned __int64)(v4 * v5 + 8) >> 3;
      }
    }
    else if ( v3 == 1 )
    {
      v8 = *(_QWORD *)(a1 + 16);
      v9 = *(_QWORD *)(v8 + 8) + a2 == 0;
      v10 = *(_QWORD *)(v8 + 8) + a2;
      result = 1LL;
      if ( !v9 )
      {
        result = 1LL;
        if ( *(_QWORD *)a1 )
        {
          v11 = *(_QWORD *)(*(_QWORD *)a1 + 16LL);
          result = 1LL;
          if ( v11 )
          {
            v12 = *(_QWORD *)(v11 + 24);
            result = 1LL;
            if ( v12 )
            {
              result = 1LL;
              if ( *(_DWORD *)(v12 + 8) )
              {
                result = 1LL;
                if ( *(_DWORD *)(v12 + 12) )
                  result = *(_DWORD *)(v12 + 12)
                         * ((v10 + (unsigned __int64)*(_DWORD *)(v12 + 8) - 1)
                          / *(_DWORD *)(v12 + 8))
                         + 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0000000000009E24) ----------------------------------------------------
unsigned __int64 __fastcall encodeLen(__int64 a1, __int64 a2)
{
  unsigned __int64 result; // rax@1
  __int64 v3; // rcx@4
  __int64 v4; // rdx@5

  result = 0LL;
  if ( a2 )
  {
    if ( a1 )
    {
      result = 0LL;
      if ( *(_QWORD *)a1 )
      {
        v3 = *(_QWORD *)(*(_QWORD *)a1 + 16LL);
        result = 0LL;
        if ( v3 )
        {
          v4 = *(_QWORD *)(v3 + 24);
          result = 0LL;
          if ( v4 )
          {
            result = 0LL;
            if ( *(_DWORD *)(v4 + 8) )
            {
              result = 0LL;
              if ( *(_DWORD *)(v4 + 12) )
                result = (a2 + (unsigned __int64)*(_DWORD *)(v4 + 8) - 1) / *(_DWORD *)(v4 + 8) * *(_DWORD *)(v4 + 12);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0000000000009E7B) ----------------------------------------------------
unsigned __int64 __fastcall decodeLen(__int64 a1, __int64 a2)
{
  unsigned __int64 result; // rax@1
  __int64 v3; // rax@2
  __int64 v4; // rcx@4
  __int64 v5; // rcx@5

  result = 0LL;
  if ( a2 )
  {
    v3 = 0LL;
    if ( a1 )
    {
      v3 = 0LL;
      if ( *(_QWORD *)a1 )
      {
        v4 = *(_QWORD *)(*(_QWORD *)a1 + 16LL);
        v3 = 0LL;
        if ( v4 )
        {
          v5 = *(_QWORD *)(v4 + 24);
          v3 = 0LL;
          if ( v5 )
            v3 = *(_DWORD *)(v5 + 4);
        }
      }
    }
    result = (unsigned __int64)(a2 * v3 + 8) >> 3;
  }
  return result;
}

//----- (0000000000009EBE) ----------------------------------------------------
unsigned __int64 __usercall CNEncoderGetOutputLengthFromEncoding@<rax>(__int64 a1@<rax>, __int64 a2@<rdx>, unsigned int a3@<edi>, int a4@<esi>)
{
  __int64 v4; // r14@1
  unsigned __int64 v5; // r15@1
  __int64 v6; // r15@4
  __int64 v7; // rax@6
  __int64 v8; // rax@7
  __int64 v9; // rax@14
  __int64 v10; // rax@15
  __int64 v12; // [sp+0h] [bp-20h]@1

  v12 = a1;
  v4 = a2;
  v5 = 0LL;
  if ( !(unsigned int)CNEncoderCreate(a3, a4, (__int64)&v12) )
  {
    v5 = 0LL;
    if ( a4 == 2 )
    {
      v5 = 0LL;
      if ( v4 )
      {
        v6 = 0LL;
        if ( v12 )
        {
          v6 = 0LL;
          if ( *(_QWORD *)v12 )
          {
            v7 = *(_QWORD *)(*(_QWORD *)v12 + 16LL);
            v6 = 0LL;
            if ( v7 )
            {
              v8 = *(_QWORD *)(v7 + 24);
              v6 = 0LL;
              if ( v8 )
                v6 = *(_DWORD *)(v8 + 4);
            }
          }
        }
        v5 = (unsigned __int64)(v4 * v6 + 8) >> 3;
      }
    }
    else if ( a4 == 1 )
    {
      v5 = 1LL;
      if ( v4 )
      {
        if ( v12 )
        {
          v5 = 1LL;
          if ( *(_QWORD *)v12 )
          {
            v9 = *(_QWORD *)(*(_QWORD *)v12 + 16LL);
            v5 = 1LL;
            if ( v9 )
            {
              v10 = *(_QWORD *)(v9 + 24);
              v5 = 1LL;
              if ( v10 )
              {
                v5 = 1LL;
                if ( *(_DWORD *)(v10 + 8) )
                {
                  v5 = 1LL;
                  if ( *(_DWORD *)(v10 + 12) )
                    v5 = *(_DWORD *)(v10 + 12)
                       * ((v4 + (unsigned __int64)*(_DWORD *)(v10 + 8) - 1)
                        / *(_DWORD *)(v10 + 8))
                       + 1;
                }
              }
            }
          }
        }
      }
    }
    CNEncoderRelease((void **)&v12);
  }
  return v5;
}

//----- (0000000000009FC2) ----------------------------------------------------
__int64 __fastcall CNEncoderUpdate(__int64 a1, const void *a2, unsigned __int64 a3, __int64 a4, unsigned __int64 *a5)
{
  unsigned __int64 *v5; // r9@1
  __int64 v6; // r8@1
  unsigned __int64 v7; // rcx@1
  const void *v8; // rdx@1
  __int64 v9; // rsi@1
  __int64 result; // rax@1
  int v11; // edi@5

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  result = 4294962996LL;
  if ( a1 && v6 && v5 )
  {
    if ( v8 )
    {
      v11 = *(_DWORD *)(a1 + 8);
      if ( v11 == 2 )
      {
        result = CNBufferProcessData(
                   *(_QWORD *)(v9 + 24),
                   v9,
                   v8,
                   v7,
                   v6,
                   v5,
                   (void (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))deCode,
                   (int (__fastcall *)(_QWORD, _QWORD))decodeLen);
      }
      else if ( v11 == 1 )
      {
        result = CNBufferProcessData(
                   *(_QWORD *)(v9 + 16),
                   v9,
                   v8,
                   v7,
                   v6,
                   v5,
                   (void (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))enCode,
                   (int (__fastcall *)(_QWORD, _QWORD))encodeLen);
      }
    }
    else if ( !v7 )
    {
      *v5 = 0LL;
      result = 0LL;
    }
  }
  return result;
}

//----- (000000000000A04E) ----------------------------------------------------
signed __int64 __fastcall enCode(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r14@1
  __int64 v6; // r15@1
  __int64 v7; // rbx@1
  __int64 v8; // r12@1
  unsigned int v9; // er13@2
  __int64 v10; // rax@3
  __int64 v11; // rax@4
  __int64 v12; // rax@9
  __int64 v13; // rax@10
  unsigned __int64 v14; // rcx@11
  __int64 v15; // rsi@12
  unsigned __int64 v16; // rdx@13
  bool v17; // cf@14
  signed __int64 result; // rax@14
  int v19; // er10@15
  unsigned __int64 v20; // rsi@15
  __int64 v21; // r9@15
  unsigned __int64 v22; // rax@16
  int v23; // ecx@16
  unsigned __int8 v24; // of@16
  int v25; // ecx@16
  signed __int64 v26; // rcx@20
  signed __int64 v27; // rax@21
  __int64 v28; // rdx@21
  __int64 v29; // r8@22
  __int64 v30; // rdi@22
  char v31; // bl@22
  __int64 v32; // [sp+8h] [bp-48h]@15
  unsigned __int64 v33; // [sp+10h] [bp-40h]@15
  unsigned __int64 v34; // [sp+20h] [bp-30h]@15

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( !a1 )
    goto LABEL_33;
  v9 = 0;
  if ( *(_QWORD *)a1 )
  {
    v10 = *(_QWORD *)(*(_QWORD *)a1 + 16LL);
    if ( v10 )
    {
      v11 = *(_QWORD *)(v10 + 24);
      if ( v11 )
        v9 = *(_DWORD *)(v11 + 4);
    }
  }
  if ( a3
    && a1
    && *(_QWORD *)a1
    && (v12 = *(_QWORD *)(*(_QWORD *)a1 + 16LL)) != 0
    && (v13 = *(_QWORD *)(v12 + 24)) != 0
    && (v14 = *(_DWORD *)(v13 + 8)) != 0
    && (v15 = *(_DWORD *)(v13 + 12)) != 0
    && (v16 = v15 * ((a3 + v14 - 1) / v14)) != 0 )
  {
    v17 = *(_QWORD *)a5 < v16;
    *(_QWORD *)a5 = v16;
    result = 0xFFFFFFFFLL;
    if ( v17 )
      return result;
    v32 = v15;
    v33 = v14;
    v34 = v16;
    __bzero(v5);
    v19 = 8 - v9;
    v20 = 0LL;
    v21 = v6;
    do
    {
      v22 = v20 / (signed int)v9;
      *(_BYTE *)(v5 + v22) |= (unsigned __int8)((unsigned int)*(_BYTE *)v7 >> (v19 + v20 % (signed int)v9)) & *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 16LL) + 24LL) + 16LL);
      v23 = v19 + v20 % (signed int)v9;
      v24 = __OFSUB__(v23, v9);
      v25 = v23 - v9;
      if ( (unsigned __int8)((v25 < 0) ^ v24) | (v25 == 0) )
        LOBYTE(v25) = v19 + v20 % (signed int)v9;
      else
        *(_BYTE *)(v5 + v22++ + 1) |= (unsigned __int8)((unsigned int)*(_BYTE *)v7 >> v25) & *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 16LL) + 24LL) + 16LL);
      *(_BYTE *)(v22 + v5 + 1) |= (unsigned __int8)(*(_BYTE *)v7++ << (v9 - v25)) & *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 16LL) + 24LL)
                                                                                             + 16LL);
      v20 += 8LL;
      --v21;
    }
    while ( v21 );
    v26 = v22 + 2;
    if ( v22 != -2LL )
    {
      v27 = v22 + 2;
      v28 = v5;
      do
      {
        v29 = *(_BYTE *)v28;
        v30 = *(_QWORD *)(*(_QWORD *)v8 + 16LL);
        v31 = -128;
        if ( *(_BYTE *)(v30 + 32) > (unsigned int)v29 )
          v31 = *(_BYTE *)(*(_QWORD *)(v30 + 16) + v29);
        *(_BYTE *)v28++ = v31;
        --v27;
      }
      while ( v27 );
    }
    if ( v26 < v34 )
    {
      do
        *(_BYTE *)(v5 + v26++) = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v8 + 16LL) + 33LL);
      while ( v26 != v32 * ((v33 + v6 - 1) / v33) );
      v26 = v32 * ((v33 + v6 - 1) / v33);
    }
    *(_BYTE *)(v5 + v26) = 0;
  }
  else
  {
LABEL_33:
    *(_QWORD *)a5 = 0LL;
    *(_BYTE *)v5 = 0;
  }
  return 0LL;
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);

//----- (000000000000A26C) ----------------------------------------------------
__int64 __fastcall deCode(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r15@1
  __int64 v6; // r12@1
  __int64 v7; // rbx@1
  __int64 v8; // r13@1
  __int64 v9; // rax@2
  __int64 v10; // rcx@3
  int v11; // er14@3
  __int64 v12; // rcx@4
  __int64 v13; // rax@7
  __int64 v14; // rax@9
  __int64 v15; // rsi@9
  unsigned __int64 v16; // rsi@11
  unsigned __int64 v17; // rdi@12
  unsigned __int64 v18; // rdx@12
  __int64 v19; // rax@13
  unsigned int v20; // esi@14
  int v21; // eax@14
  signed __int64 v22; // rax@18
  __int64 v24; // [sp+0h] [bp-30h]@12

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( a1 )
  {
    v9 = *(_QWORD *)a1;
    if ( *(_QWORD *)a1 )
    {
      v10 = *(_QWORD *)(v9 + 16);
      v11 = 0;
      if ( !v10 )
        goto LABEL_26;
      v12 = *(_QWORD *)(v10 + 24);
      v11 = 0;
      if ( v12 )
        v11 = *(_DWORD *)(v12 + 4);
      if ( v9 )
      {
LABEL_26:
        v13 = *(_QWORD *)(v9 + 16);
        if ( v13 )
        {
          if ( a3 )
          {
            v14 = *(_QWORD *)(v13 + 24);
            v15 = 0LL;
            if ( v14 )
              v15 = *(_DWORD *)(v14 + 4);
            v16 = (unsigned __int64)(a3 * v15 + 8) >> 3;
            *(_QWORD *)a5 = v16;
            if ( v16 )
            {
              v24 = a5;
              __bzero(v5);
              v17 = 0LL;
              v18 = 0LL;
              do
              {
                v19 = *(_BYTE *)v7;
                if ( (_DWORD)v19 != *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v8 + 16LL) + 33LL) )
                {
                  v20 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v8 + 8LL) + v19);
                  v18 = v17 >> 3;
                  v21 = 8 - v11 - (v17 & 7);
                  if ( v21 < 0 )
                  {
                    *(_BYTE *)(v5 + v18) |= v20 >> -(char)v21;
                    *(_BYTE *)(v5 + v18 + 1) |= v20 << (v21 + 8);
                  }
                  else
                  {
                    *(_BYTE *)(v5 + v18) |= v20 << v21;
                  }
                }
                ++v7;
                v17 += v11;
                --v6;
              }
              while ( v6 );
              v22 = v18 + 1;
              if ( *(_BYTE *)(v5 + v18 + 1) )
                v22 = v18 + 2;
              *(_QWORD *)v24 = v22;
              return 0LL;
            }
          }
          else
          {
            *(_QWORD *)a5 = 0LL;
          }
          *(_BYTE *)v5 = 0;
          return 0LL;
        }
      }
    }
  }
  return 0LL;
}
// AA0C: using guessed type int __fastcall __bzero(_QWORD);

//----- (000000000000A3C1) ----------------------------------------------------
signed __int64 __fastcall CNEncoderFinal(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx@1
  __int64 v4; // r14@1
  __int64 v5; // rcx@1
  signed int v6; // edx@1
  int v7; // eax@4
  __int64 v9; // rdx@7
  unsigned __int64 v10; // rax@7
  __int64 v11; // rsi@9
  __int64 v12; // rdi@10
  unsigned __int64 v13; // rsi@11
  __int64 v14; // rdi@12

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = -4300;
  if ( a1 && a2 && v3 )
  {
    v7 = *(_DWORD *)(a1 + 8);
    if ( v7 == 2 )
      return CNBufferFlushData(
               *(_QWORD *)(a1 + 24),
               a1,
               a2,
               v3,
               (void (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))deCode,
               (int (__fastcall *)(_QWORD))decodeLen);
    if ( v7 == 1 )
    {
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL);
      v10 = 1LL;
      if ( v9 )
      {
        v10 = 1LL;
        if ( *(_QWORD *)a1 )
        {
          v11 = *(_QWORD *)(*(_QWORD *)a1 + 16LL);
          v10 = 1LL;
          if ( v11 )
          {
            v12 = *(_QWORD *)(v11 + 24);
            v10 = 1LL;
            if ( v12 )
            {
              v13 = *(_DWORD *)(v12 + 8);
              v10 = 1LL;
              if ( *(_DWORD *)(v12 + 8) )
              {
                v14 = *(_DWORD *)(v12 + 12);
                v10 = 1LL;
                if ( v14 )
                  v10 = v14 * ((v9 + v13 - 1) / v13) + 1;
              }
            }
          }
        }
      }
      v6 = -4301;
      if ( v10 <= *(_QWORD *)v3 )
      {
        v6 = CNBufferFlushData(
               *(_QWORD *)(v5 + 16),
               v5,
               v4,
               v3,
               (void (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))enCode,
               (int (__fastcall *)(_QWORD))encodeLen);
        if ( !v6 )
        {
          *(_BYTE *)(v4 + *(_QWORD *)v3) = 0;
          v6 = 0;
        }
      }
    }
  }
  return (unsigned int)v6;
}

//----- (000000000000A4CD) ----------------------------------------------------
__int64 __fastcall CNEncoderBlocksize(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14@1
  __int64 result; // rax@1
  __int64 v5; // rax@4
  __int64 v6; // rcx@5
  __int64 v7; // rdx@6
  __int64 v8; // rdx@7
  __int64 v9; // rcx@9
  __int64 v10; // rax@9
  __int64 v11; // rcx@10
  __int64 v12; // rcx@11
  __int64 v13; // [sp+8h] [bp-18h]@3

  v3 = a3;
  result = 4294962996LL;
  if ( a2 )
  {
    if ( a3 )
    {
      result = CNEncoderCreate(a1, 1, (__int64)&v13);
      if ( !(_DWORD)result )
      {
        v5 = v13;
        if ( v13 )
        {
          v6 = 0LL;
          if ( *(_QWORD *)v13 )
          {
            v7 = *(_QWORD *)(*(_QWORD *)v13 + 16LL);
            v6 = 0LL;
            if ( v7 )
            {
              v8 = *(_QWORD *)(v7 + 24);
              v6 = 0LL;
              if ( v8 )
                v6 = *(_DWORD *)(v8 + 8);
            }
          }
          *(_QWORD *)a2 = v6;
          v9 = *(_QWORD *)v5;
          v10 = 0LL;
          if ( v9 )
          {
            v11 = *(_QWORD *)(v9 + 16);
            v10 = 0LL;
            if ( v11 )
            {
              v12 = *(_QWORD *)(v11 + 24);
              v10 = 0LL;
              if ( v12 )
                v10 = *(_DWORD *)(v12 + 12);
            }
          }
        }
        else
        {
          *(_QWORD *)a2 = 0LL;
          v10 = 0LL;
        }
        *(_QWORD *)v3 = v10;
        CNEncoderRelease((void **)&v13);
        result = 0LL;
      }
    }
  }
  return result;
}

//----- (000000000000A577) ----------------------------------------------------
signed __int64 __fastcall CNEncoderBlocksizeFromRef(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax@1
  __int64 v4; // rax@4
  __int64 v5; // rdi@5
  __int64 v6; // rcx@5
  __int64 v7; // rdi@6
  __int64 v8; // rcx@8
  __int64 v9; // rax@8
  __int64 v10; // rcx@9

  result = 4294962996LL;
  if ( a1 && a2 && a3 )
  {
    v4 = *(_QWORD *)a1;
    if ( *(_QWORD *)a1 )
    {
      v5 = *(_QWORD *)(v4 + 16);
      v6 = 0LL;
      if ( v5 )
      {
        v7 = *(_QWORD *)(v5 + 24);
        v6 = 0LL;
        if ( v7 )
          v6 = *(_DWORD *)(v7 + 8);
      }
      *(_QWORD *)a2 = v6;
      v8 = *(_QWORD *)(v4 + 16);
      v9 = 0LL;
      if ( v8 )
      {
        v10 = *(_QWORD *)(v8 + 24);
        v9 = 0LL;
        if ( v10 )
          v9 = *(_DWORD *)(v10 + 12);
      }
    }
    else
    {
      *(_QWORD *)a2 = 0LL;
      v9 = 0LL;
    }
    *(_QWORD *)a3 = v9;
    result = 0LL;
  }
  return result;
}

//----- (000000000000A5DE) ----------------------------------------------------
__int64 __fastcall CNEncode(unsigned int a1, int a2, const void *a3, unsigned __int64 a4, __int64 a5, __int64 *a6)
{
  __int64 *v6; // r14@1
  __int64 v7; // r13@1
  unsigned __int64 v8; // r15@1
  const void *v9; // r12@1
  __int64 result; // rax@1
  __int64 v11; // rbx@5
  __int64 v12; // rax@6
  __int64 v13; // [sp+8h] [bp-38h]@4
  __int64 v14; // [sp+10h] [bp-30h]@5

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  result = 4294962996LL;
  if ( a5 )
  {
    if ( a6 )
    {
      if ( a3 )
      {
        result = CNEncoderCreate(a1, a2, (__int64)&v13);
        if ( !(_DWORD)result )
        {
          v11 = *v6;
          v14 = *v6;
          *v6 = 0LL;
          result = CNEncoderUpdate(v13, v9, v8, v7, (unsigned __int64 *)&v14);
          if ( !(_DWORD)result )
          {
            v12 = v14;
            *v6 = v14;
            v14 = v11 - v12;
            result = CNEncoderFinal(v13, v12 + v7, (__int64)&v14);
            if ( !(_DWORD)result )
            {
              *v6 += v14;
              CNEncoderRelease((void **)&v13);
              result = 0LL;
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (000000000000A68A) ----------------------------------------------------
__int64 __fastcall __getCodeFrame_block_invoke(__int64 a1)
{
  __int64 v1; // rax@1
  __int64 result; // rax@3

  v1 = 0LL;
  do
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + v1 + 1984) = 0LL;
    v1 += 24LL;
  }
  while ( v1 != 144 );
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 2008LL) = &defaultBase64;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 2032LL) = &defaultBase32;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 2056LL) = &recoveryBase32;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 2080LL) = &hexBase32;
  result = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(result + 2104) = &defaultBase16;
  return result;
}
// D590: using guessed type char *defaultBase16;
// D5B8: using guessed type char *hexBase32;
// D5E0: using guessed type char *recoveryBase32;
// D608: using guessed type char *defaultBase32;
// D630: using guessed type char *defaultBase64;

//----- (000000000000A708) ----------------------------------------------------
__int64 __fastcall __getCodeFrame_block_invoke_2(__int64 a1)
{
  void *v1; // rax@1
  __int64 v2; // rcx@1
  __int64 result; // rax@1

  v1 = malloc(0x100uLL);
  v2 = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24 * v2 + 1976) = v1;
  result = *(_QWORD *)(a1 + 32);
  if ( *(_QWORD *)(result + 24 * v2 + 1976) )
    result = setReverseMap(result + 24 * v2 + 1968);
  return result;
}

//----- (000000000000A763) ----------------------------------------------------
void *__fastcall CNBufferCreate(size_t a1)
{
  void *v1; // rbx@1
  void *result; // rax@1
  bool v3; // zf@2

  v1 = malloc(0x18uLL);
  result = 0LL;
  if ( v1 )
  {
    *(_QWORD *)v1 = a1;
    *((_QWORD *)v1 + 1) = 0LL;
    result = malloc(a1);
    *((_QWORD *)v1 + 2) = result;
    v3 = result == 0LL;
    if ( result )
      result = v1;
    if ( v3 )
    {
      free(v1);
      result = 0LL;
    }
  }
  return result;
}

//----- (000000000000A7B0) ----------------------------------------------------
__int64 __fastcall CNBufferRelease(void **a1)
{
  void *v1; // rbx@2
  void *v2; // rdi@2

  if ( a1 )
  {
    v1 = *a1;
    v2 = (void *)*((_QWORD *)*a1 + 2);
    if ( v2 )
      free(v2);
    if ( v1 )
      free(v1);
  }
  return 0LL;
}

//----- (000000000000A7E2) ----------------------------------------------------
__int64 __fastcall CNBufferProcessData(__int64 a1, __int64 a2, const void *a3, unsigned __int64 a4, __int64 a5, unsigned __int64 *a6, void (__fastcall *a7)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD), int (__fastcall *a8)(_QWORD, _QWORD))
{
  unsigned __int64 *v8; // rbx@1
  unsigned __int64 v9; // r12@1
  __int64 v10; // r13@1
  unsigned __int64 v11; // rax@1
  signed int v12; // er14@1
  unsigned __int64 v13; // r15@1
  char *v14; // rcx@2
  __int64 v15; // rdi@2
  unsigned __int64 *v16; // r12@2
  __int64 v17; // rbx@2
  size_t v18; // r13@3
  size_t v19; // rax@5
  unsigned __int64 v20; // rsi@6
  unsigned __int64 v21; // rax@6
  unsigned __int64 v22; // r14@8
  unsigned __int64 v23; // rbx@8
  unsigned __int64 v24; // rax@8
  const void *v25; // rsi@9
  char *v26; // r15@11
  unsigned __int64 v28; // [sp+18h] [bp-58h]@1
  __int64 v29; // [sp+20h] [bp-50h]@1
  __int64 v30; // [sp+28h] [bp-48h]@1
  unsigned __int64 v31; // [sp+30h] [bp-40h]@1
  const void *v32; // [sp+38h] [bp-38h]@1
  unsigned __int64 v33; // [sp+40h] [bp-30h]@1

  v8 = a6;
  v30 = a5;
  v9 = a4;
  v32 = a3;
  v29 = a2;
  v10 = a1;
  v31 = *(_QWORD *)a1;
  v28 = *a6;
  v33 = *a6;
  LODWORD(v11) = a8(a2, a4 + *(_QWORD *)(a1 + 8));
  v12 = -4301;
  v13 = v9;
  if ( v11 > v33 )
    return (unsigned int)v12;
  v14 = (char *)v32;
  *v8 = 0LL;
  v15 = *(_QWORD *)(a1 + 8);
  v16 = v8;
  v17 = v10;
  if ( v15 )
  {
    v18 = v31 - v15;
    if ( v31 - v15 >= v13 )
      v18 = v13;
    memcpy((void *)(*(_QWORD *)(v17 + 16) + v15), v32, v18);
    v19 = v18 + *(_QWORD *)(v17 + 8);
    *(_QWORD *)(v17 + 8) = v19;
    v12 = 0;
    if ( v19 < v31 )
      return (unsigned int)v12;
    a7(a2, *(_QWORD *)(v17 + 16), v31, v30, &v33);
    v20 = v31;
    v13 -= v18;
    v14 = (char *)v32 + v18;
    v21 = v33;
    v30 += v33;
    *v16 = v33;
    v28 -= v21;
    *(_QWORD *)(v17 + 8) = 0LL;
    v10 = v17;
  }
  else
  {
    v20 = v31;
  }
  v22 = v13 % v20;
  v23 = v13 - v13 % v20;
  v24 = v20;
  if ( v13 == v13 % v20 )
  {
    v12 = -4303;
    v25 = v14;
    if ( v13 > v24 )
      return (unsigned int)v12;
  }
  else
  {
    v33 = v28;
    v26 = v14;
    a7(v29, v14, v23, v30, &v33);
    v25 = &v26[v23];
    *v16 += v33;
    v13 = v22;
  }
  v12 = 0;
  if ( v13 )
  {
    memcpy(*(void **)(v10 + 16), v25, v13);
    *(_QWORD *)(v10 + 8) = v13;
  }
  return (unsigned int)v12;
}

//----- (000000000000A97F) ----------------------------------------------------
signed __int64 __fastcall CNBufferFlushData(__int64 a1, __int64 a2, __int64 a3, __int64 a4, void (__fastcall *a5)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD), int (__fastcall *a6)(_QWORD))
{
  void (__fastcall *v6)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // r14@1
  __int64 v7; // r13@1
  __int64 v8; // r15@1
  __int64 v9; // r12@1
  unsigned __int64 v10; // rsi@1
  signed __int64 result; // rax@2
  unsigned __int64 v12; // rax@3
  unsigned __int64 v13; // rcx@3

  v6 = a5;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  v10 = *(_QWORD *)(a1 + 8);
  if ( !v10 )
  {
    *(_QWORD *)a4 = 0LL;
    return 0LL;
  }
  result = 4294962993LL;
  if ( v10 <= *(_QWORD *)a1 )
  {
    LODWORD(v12) = a6(v9);
    v13 = v12;
    result = 4294962995LL;
    if ( v13 <= *(_QWORD *)v7 )
    {
      v6(v9, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 8), v8, v7);
      return 0LL;
    }
  }
  return result;
}

//----- (000000000000A9F2) ----------------------------------------------------
bool __fastcall CNBufferEmpty(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) == 0LL;
}

// ALL OK, 329 function(s) have been successfully decompiled
